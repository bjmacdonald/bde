// bslfmt_format_arg_cpp03.h                                          -*-C++-*-

// Automatically generated file.  **DO NOT EDIT**

#ifndef INCLUDED_BSLFMT_FORMAT_ARG_CPP03
#define INCLUDED_BSLFMT_FORMAT_ARG_CPP03

//@PURPOSE: Provide C++03 implementation for bslfmt_format_arg.h
//
//@CLASSES: See bslfmt_format_arg.h for list of classes
//
//@SEE_ALSO: bslfmt_format_arg
//
//@DESCRIPTION:  This component is the C++03 translation of a C++11 component,
// generated by the 'sim_cpp11_features.pl' program.  If the original header
// contains any specially delimited regions of C++11 code, then this generated
// file contains the C++03 equivalent, i.e., with variadic templates expanded
// and rvalue-references replaced by 'bslmf::MovableRef' objects.  The header
// code in this file is designed to be '#include'd into the original header
// when compiling with a C++03 compiler.  If there are no specially delimited
// regions of C++11 code, then this header contains no code and is not
// '#include'd in the original header.
//
// Generated on Wed Apr  2 17:20:16 2025
// Command line: sim_cpp11_features.pl bslfmt_format_arg.h

#ifdef COMPILING_BSLFMT_FORMAT_ARG_H

namespace BloombergLP {
namespace bslfmt {

// FORWARD DECLARATIONS

template <class t_CHAR>
class basic_format_parse_context;

template <class t_OUT, class t_CHAR>
class basic_format_context;

template <class t_CONTEXT>
class basic_format_arg;

template <class t_VALUE>
class Format_ContextOutputIteratorRef;

// TYPEDEFS

typedef basic_format_context<Format_ContextOutputIteratorRef<char>, char>
    format_context;

typedef basic_format_context<Format_ContextOutputIteratorRef<wchar_t>, wchar_t>
    wformat_context;

                        // ======================
                        // class basic_format_arg
                        // ======================

/// This class provides an STL-compliant `basic_format_arg` which holds (by
/// value for scalar and pointer types, by reference for user-defined types).
/// These types should not be constructed directly by the user.
template <class t_OUT, class t_CHAR>
class basic_format_arg<basic_format_context<t_OUT, t_CHAR> > {
  public:
    // TYPES

    /// This class provides a type-erased wrapper which holds a pointer to a
    /// user-defined type and permits its formatting using the appropriate
    /// bsl::formatter type.
    class handle {
      private:
        // DATA
        const void  *d_value_p;
                         // pointer to the referenced value

        void       (*d_format_impl_p)(basic_format_parse_context<t_CHAR>&,
                                      basic_format_context<t_OUT, t_CHAR>&,
                                      const void *);
                         // pointer to a format_impl instance

        // FRIENDS
        friend class basic_format_arg<basic_format_context<t_OUT, t_CHAR> >;

        // PRIVATE CLASS METHODS

        /// Format the specified `value` using a `bsl::formatter` instance for
        /// the specified template parameter `t_TYPE`.  The constructed
        /// formatter will parse the specification in the specified `pc`
        /// context and write the output to the specified `fc` context.
        template <class t_TYPE>
        static void format_impl(basic_format_parse_context<t_CHAR>&   pc,
                                basic_format_context<t_OUT, t_CHAR>&  fc,
                                const void                           *value);

        // PRIVATE CREATORS

        /// Create a `handle` referencing the specified `value` and initialize
        /// the contained formatting function to an instance of `format_impl`
        /// for the template parameter `t_TYPE`.
        template <class t_TYPE>
        explicit handle(const t_TYPE& value) BSLS_KEYWORD_NOEXCEPT;

      public:
        // CREATORS
#if !defined(BSLMF_MOVABLEREF_USES_RVALUE_REFERENCES)
        /// Move-construct a `handle` from the specified `rhs`.  This is
        /// required to support use within a bsl::variant on C++03, but must
        /// *not* be specified for C++11 and later as it will result in the
        /// implicit deletion of other defaulted special member functions.
        handle(bslmf::MovableRef<handle> rhs) BSLS_KEYWORD_NOEXCEPT;
#endif  // !defined(BSLMF_MOVABLEREF_USES_RVALUE_REFERENCES)

        // ACCESSORS

        /// Format the contained value using a formatter for the template
        /// parameter `t_TYPE` used in the construction of this object.  The
        /// constructed formatter will parse the specification in the specified
        /// `pc` context and write the output to the specified `fc` context.
        void format(basic_format_parse_context<t_CHAR>&  pc,
                    basic_format_context<t_OUT, t_CHAR>& fc) const;
    };

    typedef typename BloombergLP::bsls::UnspecifiedBool<basic_format_arg>
                                                   UnspecifiedBoolType;
    typedef typename UnspecifiedBoolType::BoolType BoolType;

  private:
    // NOT IMPLEMENTED
    bool operator==(const basic_format_arg&) const BSLS_KEYWORD_DELETED;

    // PRIVATE TYPES
    typedef t_CHAR char_type;

    typedef bsl::variant<bsl::monostate,
                         bool,
                         char_type,
                         int,
                         unsigned,
                         long long,
                         unsigned long long,
                         float,
                         double,
                         long double,
                         const char_type *,
                         bsl::basic_string_view<char_type>,
                         const void *,
                         handle>
        variant_type;

    // DATA
    variant_type d_value;  // the contained value or a reference thereto

    // FRIENDS
    friend class Format_ArgUtil;

    // PRIVATE CREATORS

    /// Create a `basic_format_arg` from the specified `value`, which is then
    /// held by value.
    explicit basic_format_arg(bool value) BSLS_KEYWORD_NOEXCEPT;

    /// Create a `basic_format_arg` from the specified `value`, which is then
    /// held by value.
    explicit basic_format_arg(char_type value) BSLS_KEYWORD_NOEXCEPT;

    /// Create a `basic_format_arg` from the specified `value` widened from
    /// type `char` to type `wchar_t`, which is then held by value.  This
    /// constructor only participates in overload resolution if `value` is of
    /// type `char` and `t_CHAR` is of type `wchar_t`.
    template <class t_TYPE>
    explicit basic_format_arg(
           t_TYPE value,
           typename bsl::enable_if<bsl::is_same<t_TYPE, char>::value &&
                                       bsl::is_same<char_type, wchar_t>::value,
                                   int>::type = 0) BSLS_KEYWORD_NOEXCEPT;

    /// Create a `basic_format_arg` from the specified `value`, which is then
    /// held by value.  This constructor only participates in overload
    /// resolution if `value` is an signed integer type that can be held within
    /// a `long long` or an unsigned integer type that can be held within an
    /// `unsigned long long`.
    template <class t_TYPE>
    explicit basic_format_arg(
           t_TYPE value,
           typename bsl::enable_if<bsl::is_integral<t_TYPE>::value &&
                                       !bsl::is_same<t_TYPE, char>::value &&
                                       !bsl::is_same<t_TYPE, wchar_t>::value &&
                                       (sizeof(t_TYPE) <= sizeof(long long)),
                                   int>::type = 0) BSLS_KEYWORD_NOEXCEPT;

    /// Create a `basic_format_arg` from the specified `value`, which is then
    /// held by reference in a `basic_format_arg::handle`.  This constructor
    /// only participates in overload resolution if `value` is not an integer
    /// or if `value` is a signed integer type that can not be held within a
    /// `long long` or an unsigned integer type that can not be held within an
    /// `unsigned long long`.  Participation in overload resolution is also
    /// disabled if `value` is of type `long double`.
    template <class t_TYPE>
    explicit basic_format_arg(
         const t_TYPE& value,
         typename bsl::enable_if<(!bsl::is_integral<t_TYPE>::value &&
                                  !bsl::is_same<t_TYPE, long double>::value) ||
                                     (sizeof(t_TYPE) > sizeof(long long)),
                                 int>::type = 0) BSLS_KEYWORD_NOEXCEPT;

    /// Create a `basic_format_arg` from the specified `value`, which is then
    /// held by value.
    explicit basic_format_arg(float value) BSLS_KEYWORD_NOEXCEPT;

    /// Create a `basic_format_arg` from the specified `value`, which is then
    /// held by value.
    explicit basic_format_arg(double value) BSLS_KEYWORD_NOEXCEPT;

    /// Terminate by calling BSLMF_ASSERT.  This constructor only participates
    /// in overload resolution if `value` is of the currently unsupported type
    /// `long double`.  Note: this is required to use a template parameter to
    /// ensure that this function is only instantiated when an attempt is made
    /// to use it.
    template <class t_TYPE>
    explicit basic_format_arg(
           t_TYPE value,
           typename bsl::enable_if<bsl::is_same<t_TYPE, long double>::value,
                                   int>::type = 0) BSLS_KEYWORD_NOEXCEPT;

    /// Create a `basic_format_arg` from the specified `value`, which is then
    /// held by value.
    template <class t_TRAITS>
    explicit basic_format_arg(
      bsl::basic_string_view<char_type, t_TRAITS> value) BSLS_KEYWORD_NOEXCEPT;

#ifdef BSLS_LIBRARYFEATURES_HAS_CPP17_BASELINE_LIBRARY
#ifndef BSLSTL_STRING_VIEW_IS_ALIASED
    /// Create a `basic_format_arg` from the specified `value`, which is then
    /// held by value.
    template <class t_TRAITS>
    explicit basic_format_arg(
      std::basic_string_view<char_type, t_TRAITS> value) BSLS_KEYWORD_NOEXCEPT;
#endif
#endif

    /// Create a `basic_format_arg` holding (by value) a `string_view`
    /// constructed from the specified `value`.
    template <class t_TRAITS, class t_ALLOC>
    explicit basic_format_arg(bsl::basic_string<char_type, t_TRAITS, t_ALLOC>&
                                  value) BSLS_KEYWORD_NOEXCEPT;

    /// Create a `basic_format_arg` holding (by value) a `string_view`
    /// constructed from the specified `value`.
    template <class t_TRAITS, class t_ALLOC>
    explicit basic_format_arg(
                  const bsl::basic_string<char_type, t_TRAITS, t_ALLOC>& value)
        BSLS_KEYWORD_NOEXCEPT;

    /// Create a `basic_format_arg` holding (by value) a `string_view`
    /// constructed from the specified `value`.
    template <class t_TRAITS, class t_ALLOC>
    explicit basic_format_arg(std::basic_string<char_type, t_TRAITS, t_ALLOC>&
                                  value) BSLS_KEYWORD_NOEXCEPT;

    /// Create a `basic_format_arg` holding (by value) a `string_view`
    /// constructed from the specified `value`.
    template <class t_TRAITS, class t_ALLOC>
    explicit basic_format_arg(
                  const std::basic_string<char_type, t_TRAITS, t_ALLOC>& value)
        BSLS_KEYWORD_NOEXCEPT;

    /// Create a `basic_format_arg` from the specified `value`, which is then
    /// held by value.
    explicit basic_format_arg(char_type *value) BSLS_KEYWORD_NOEXCEPT;

    /// Create a `basic_format_arg` from the specified `value`, which is then
    /// held by value.
    explicit basic_format_arg(const char_type *value) BSLS_KEYWORD_NOEXCEPT;

    /// Create a `basic_format_arg` from the specified `value`, which is then
    /// held by value.
    explicit basic_format_arg(void *value) BSLS_KEYWORD_NOEXCEPT;

    /// Create a `basic_format_arg` from the specified `value`, which is then
    /// held by value.
    explicit basic_format_arg(const void *value) BSLS_KEYWORD_NOEXCEPT;

    /// Create a `basic_format_arg` which holds
    /// `static_cast<const void *>(nullptr)`.
    explicit basic_format_arg(bsl::nullptr_t) BSLS_KEYWORD_NOEXCEPT;

  public:
    // CREATORS

    /// Create a `basic_format_arg` which holds a `bsl::monostate`.
    basic_format_arg() BSLS_KEYWORD_NOEXCEPT;

#if !defined(BSLMF_MOVABLEREF_USES_RVALUE_REFERENCES)
    /// Move-construct a `basic_format_arg` from the specified `rhs`.  This is
    /// required to support use on C++03, but must *not* be specified for C++11
    /// and later as it will result in the implicit deletion of other defaulted
    /// special member functions.
    basic_format_arg(
                bslmf::MovableRef<basic_format_arg> rhs) BSLS_KEYWORD_NOEXCEPT;
#endif  // !defined(BSLMF_MOVABLEREF_USES_RVALUE_REFERENCES)

    // ACCESSORS

    /// Return whether this object holds a value.
    operator BoolType() const BSLS_KEYWORD_NOEXCEPT;

    // MANIPULATORS

#if !defined(BSLMF_MOVABLEREF_USES_RVALUE_REFERENCES)
    /// Move-assign a `basic_format_arg` from the specified `rhs`.  This is
    /// required to support use on C++03, but must *not* be specified for C++11
    /// and later as it will result in the implicit deletion of other defaulted
    /// special member functions.
    basic_format_arg &operator=(
                bslmf::MovableRef<basic_format_arg> rhs) BSLS_KEYWORD_NOEXCEPT;
#endif  // !defined(BSLMF_MOVABLEREF_USES_RVALUE_REFERENCES)

#if defined(BSLS_LIBRARYFEATURES_HAS_CPP14_BASELINE_LIBRARY) &&               \
    defined(BSLS_LIBRARYFEATURES_HAS_CPP14_INTEGER_SEQUENCE)
    // This check is a proxy for BSL_VARIANT_FULL_IMPLEMENTATION which is unset
    // at the end of bslstl_variant.h

    /// Invoke the specified `visitor` functor on the value contained by this
    /// object, providing that functor non-modifiable access to that value.
    /// `visitor` must be a `variant`-style functor that is able to visit all
    /// supported types listed in the {DESCRIPTION}.
    template <class t_VISITOR>
    decltype(auto) visit(t_VISITOR&& visitor);
#else
    /// Invoke the specified `visitor` functor on the value contained by this
    /// object, providing that functor non-modifiable access to that value.
    /// `visitor` must be a `variant`-style functor that is able to visit all
    /// supported types listed in the {DESCRIPTION}.
    template <class t_VISITOR>
    typename bsl::invoke_result<t_VISITOR&, bsl::monostate&>::type visit(
                                                           t_VISITOR& visitor);
#endif

    // HIDDEN FRIENDS

    /// Exchange the values of the specified `lhs` and `rhs`.
    friend void swap(basic_format_arg& lhs, basic_format_arg& rhs)
    {
        lhs.d_value.swap(rhs.d_value);
    }
};

                            // ====================
                            // class Format_ArgUtil
                            // ====================

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslfmt_format_arg.h
#ifndef BSLFMT_FORMAT_ARG_VARIADIC_LIMIT
#define BSLFMT_FORMAT_ARG_VARIADIC_LIMIT 10
#endif
#ifndef BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_A
#define BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_A BSLFMT_FORMAT_ARG_VARIADIC_LIMIT
#endif
class Format_ArgUtil {
  public:

#if BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_A >= 0
    template <class t_CONTEXT>
    static void makeFormatArgArray(
      bsl::array<basic_format_arg<t_CONTEXT>,  0u> *out);
#endif  // BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_A >= 0

#if BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_A >= 1
    template <class t_CONTEXT, class t_FMTARGS_01>
    static void makeFormatArgArray(
      bsl::array<basic_format_arg<t_CONTEXT>,  1u> *out,
      t_FMTARGS_01& fmt_args_01);
#endif  // BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_A >= 1

#if BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_A >= 2
    template <class t_CONTEXT, class t_FMTARGS_01,
                               class t_FMTARGS_02>
    static void makeFormatArgArray(
      bsl::array<basic_format_arg<t_CONTEXT>,  2u> *out,
      t_FMTARGS_01& fmt_args_01,
      t_FMTARGS_02& fmt_args_02);
#endif  // BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_A >= 2

#if BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_A >= 3
    template <class t_CONTEXT, class t_FMTARGS_01,
                               class t_FMTARGS_02,
                               class t_FMTARGS_03>
    static void makeFormatArgArray(
      bsl::array<basic_format_arg<t_CONTEXT>,  3u> *out,
      t_FMTARGS_01& fmt_args_01,
      t_FMTARGS_02& fmt_args_02,
      t_FMTARGS_03& fmt_args_03);
#endif  // BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_A >= 3

#if BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_A >= 4
    template <class t_CONTEXT, class t_FMTARGS_01,
                               class t_FMTARGS_02,
                               class t_FMTARGS_03,
                               class t_FMTARGS_04>
    static void makeFormatArgArray(
      bsl::array<basic_format_arg<t_CONTEXT>,  4u> *out,
      t_FMTARGS_01& fmt_args_01,
      t_FMTARGS_02& fmt_args_02,
      t_FMTARGS_03& fmt_args_03,
      t_FMTARGS_04& fmt_args_04);
#endif  // BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_A >= 4

#if BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_A >= 5
    template <class t_CONTEXT, class t_FMTARGS_01,
                               class t_FMTARGS_02,
                               class t_FMTARGS_03,
                               class t_FMTARGS_04,
                               class t_FMTARGS_05>
    static void makeFormatArgArray(
      bsl::array<basic_format_arg<t_CONTEXT>,  5u> *out,
      t_FMTARGS_01& fmt_args_01,
      t_FMTARGS_02& fmt_args_02,
      t_FMTARGS_03& fmt_args_03,
      t_FMTARGS_04& fmt_args_04,
      t_FMTARGS_05& fmt_args_05);
#endif  // BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_A >= 5

#if BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_A >= 6
    template <class t_CONTEXT, class t_FMTARGS_01,
                               class t_FMTARGS_02,
                               class t_FMTARGS_03,
                               class t_FMTARGS_04,
                               class t_FMTARGS_05,
                               class t_FMTARGS_06>
    static void makeFormatArgArray(
      bsl::array<basic_format_arg<t_CONTEXT>,  6u> *out,
      t_FMTARGS_01& fmt_args_01,
      t_FMTARGS_02& fmt_args_02,
      t_FMTARGS_03& fmt_args_03,
      t_FMTARGS_04& fmt_args_04,
      t_FMTARGS_05& fmt_args_05,
      t_FMTARGS_06& fmt_args_06);
#endif  // BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_A >= 6

#if BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_A >= 7
    template <class t_CONTEXT, class t_FMTARGS_01,
                               class t_FMTARGS_02,
                               class t_FMTARGS_03,
                               class t_FMTARGS_04,
                               class t_FMTARGS_05,
                               class t_FMTARGS_06,
                               class t_FMTARGS_07>
    static void makeFormatArgArray(
      bsl::array<basic_format_arg<t_CONTEXT>,  7u> *out,
      t_FMTARGS_01& fmt_args_01,
      t_FMTARGS_02& fmt_args_02,
      t_FMTARGS_03& fmt_args_03,
      t_FMTARGS_04& fmt_args_04,
      t_FMTARGS_05& fmt_args_05,
      t_FMTARGS_06& fmt_args_06,
      t_FMTARGS_07& fmt_args_07);
#endif  // BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_A >= 7

#if BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_A >= 8
    template <class t_CONTEXT, class t_FMTARGS_01,
                               class t_FMTARGS_02,
                               class t_FMTARGS_03,
                               class t_FMTARGS_04,
                               class t_FMTARGS_05,
                               class t_FMTARGS_06,
                               class t_FMTARGS_07,
                               class t_FMTARGS_08>
    static void makeFormatArgArray(
      bsl::array<basic_format_arg<t_CONTEXT>,  8u> *out,
      t_FMTARGS_01& fmt_args_01,
      t_FMTARGS_02& fmt_args_02,
      t_FMTARGS_03& fmt_args_03,
      t_FMTARGS_04& fmt_args_04,
      t_FMTARGS_05& fmt_args_05,
      t_FMTARGS_06& fmt_args_06,
      t_FMTARGS_07& fmt_args_07,
      t_FMTARGS_08& fmt_args_08);
#endif  // BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_A >= 8

#if BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_A >= 9
    template <class t_CONTEXT, class t_FMTARGS_01,
                               class t_FMTARGS_02,
                               class t_FMTARGS_03,
                               class t_FMTARGS_04,
                               class t_FMTARGS_05,
                               class t_FMTARGS_06,
                               class t_FMTARGS_07,
                               class t_FMTARGS_08,
                               class t_FMTARGS_09>
    static void makeFormatArgArray(
      bsl::array<basic_format_arg<t_CONTEXT>,  9u> *out,
      t_FMTARGS_01& fmt_args_01,
      t_FMTARGS_02& fmt_args_02,
      t_FMTARGS_03& fmt_args_03,
      t_FMTARGS_04& fmt_args_04,
      t_FMTARGS_05& fmt_args_05,
      t_FMTARGS_06& fmt_args_06,
      t_FMTARGS_07& fmt_args_07,
      t_FMTARGS_08& fmt_args_08,
      t_FMTARGS_09& fmt_args_09);
#endif  // BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_A >= 9

#if BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_A >= 10
    template <class t_CONTEXT, class t_FMTARGS_01,
                               class t_FMTARGS_02,
                               class t_FMTARGS_03,
                               class t_FMTARGS_04,
                               class t_FMTARGS_05,
                               class t_FMTARGS_06,
                               class t_FMTARGS_07,
                               class t_FMTARGS_08,
                               class t_FMTARGS_09,
                               class t_FMTARGS_10>
    static void makeFormatArgArray(
      bsl::array<basic_format_arg<t_CONTEXT>, 10u> *out,
      t_FMTARGS_01& fmt_args_01,
      t_FMTARGS_02& fmt_args_02,
      t_FMTARGS_03& fmt_args_03,
      t_FMTARGS_04& fmt_args_04,
      t_FMTARGS_05& fmt_args_05,
      t_FMTARGS_06& fmt_args_06,
      t_FMTARGS_07& fmt_args_07,
      t_FMTARGS_08& fmt_args_08,
      t_FMTARGS_09& fmt_args_09,
      t_FMTARGS_10& fmt_args_10);
#endif  // BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_A >= 10

};
#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
class Format_ArgUtil {
  public:

    template <class t_CONTEXT, class... t_FMTARGS>
    static void makeFormatArgArray(
      bsl::array<basic_format_arg<t_CONTEXT>, sizeof...(t_FMTARGS)> *out,
      t_FMTARGS&...                                                  fmt_args);
};

// }}} END GENERATED CODE
#endif

// FREE FUNCTIONS

#if defined(BSLS_LIBRARYFEATURES_HAS_CPP14_BASELINE_LIBRARY) &&               \
    defined(BSLS_LIBRARYFEATURES_HAS_CPP14_INTEGER_SEQUENCE)
    // This check is a proxy for BSL_VARIANT_FULL_IMPLEMENTATION which is unset
    // at the end of bslstl_variant.h

/// Invoke the specified `visitor` functor on the value contained by the
/// specified `arg`, providing that functor non-modifiable access to that
/// value.  `visitor` must be a `variant`-style functor that is able to visit
/// all supported types listed in the {DESCRIPTION}.
template <class t_VISITOR, class t_CONTEXT>
decltype(auto) visit_format_arg(t_VISITOR&&                 visitor,
                                basic_format_arg<t_CONTEXT> arg);
#else

/// Invoke the specified `visitor` functor on the value contained by the
/// specified `arg`, providing that functor non-modifiable access to that
/// value.  `visitor` must be a `variant`-style functor that is able to visit
/// all supported types listed in the {DESCRIPTION}.
template <class t_VISITOR, class t_CONTEXT>
typename bsl::invoke_result<t_VISITOR&, bsl::monostate&>::type
visit_format_arg(t_VISITOR& visitor, basic_format_arg<t_CONTEXT> arg);
#endif

// ============================================================================
//                           INLINE DEFINITIONS
// ============================================================================

                         // ----------------------
                         // class basic_format_arg
                         // ----------------------

// PRIVATE CLASS METHODS
template <class t_OUT, class t_CHAR>
template <class t_TYPE>
inline
void
basic_format_arg<basic_format_context<t_OUT, t_CHAR> >::handle::format_impl(
                                   basic_format_parse_context<t_CHAR>&   pc,
                                   basic_format_context<t_OUT, t_CHAR>&  fc,
                                   const void                           *value)
{
    bsl::formatter<t_TYPE, t_CHAR> f;
    pc.advance_to(f.parse(pc));
    fc.advance_to(f.format(*static_cast<const t_TYPE *>(value), fc));
}

// PRIVATE CREATORS
template <class t_OUT, class t_CHAR>
template <class t_TYPE>
inline
basic_format_arg<basic_format_context<t_OUT, t_CHAR> >::handle::handle(
                                     const t_TYPE& value) BSLS_KEYWORD_NOEXCEPT
: d_value_p(BSLS_UTIL_ADDRESSOF(value))
, d_format_impl_p(format_impl<t_TYPE>)
{
}

// CREATORS
#if !defined(BSLMF_MOVABLEREF_USES_RVALUE_REFERENCES)
template <class t_OUT, class t_CHAR>
inline
basic_format_arg<basic_format_context<t_OUT, t_CHAR> >::handle::handle(
                           bslmf::MovableRef<handle> rhs) BSLS_KEYWORD_NOEXCEPT
{
    d_value_p = bslmf::MovableRefUtil::move(
                                 bslmf::MovableRefUtil::access(rhs).d_value_p);
    d_format_impl_p = bslmf::MovableRefUtil::move(
                           bslmf::MovableRefUtil::access(rhs).d_format_impl_p);
}
#endif  // !defined(BSLMF_MOVABLEREF_USES_RVALUE_REFERENCES)

// ACCESSORS
template <class t_OUT, class t_CHAR>
inline
void basic_format_arg<basic_format_context<t_OUT, t_CHAR> >::handle::format(
                                 basic_format_parse_context<t_CHAR>&  pc,
                                 basic_format_context<t_OUT, t_CHAR>& fc) const
{
    d_format_impl_p(pc, fc, d_value_p);
}

                         // ----------------------
                         // class basic_format_arg
                         // ----------------------

// MANIPULATORS

#if defined(BSLS_LIBRARYFEATURES_HAS_CPP14_BASELINE_LIBRARY) &&               \
    defined(BSLS_LIBRARYFEATURES_HAS_CPP14_INTEGER_SEQUENCE)
    // This check is a proxy for BSL_VARIANT_FULL_IMPLEMENTATION which is unset
    // at the end of bslstl_variant.h
template <class t_OUT, class t_CHAR>
template <class t_VISITOR>
inline
decltype(auto) basic_format_arg<basic_format_context<t_OUT, t_CHAR> >::visit(
                                                                 t_VISITOR&& v)
{
    auto thisCopy(*this);
    return bsl::visit(std::forward<t_VISITOR>(v), thisCopy.d_value);
}
#else
template <class t_OUT, class t_CHAR>
template <class t_VISITOR>
inline
typename bsl::invoke_result<t_VISITOR&, bsl::monostate&>::type
basic_format_arg<basic_format_context<t_OUT, t_CHAR> >::visit(t_VISITOR& v)
{
    basic_format_arg thisCopy(*this);
    return bsl::visit(v, thisCopy.d_value);
}
#endif

// PRIVATE CREATORS
template <class t_OUT, class t_CHAR>
inline
basic_format_arg<basic_format_context<t_OUT, t_CHAR> >::basic_format_arg(
                                              bool value) BSLS_KEYWORD_NOEXCEPT
: d_value(value)
{
}

template <class t_OUT, class t_CHAR>
inline
basic_format_arg<basic_format_context<t_OUT, t_CHAR> >::basic_format_arg(
                                         char_type value) BSLS_KEYWORD_NOEXCEPT
: d_value(value)
{
}

template <class t_OUT, class t_CHAR>
template <class t_TYPE>
inline
basic_format_arg<basic_format_context<t_OUT, t_CHAR> >::basic_format_arg(
           t_TYPE value,
           typename bsl::enable_if<bsl::is_same<t_TYPE, char>::value &&
                                       bsl::is_same<char_type, wchar_t>::value,
                                   int>::type) BSLS_KEYWORD_NOEXCEPT
{
    static const std::ctype<wchar_t>& ct =
                  std::use_facet<std::ctype<wchar_t> >(std::locale::classic());
    d_value = ct.widen(value);
}

template <class t_OUT, class t_CHAR>
template <class t_TYPE>
inline
basic_format_arg<basic_format_context<t_OUT, t_CHAR> >::basic_format_arg(
           t_TYPE value,
           typename bsl::enable_if<bsl::is_integral<t_TYPE>::value &&
                                       !bsl::is_same<t_TYPE, char>::value &&
                                       !bsl::is_same<t_TYPE, wchar_t>::value &&
                                       (sizeof(t_TYPE) <= sizeof(long long)),
                                   int>::type) BSLS_KEYWORD_NOEXCEPT
{
    if (static_cast<t_TYPE>(-1) < static_cast<t_TYPE>(0)) {
        // `t_TYPE` is signed
        if (sizeof(t_TYPE) <= sizeof(int)) {
            d_value.template emplace<int>(static_cast<int>(value));
        }
        else {
            d_value.template emplace<long long>(value);
        }
    }
    else {
        // `t_TYPE` is unsigned
        if (sizeof(t_TYPE) <= sizeof(int)) {
            d_value.template emplace<unsigned int>(
                                             static_cast<unsigned int>(value));
        }
        else {
            d_value.template emplace<unsigned long long>(value);
        }
    }
}

template <class t_OUT, class t_CHAR>
template <class t_TYPE>
inline
basic_format_arg<basic_format_context<t_OUT, t_CHAR> >::basic_format_arg(
         const t_TYPE& value,
         typename bsl::enable_if<(!bsl::is_integral<t_TYPE>::value &&
                                  !bsl::is_same<t_TYPE, long double>::value) ||
                                     (sizeof(t_TYPE) > sizeof(long long)),
                                 int>::type) BSLS_KEYWORD_NOEXCEPT
: d_value(handle(value))
{
}

template <class t_OUT, class t_CHAR>
inline
basic_format_arg<basic_format_context<t_OUT, t_CHAR> >::basic_format_arg(
                                             float value) BSLS_KEYWORD_NOEXCEPT
: d_value(value)
{
}

template <class t_OUT, class t_CHAR>
inline
basic_format_arg<basic_format_context<t_OUT, t_CHAR> >::basic_format_arg(
                                            double value) BSLS_KEYWORD_NOEXCEPT
: d_value(value)
{
}

template <class t_OUT, class t_CHAR>
template <class t_TYPE>
inline
basic_format_arg<basic_format_context<t_OUT, t_CHAR> >::basic_format_arg(
              t_TYPE value,
              typename bsl::enable_if<bsl::is_same<t_TYPE, long double>::value,
                                      int>::type) BSLS_KEYWORD_NOEXCEPT
: d_value(static_cast<long double>(value))
{
#ifdef BSLS_COMPILERFEATURES_SUPPORT_STATIC_ASSERT
    static_assert(!bsl::is_same<t_TYPE, long double>::value,
                  "long double not supported by bsl::format");
#else
    BSLMF_ASSERT((!bsl::is_same<t_TYPE, long double>::value));
#endif
}

template <class t_OUT, class t_CHAR>
template <class t_TRAITS>
inline
basic_format_arg<basic_format_context<t_OUT, t_CHAR> >::basic_format_arg(
       bsl::basic_string_view<char_type, t_TRAITS> value) BSLS_KEYWORD_NOEXCEPT
: d_value(static_cast<bsl::basic_string_view<char_type> >(value))
{
}

#ifdef BSLS_LIBRARYFEATURES_HAS_CPP17_BASELINE_LIBRARY
#ifndef BSLSTL_STRING_VIEW_IS_ALIASED
template <class t_OUT, class t_CHAR>
template <class t_TRAITS>
inline
basic_format_arg<basic_format_context<t_OUT, t_CHAR> >::basic_format_arg(
       std::basic_string_view<char_type, t_TRAITS> value) BSLS_KEYWORD_NOEXCEPT
: d_value(static_cast<bsl::basic_string_view<char_type> >(value))
{
}
#endif
#endif

template <class t_OUT, class t_CHAR>
template <class t_TRAITS, class t_ALLOC>
inline
basic_format_arg<basic_format_context<t_OUT, t_CHAR> >::basic_format_arg(
  bsl::basic_string<char_type, t_TRAITS, t_ALLOC>& value) BSLS_KEYWORD_NOEXCEPT
: d_value(static_cast<bsl::basic_string_view<char_type> >(value))
{
}

template <class t_OUT, class t_CHAR>
template <class t_TRAITS, class t_ALLOC>
inline
basic_format_arg<basic_format_context<t_OUT, t_CHAR> >::basic_format_arg(
                  const bsl::basic_string<char_type, t_TRAITS, t_ALLOC>& value)
    BSLS_KEYWORD_NOEXCEPT
: d_value(static_cast<bsl::basic_string_view<char_type> >(value))
{
}

template <class t_OUT, class t_CHAR>
template <class t_TRAITS, class t_ALLOC>
inline
basic_format_arg<basic_format_context<t_OUT, t_CHAR> >::basic_format_arg(
  std::basic_string<char_type, t_TRAITS, t_ALLOC>& value) BSLS_KEYWORD_NOEXCEPT
: d_value(static_cast<bsl::basic_string_view<char_type> >(value))
{
}

template <class t_OUT, class t_CHAR>
template <class t_TRAITS, class t_ALLOC>
inline
basic_format_arg<basic_format_context<t_OUT, t_CHAR> >::basic_format_arg(
                  const std::basic_string<char_type, t_TRAITS, t_ALLOC>& value)
    BSLS_KEYWORD_NOEXCEPT
: d_value(static_cast<bsl::basic_string_view<char_type> >(value))
{
}

template <class t_OUT, class t_CHAR>
inline
basic_format_arg<basic_format_context<t_OUT, t_CHAR> >::basic_format_arg(
                                        char_type *value) BSLS_KEYWORD_NOEXCEPT
: d_value(static_cast<const char_type *>(value))
{
}

template <class t_OUT, class t_CHAR>
inline
basic_format_arg<basic_format_context<t_OUT, t_CHAR> >::basic_format_arg(
                                  const char_type *value) BSLS_KEYWORD_NOEXCEPT
: d_value(value)
{
}

template <class t_OUT, class t_CHAR>
inline
basic_format_arg<basic_format_context<t_OUT, t_CHAR> >::basic_format_arg(
                                             void *value) BSLS_KEYWORD_NOEXCEPT
: d_value(static_cast<const void *>(value))
{
}

template <class t_OUT, class t_CHAR>
inline
basic_format_arg<basic_format_context<t_OUT, t_CHAR> >::basic_format_arg(
                                       const void *value) BSLS_KEYWORD_NOEXCEPT
: d_value(value)
{
}

template <class t_OUT, class t_CHAR>
inline
basic_format_arg<basic_format_context<t_OUT, t_CHAR> >::basic_format_arg(
                                          bsl::nullptr_t) BSLS_KEYWORD_NOEXCEPT

#if defined(BSLS_COMPILERFEATURES_SUPPORT_NULLPTR)
: d_value(static_cast<const void *>(nullptr))
#else
: d_value(static_cast<const void *>(0))
#endif
{
}

// CREATORS
template <class t_OUT, class t_CHAR>
inline
basic_format_arg<basic_format_context<t_OUT, t_CHAR> >::basic_format_arg()
    BSLS_KEYWORD_NOEXCEPT
{
}

#if !defined(BSLMF_MOVABLEREF_USES_RVALUE_REFERENCES)
template <class t_OUT, class t_CHAR>
inline
basic_format_arg<basic_format_context<t_OUT, t_CHAR> >::basic_format_arg(
                 bslmf::MovableRef<basic_format_arg> rhs) BSLS_KEYWORD_NOEXCEPT
{
    d_value = bslmf::MovableRefUtil::move(
                                   bslmf::MovableRefUtil::access(rhs).d_value);
}
#endif  // !defined(BSLMF_MOVABLEREF_USES_RVALUE_REFERENCES)

// ACCESSORS
template <class t_OUT, class t_CHAR>
inline
basic_format_arg<basic_format_context<t_OUT, t_CHAR> >::operator BoolType()
    const BSLS_KEYWORD_NOEXCEPT
{
    return UnspecifiedBoolType::makeValue(
                             !bsl::holds_alternative<bsl::monostate>(d_value));
}

// MANIPULATORS
#if !defined(BSLMF_MOVABLEREF_USES_RVALUE_REFERENCES)
template <class t_OUT, class t_CHAR>
inline
basic_format_arg<basic_format_context<t_OUT, t_CHAR> > &
basic_format_arg<basic_format_context<t_OUT, t_CHAR> >::operator=(
                 bslmf::MovableRef<basic_format_arg> rhs) BSLS_KEYWORD_NOEXCEPT
{
    d_value = bslmf::MovableRefUtil::move(
                                   bslmf::MovableRefUtil::access(rhs).d_value);
    return *this;
}
#endif  // !defined(BSLMF_MOVABLEREF_USES_RVALUE_REFERENCES)

                            // --------------------
                            // class Format_ArgUtil
                            // --------------------

// CLASS METHODS

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslfmt_format_arg.h
#ifndef BSLFMT_FORMAT_ARG_VARIADIC_LIMIT
#define BSLFMT_FORMAT_ARG_VARIADIC_LIMIT 10
#endif
#ifndef BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_B
#define BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_B BSLFMT_FORMAT_ARG_VARIADIC_LIMIT
#endif
#if BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_B >= 0
template <class t_CONTEXT>
inline
void Format_ArgUtil::makeFormatArgArray(
       bsl::array<basic_format_arg<t_CONTEXT>,  0u> *out)
{
#ifndef BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS
    bsl::array<basic_format_arg<t_CONTEXT>,  0u> tmp = {
        {}};
    *out = bslmf::MovableRefUtil::move(tmp);
#else
    *out = { {} };
#endif
}
#endif  // BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_B >= 0

#if BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_B >= 1
template <class t_CONTEXT, class t_FMTARGS_01>
inline
void Format_ArgUtil::makeFormatArgArray(
       bsl::array<basic_format_arg<t_CONTEXT>,  1u> *out,
       t_FMTARGS_01& fmt_args_01)
{
#ifndef BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS
    bsl::array<basic_format_arg<t_CONTEXT>,  1u> tmp = {
        {basic_format_arg<t_CONTEXT>(fmt_args_01)}};
    *out = bslmf::MovableRefUtil::move(tmp);
#else
    *out = { {basic_format_arg<t_CONTEXT>(fmt_args_01)} };
#endif
}
#endif  // BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_B >= 1

#if BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_B >= 2
template <class t_CONTEXT, class t_FMTARGS_01,
                           class t_FMTARGS_02>
inline
void Format_ArgUtil::makeFormatArgArray(
       bsl::array<basic_format_arg<t_CONTEXT>,  2u> *out,
       t_FMTARGS_01& fmt_args_01,
       t_FMTARGS_02& fmt_args_02)
{
#ifndef BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS
    bsl::array<basic_format_arg<t_CONTEXT>,  2u> tmp = {
        {basic_format_arg<t_CONTEXT>(fmt_args_01),
         basic_format_arg<t_CONTEXT>(fmt_args_02)}};
    *out = bslmf::MovableRefUtil::move(tmp);
#else
    *out = { {basic_format_arg<t_CONTEXT>(fmt_args_01),
              basic_format_arg<t_CONTEXT>(fmt_args_02)} };
#endif
}
#endif  // BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_B >= 2

#if BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_B >= 3
template <class t_CONTEXT, class t_FMTARGS_01,
                           class t_FMTARGS_02,
                           class t_FMTARGS_03>
inline
void Format_ArgUtil::makeFormatArgArray(
       bsl::array<basic_format_arg<t_CONTEXT>,  3u> *out,
       t_FMTARGS_01& fmt_args_01,
       t_FMTARGS_02& fmt_args_02,
       t_FMTARGS_03& fmt_args_03)
{
#ifndef BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS
    bsl::array<basic_format_arg<t_CONTEXT>,  3u> tmp = {
        {basic_format_arg<t_CONTEXT>(fmt_args_01),
         basic_format_arg<t_CONTEXT>(fmt_args_02),
         basic_format_arg<t_CONTEXT>(fmt_args_03)}};
    *out = bslmf::MovableRefUtil::move(tmp);
#else
    *out = { {basic_format_arg<t_CONTEXT>(fmt_args_01),
              basic_format_arg<t_CONTEXT>(fmt_args_02),
              basic_format_arg<t_CONTEXT>(fmt_args_03)} };
#endif
}
#endif  // BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_B >= 3

#if BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_B >= 4
template <class t_CONTEXT, class t_FMTARGS_01,
                           class t_FMTARGS_02,
                           class t_FMTARGS_03,
                           class t_FMTARGS_04>
inline
void Format_ArgUtil::makeFormatArgArray(
       bsl::array<basic_format_arg<t_CONTEXT>,  4u> *out,
       t_FMTARGS_01& fmt_args_01,
       t_FMTARGS_02& fmt_args_02,
       t_FMTARGS_03& fmt_args_03,
       t_FMTARGS_04& fmt_args_04)
{
#ifndef BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS
    bsl::array<basic_format_arg<t_CONTEXT>,  4u> tmp = {
        {basic_format_arg<t_CONTEXT>(fmt_args_01),
         basic_format_arg<t_CONTEXT>(fmt_args_02),
         basic_format_arg<t_CONTEXT>(fmt_args_03),
         basic_format_arg<t_CONTEXT>(fmt_args_04)}};
    *out = bslmf::MovableRefUtil::move(tmp);
#else
    *out = { {basic_format_arg<t_CONTEXT>(fmt_args_01),
              basic_format_arg<t_CONTEXT>(fmt_args_02),
              basic_format_arg<t_CONTEXT>(fmt_args_03),
              basic_format_arg<t_CONTEXT>(fmt_args_04)} };
#endif
}
#endif  // BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_B >= 4

#if BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_B >= 5
template <class t_CONTEXT, class t_FMTARGS_01,
                           class t_FMTARGS_02,
                           class t_FMTARGS_03,
                           class t_FMTARGS_04,
                           class t_FMTARGS_05>
inline
void Format_ArgUtil::makeFormatArgArray(
       bsl::array<basic_format_arg<t_CONTEXT>,  5u> *out,
       t_FMTARGS_01& fmt_args_01,
       t_FMTARGS_02& fmt_args_02,
       t_FMTARGS_03& fmt_args_03,
       t_FMTARGS_04& fmt_args_04,
       t_FMTARGS_05& fmt_args_05)
{
#ifndef BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS
    bsl::array<basic_format_arg<t_CONTEXT>,  5u> tmp = {
        {basic_format_arg<t_CONTEXT>(fmt_args_01),
         basic_format_arg<t_CONTEXT>(fmt_args_02),
         basic_format_arg<t_CONTEXT>(fmt_args_03),
         basic_format_arg<t_CONTEXT>(fmt_args_04),
         basic_format_arg<t_CONTEXT>(fmt_args_05)}};
    *out = bslmf::MovableRefUtil::move(tmp);
#else
    *out = { {basic_format_arg<t_CONTEXT>(fmt_args_01),
              basic_format_arg<t_CONTEXT>(fmt_args_02),
              basic_format_arg<t_CONTEXT>(fmt_args_03),
              basic_format_arg<t_CONTEXT>(fmt_args_04),
              basic_format_arg<t_CONTEXT>(fmt_args_05)} };
#endif
}
#endif  // BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_B >= 5

#if BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_B >= 6
template <class t_CONTEXT, class t_FMTARGS_01,
                           class t_FMTARGS_02,
                           class t_FMTARGS_03,
                           class t_FMTARGS_04,
                           class t_FMTARGS_05,
                           class t_FMTARGS_06>
inline
void Format_ArgUtil::makeFormatArgArray(
       bsl::array<basic_format_arg<t_CONTEXT>,  6u> *out,
       t_FMTARGS_01& fmt_args_01,
       t_FMTARGS_02& fmt_args_02,
       t_FMTARGS_03& fmt_args_03,
       t_FMTARGS_04& fmt_args_04,
       t_FMTARGS_05& fmt_args_05,
       t_FMTARGS_06& fmt_args_06)
{
#ifndef BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS
    bsl::array<basic_format_arg<t_CONTEXT>,  6u> tmp = {
        {basic_format_arg<t_CONTEXT>(fmt_args_01),
         basic_format_arg<t_CONTEXT>(fmt_args_02),
         basic_format_arg<t_CONTEXT>(fmt_args_03),
         basic_format_arg<t_CONTEXT>(fmt_args_04),
         basic_format_arg<t_CONTEXT>(fmt_args_05),
         basic_format_arg<t_CONTEXT>(fmt_args_06)}};
    *out = bslmf::MovableRefUtil::move(tmp);
#else
    *out = { {basic_format_arg<t_CONTEXT>(fmt_args_01),
              basic_format_arg<t_CONTEXT>(fmt_args_02),
              basic_format_arg<t_CONTEXT>(fmt_args_03),
              basic_format_arg<t_CONTEXT>(fmt_args_04),
              basic_format_arg<t_CONTEXT>(fmt_args_05),
              basic_format_arg<t_CONTEXT>(fmt_args_06)} };
#endif
}
#endif  // BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_B >= 6

#if BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_B >= 7
template <class t_CONTEXT, class t_FMTARGS_01,
                           class t_FMTARGS_02,
                           class t_FMTARGS_03,
                           class t_FMTARGS_04,
                           class t_FMTARGS_05,
                           class t_FMTARGS_06,
                           class t_FMTARGS_07>
inline
void Format_ArgUtil::makeFormatArgArray(
       bsl::array<basic_format_arg<t_CONTEXT>,  7u> *out,
       t_FMTARGS_01& fmt_args_01,
       t_FMTARGS_02& fmt_args_02,
       t_FMTARGS_03& fmt_args_03,
       t_FMTARGS_04& fmt_args_04,
       t_FMTARGS_05& fmt_args_05,
       t_FMTARGS_06& fmt_args_06,
       t_FMTARGS_07& fmt_args_07)
{
#ifndef BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS
    bsl::array<basic_format_arg<t_CONTEXT>,  7u> tmp = {
        {basic_format_arg<t_CONTEXT>(fmt_args_01),
         basic_format_arg<t_CONTEXT>(fmt_args_02),
         basic_format_arg<t_CONTEXT>(fmt_args_03),
         basic_format_arg<t_CONTEXT>(fmt_args_04),
         basic_format_arg<t_CONTEXT>(fmt_args_05),
         basic_format_arg<t_CONTEXT>(fmt_args_06),
         basic_format_arg<t_CONTEXT>(fmt_args_07)}};
    *out = bslmf::MovableRefUtil::move(tmp);
#else
    *out = { {basic_format_arg<t_CONTEXT>(fmt_args_01),
              basic_format_arg<t_CONTEXT>(fmt_args_02),
              basic_format_arg<t_CONTEXT>(fmt_args_03),
              basic_format_arg<t_CONTEXT>(fmt_args_04),
              basic_format_arg<t_CONTEXT>(fmt_args_05),
              basic_format_arg<t_CONTEXT>(fmt_args_06),
              basic_format_arg<t_CONTEXT>(fmt_args_07)} };
#endif
}
#endif  // BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_B >= 7

#if BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_B >= 8
template <class t_CONTEXT, class t_FMTARGS_01,
                           class t_FMTARGS_02,
                           class t_FMTARGS_03,
                           class t_FMTARGS_04,
                           class t_FMTARGS_05,
                           class t_FMTARGS_06,
                           class t_FMTARGS_07,
                           class t_FMTARGS_08>
inline
void Format_ArgUtil::makeFormatArgArray(
       bsl::array<basic_format_arg<t_CONTEXT>,  8u> *out,
       t_FMTARGS_01& fmt_args_01,
       t_FMTARGS_02& fmt_args_02,
       t_FMTARGS_03& fmt_args_03,
       t_FMTARGS_04& fmt_args_04,
       t_FMTARGS_05& fmt_args_05,
       t_FMTARGS_06& fmt_args_06,
       t_FMTARGS_07& fmt_args_07,
       t_FMTARGS_08& fmt_args_08)
{
#ifndef BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS
    bsl::array<basic_format_arg<t_CONTEXT>,  8u> tmp = {
        {basic_format_arg<t_CONTEXT>(fmt_args_01),
         basic_format_arg<t_CONTEXT>(fmt_args_02),
         basic_format_arg<t_CONTEXT>(fmt_args_03),
         basic_format_arg<t_CONTEXT>(fmt_args_04),
         basic_format_arg<t_CONTEXT>(fmt_args_05),
         basic_format_arg<t_CONTEXT>(fmt_args_06),
         basic_format_arg<t_CONTEXT>(fmt_args_07),
         basic_format_arg<t_CONTEXT>(fmt_args_08)}};
    *out = bslmf::MovableRefUtil::move(tmp);
#else
    *out = { {basic_format_arg<t_CONTEXT>(fmt_args_01),
              basic_format_arg<t_CONTEXT>(fmt_args_02),
              basic_format_arg<t_CONTEXT>(fmt_args_03),
              basic_format_arg<t_CONTEXT>(fmt_args_04),
              basic_format_arg<t_CONTEXT>(fmt_args_05),
              basic_format_arg<t_CONTEXT>(fmt_args_06),
              basic_format_arg<t_CONTEXT>(fmt_args_07),
              basic_format_arg<t_CONTEXT>(fmt_args_08)} };
#endif
}
#endif  // BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_B >= 8

#if BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_B >= 9
template <class t_CONTEXT, class t_FMTARGS_01,
                           class t_FMTARGS_02,
                           class t_FMTARGS_03,
                           class t_FMTARGS_04,
                           class t_FMTARGS_05,
                           class t_FMTARGS_06,
                           class t_FMTARGS_07,
                           class t_FMTARGS_08,
                           class t_FMTARGS_09>
inline
void Format_ArgUtil::makeFormatArgArray(
       bsl::array<basic_format_arg<t_CONTEXT>,  9u> *out,
       t_FMTARGS_01& fmt_args_01,
       t_FMTARGS_02& fmt_args_02,
       t_FMTARGS_03& fmt_args_03,
       t_FMTARGS_04& fmt_args_04,
       t_FMTARGS_05& fmt_args_05,
       t_FMTARGS_06& fmt_args_06,
       t_FMTARGS_07& fmt_args_07,
       t_FMTARGS_08& fmt_args_08,
       t_FMTARGS_09& fmt_args_09)
{
#ifndef BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS
    bsl::array<basic_format_arg<t_CONTEXT>,  9u> tmp = {
        {basic_format_arg<t_CONTEXT>(fmt_args_01),
         basic_format_arg<t_CONTEXT>(fmt_args_02),
         basic_format_arg<t_CONTEXT>(fmt_args_03),
         basic_format_arg<t_CONTEXT>(fmt_args_04),
         basic_format_arg<t_CONTEXT>(fmt_args_05),
         basic_format_arg<t_CONTEXT>(fmt_args_06),
         basic_format_arg<t_CONTEXT>(fmt_args_07),
         basic_format_arg<t_CONTEXT>(fmt_args_08),
         basic_format_arg<t_CONTEXT>(fmt_args_09)}};
    *out = bslmf::MovableRefUtil::move(tmp);
#else
    *out = { {basic_format_arg<t_CONTEXT>(fmt_args_01),
              basic_format_arg<t_CONTEXT>(fmt_args_02),
              basic_format_arg<t_CONTEXT>(fmt_args_03),
              basic_format_arg<t_CONTEXT>(fmt_args_04),
              basic_format_arg<t_CONTEXT>(fmt_args_05),
              basic_format_arg<t_CONTEXT>(fmt_args_06),
              basic_format_arg<t_CONTEXT>(fmt_args_07),
              basic_format_arg<t_CONTEXT>(fmt_args_08),
              basic_format_arg<t_CONTEXT>(fmt_args_09)} };
#endif
}
#endif  // BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_B >= 9

#if BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_B >= 10
template <class t_CONTEXT, class t_FMTARGS_01,
                           class t_FMTARGS_02,
                           class t_FMTARGS_03,
                           class t_FMTARGS_04,
                           class t_FMTARGS_05,
                           class t_FMTARGS_06,
                           class t_FMTARGS_07,
                           class t_FMTARGS_08,
                           class t_FMTARGS_09,
                           class t_FMTARGS_10>
inline
void Format_ArgUtil::makeFormatArgArray(
       bsl::array<basic_format_arg<t_CONTEXT>, 10u> *out,
       t_FMTARGS_01& fmt_args_01,
       t_FMTARGS_02& fmt_args_02,
       t_FMTARGS_03& fmt_args_03,
       t_FMTARGS_04& fmt_args_04,
       t_FMTARGS_05& fmt_args_05,
       t_FMTARGS_06& fmt_args_06,
       t_FMTARGS_07& fmt_args_07,
       t_FMTARGS_08& fmt_args_08,
       t_FMTARGS_09& fmt_args_09,
       t_FMTARGS_10& fmt_args_10)
{
#ifndef BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS
    bsl::array<basic_format_arg<t_CONTEXT>, 10u> tmp = {
        {basic_format_arg<t_CONTEXT>(fmt_args_01),
         basic_format_arg<t_CONTEXT>(fmt_args_02),
         basic_format_arg<t_CONTEXT>(fmt_args_03),
         basic_format_arg<t_CONTEXT>(fmt_args_04),
         basic_format_arg<t_CONTEXT>(fmt_args_05),
         basic_format_arg<t_CONTEXT>(fmt_args_06),
         basic_format_arg<t_CONTEXT>(fmt_args_07),
         basic_format_arg<t_CONTEXT>(fmt_args_08),
         basic_format_arg<t_CONTEXT>(fmt_args_09),
         basic_format_arg<t_CONTEXT>(fmt_args_10)}};
    *out = bslmf::MovableRefUtil::move(tmp);
#else
    *out = { {basic_format_arg<t_CONTEXT>(fmt_args_01),
              basic_format_arg<t_CONTEXT>(fmt_args_02),
              basic_format_arg<t_CONTEXT>(fmt_args_03),
              basic_format_arg<t_CONTEXT>(fmt_args_04),
              basic_format_arg<t_CONTEXT>(fmt_args_05),
              basic_format_arg<t_CONTEXT>(fmt_args_06),
              basic_format_arg<t_CONTEXT>(fmt_args_07),
              basic_format_arg<t_CONTEXT>(fmt_args_08),
              basic_format_arg<t_CONTEXT>(fmt_args_09),
              basic_format_arg<t_CONTEXT>(fmt_args_10)} };
#endif
}
#endif  // BSLFMT_FORMAT_ARG_VARIADIC_LIMIT_B >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class t_CONTEXT, class... t_FMTARGS>
inline
void Format_ArgUtil::makeFormatArgArray(
       bsl::array<basic_format_arg<t_CONTEXT>, sizeof...(t_FMTARGS)> *out,
       t_FMTARGS&...                                                  fmt_args)
{
#ifndef BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS
    bsl::array<basic_format_arg<t_CONTEXT>, sizeof...(t_FMTARGS)> tmp = {
        {basic_format_arg<t_CONTEXT>(fmt_args)...}};
    *out = bslmf::MovableRefUtil::move(tmp);
#else
    *out = { {basic_format_arg<t_CONTEXT>(fmt_args)...} };
#endif
}
// }}} END GENERATED CODE
#endif

// FREE FUNCTIONS

#if defined(BSLS_LIBRARYFEATURES_HAS_CPP14_BASELINE_LIBRARY) &&               \
    defined(BSLS_LIBRARYFEATURES_HAS_CPP14_INTEGER_SEQUENCE)
    // This check is a proxy for BSL_VARIANT_FULL_IMPLEMENTATION which is unset
    // at the end of bslstl_variant.h
template <class t_VISITOR, class t_CONTEXT>
inline
decltype(auto) visit_format_arg(t_VISITOR&&                 visitor,
                                basic_format_arg<t_CONTEXT> arg)
{
    return arg.visit(std::forward<t_VISITOR>(visitor));
}
#else
template <class t_VISITOR, class t_CONTEXT>
inline
typename bsl::invoke_result<t_VISITOR&, bsl::monostate&>::type
visit_format_arg(t_VISITOR& visitor, basic_format_arg<t_CONTEXT> arg)
{
    return arg.visit(visitor);
}
#endif

}  // close package namespace
}  // close enterprise namespace

#else // if ! defined(DEFINED_BSLFMT_FORMAT_ARG_H)
# error Not valid except when included from bslfmt_format_arg.h
#endif // ! defined(COMPILING_BSLFMT_FORMAT_ARG_H)

#endif // ! defined(INCLUDED_BSLFMT_FORMAT_ARG_CPP03)

// ----------------------------------------------------------------------------
// Copyright 2023 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
