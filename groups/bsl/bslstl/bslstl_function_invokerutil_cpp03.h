// bslstl_function_invokerutil_cpp03.h                                -*-C++-*-

// Automatically generated file.  **DO NOT EDIT**

#ifndef INCLUDED_BSLSTL_FUNCTION_INVOKERUTIL_CPP03
#define INCLUDED_BSLSTL_FUNCTION_INVOKERUTIL_CPP03

//@PURPOSE: Provide C++03 implementation for bslstl_function_invokerutil.h
//
//@CLASSES: See bslstl_function_invokerutil.h for list of classes
//
//@SEE_ALSO: bslstl_function_invokerutil
//
//@DESCRIPTION:  This component is the C++03 translation of a C++11 component,
// generated by the 'sim_cpp11_features.pl' program.  If the original header
// contains any specially delimited regions of C++11 code, then this generated
// file contains the C++03 equivalent, i.e., with variadic templates expanded
// and rvalue-references replaced by 'bslmf::MovableRef' objects.  The header
// code in this file is designed to be '#include'd into the original header
// when compiling with a C++03 compiler.  If there are no specially delimited
// regions of C++11 code, then this header contains no code and is not
// '#include'd in the original header.
//
// Generated on Sun Sep  1 05:39:09 2024
// Command line: sim_cpp11_features.pl bslstl_function_invokerutil.h

#ifdef COMPILING_BSLSTL_FUNCTION_INVOKERUTIL_H

#ifndef BSLS_PLATFORM_CMP_SUN
#define BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET, X) static_cast<RET>(X)
#else
#define BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET, X) (RET)(X)
#endif

#if defined(BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS)      \
 && defined(BSLS_COMPILERFEATURES_SUPPORT_DECLTYPE)          \
 && defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) \
 && defined(BSLS_LIBRARYFEATURES_HAS_CPP11_BASELINE_LIBRARY)
#define BSLSTL_FUNCTION_INVOKERUTIL_SUPPORT_IS_FUNC_INVOCABLE
#endif

namespace BloombergLP {
namespace bslstl {

#ifdef BSLSTL_FUNCTION_INVOKERUTIL_SUPPORT_IS_FUNC_INVOCABLE

/// forward declaration
template <class PROTOTYPE, class FUNC>
struct Function_InvokerUtil_IsFuncInvocable;

#endif

                        // ===========================
                        // struct Function_InvokerUtil
                        // ===========================

/// This struct is a namespace containing a single function template,
/// `invokerForFunc`, that returns a pointer to a function that is used to
/// invoke a callable object of a particular type.
struct Function_InvokerUtil {

    // TYPES
    enum {
        // Enumeration of the different types of callable objects.

        e_Null,
        e_FunctionPtr,
        e_MemFunctionPtr,
        e_MemDataPtr,
        e_InplaceFunctor,
        e_OutofplaceFunctor
    };

    /// Generic function pointer.  This type is as close as we can get to
    /// `void *` for function pointers.
    typedef Function_Rep::GenericInvoker GenericInvoker;

#ifdef BSLSTL_FUNCTION_INVOKERUTIL_SUPPORT_IS_FUNC_INVOCABLE
    /// This `struct` template implements a Boolean metafunction that
    /// publicly inherits from `bsl::true_type` if an object of the
    /// specified `FUNC` type is invocable under the specified `PROTOTYPE`,
    /// and publicly inherits from `bsl::false_type` otherwise.  An object
    /// of `FUNC` type is invocable under the `PROTOTYPE` if it is
    /// Lvalue-Callable with the arguments of the `PROTOTYPE` (as forwarded
    /// by the facilities of 'bslmf_forwardingtype), and returns an object
    /// of type explicitly convertible to the return type of the
    /// `PROTOTYPE`.  If the return type of the `PROTOTYPE` is `void`, then
    /// any type is considered explicitly convertible to the return type of
    /// the `PROTOTYPE`.  This `struct` template requires `PROTOTYPE` to be
    /// an unqualified function type.
    ///
    /// Note that `IsFuncInvocable` is qualitatively different than
    /// `std::is_invocable_r`, in that it makes concessions for supporting
    /// legacy behavior of `bsl::function`.
    /// `std::is_invocable_r<RET, FUNC, ARGS...>` requires that the return
    /// type of the invocation of `FUNC` with `ARGS...` be implicitly
    /// convertible to `RET`, as opposed to explicitly convertible.
    /// Further, the use of `bslmf::ForwardingType` to forward arguments in
    /// the invoker of a `bsl::function` creates qualitatively different
    /// behavior than the argument forwarding mechanism used by the standard
    /// `INVOKE` pseudo-expression.
    template <class PROTOTYPE, class FUNC>
    struct IsFuncInvocable
    : Function_InvokerUtil_IsFuncInvocable<PROTOTYPE, FUNC> {
    };
#endif

    // CLASS METHODS

    /// Return a null pointer.  Note that template argument `PROTOTYPE` must
    /// be supplied excplicitly, as there is no way to deduce it from the
    /// function arguments.
    template <class PROTOTYPE>
    static GenericInvoker *invokerForFunc(const bsl::nullptr_t&);

    /// Return a pointer to the invoker for a callable object of (template
    /// paramter) type `FUNC`.  If the specified `f` object is a null
    /// pointer or null pointer-to-member, return a null pointer.  Note that
    /// template argument `PROTOTYPE` must be supplied excplicitly, as there
    /// is no way to deduce it from the function arguments.
    template <class PROTOTYPE, class FUNC>
    static GenericInvoker *invokerForFunc(const FUNC& f);
};

               // =============================================
               // template struct Function_InvokerUtilNullCheck
               // =============================================

/// Provides an `isNull` static method that that returns whether or not its
/// argument is "null", i.e., it cannot be invoked.  For must `FUNC` types
/// `isNull` always returns `false` as every instance of `FUNC` is
/// invocable.  However, specializations of this class, especially for
/// pointer types, have `isNull` functions that sometimes return `true`.
/// This class is a customization point: types outside of this component can
/// (but rarely should) specialize this template.  In particular,
/// `bslstl_function` contains a specialization for `bsl::function`.
template <class FUNC>
struct Function_InvokerUtilNullCheck {

    // CLASS METHODS

    /// Return `false`.
    static bool isNull(const FUNC&);
};

/// Specialization of dispatcher for pointer objects.
template <class FUNC>
struct Function_InvokerUtilNullCheck<FUNC *> {

    // CLASS METHODS

    /// Return `true` if the specified `f` pointer is null; otherwise
    /// `false`.
    static bool isNull(FUNC *f);
};

/// Specialization of dispatcher for pointer-to-member objects.
template <class CLASS, class MEMTYPE>
struct Function_InvokerUtilNullCheck<MEMTYPE CLASS::*> {

  public:
    // CLASS METHODS

    /// Return `true` if the specified `f` pointer to member is null;
    /// otherwise `false`.
    static bool isNull(MEMTYPE CLASS::* f);
};

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_function_invokerutil.h
#ifndef BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT
#define BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT 13
#endif
#ifndef BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A
#define BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT
#endif


#ifdef BSLSTL_FUNCTION_INVOKERUTIL_SUPPORT_IS_FUNC_INVOCABLE

template <class VOID_TYPE,
          class RET,
          class FUNC
#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 0
        , class ARGS_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 1
        , class ARGS_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 2
        , class ARGS_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 3
        , class ARGS_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 4
        , class ARGS_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 5
        , class ARGS_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 6
        , class ARGS_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 7
        , class ARGS_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 8
        , class ARGS_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 9
        , class ARGS_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 10
        , class ARGS_10 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 11
        , class ARGS_11 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 12
        , class ARGS_12 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 12
        , class = BSLS_COMPILERFEATURES_NILT>
struct Function_InvokerUtil_IsFuncInvocableImp;


#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 0
template <class RET, class FUNC>
struct Function_InvokerUtil_IsFuncInvocable<RET(), FUNC>
: Function_InvokerUtil_IsFuncInvocableImp<void, RET, FUNC> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 1
template <class RET, class FUNC, class ARGS_01>
struct Function_InvokerUtil_IsFuncInvocable<RET(ARGS_01), FUNC>
: Function_InvokerUtil_IsFuncInvocableImp<void, RET, FUNC, ARGS_01> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 2
template <class RET, class FUNC, class ARGS_01,
                                 class ARGS_02>
struct Function_InvokerUtil_IsFuncInvocable<RET(ARGS_01,
                                                ARGS_02), FUNC>
: Function_InvokerUtil_IsFuncInvocableImp<void, RET, FUNC, ARGS_01,
                                                           ARGS_02> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 3
template <class RET, class FUNC, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03>
struct Function_InvokerUtil_IsFuncInvocable<RET(ARGS_01,
                                                ARGS_02,
                                                ARGS_03), FUNC>
: Function_InvokerUtil_IsFuncInvocableImp<void, RET, FUNC, ARGS_01,
                                                           ARGS_02,
                                                           ARGS_03> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 4
template <class RET, class FUNC, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04>
struct Function_InvokerUtil_IsFuncInvocable<RET(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04), FUNC>
: Function_InvokerUtil_IsFuncInvocableImp<void, RET, FUNC, ARGS_01,
                                                           ARGS_02,
                                                           ARGS_03,
                                                           ARGS_04> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 5
template <class RET, class FUNC, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05>
struct Function_InvokerUtil_IsFuncInvocable<RET(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05), FUNC>
: Function_InvokerUtil_IsFuncInvocableImp<void, RET, FUNC, ARGS_01,
                                                           ARGS_02,
                                                           ARGS_03,
                                                           ARGS_04,
                                                           ARGS_05> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 6
template <class RET, class FUNC, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06>
struct Function_InvokerUtil_IsFuncInvocable<RET(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06), FUNC>
: Function_InvokerUtil_IsFuncInvocableImp<void, RET, FUNC, ARGS_01,
                                                           ARGS_02,
                                                           ARGS_03,
                                                           ARGS_04,
                                                           ARGS_05,
                                                           ARGS_06> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 7
template <class RET, class FUNC, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07>
struct Function_InvokerUtil_IsFuncInvocable<RET(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07), FUNC>
: Function_InvokerUtil_IsFuncInvocableImp<void, RET, FUNC, ARGS_01,
                                                           ARGS_02,
                                                           ARGS_03,
                                                           ARGS_04,
                                                           ARGS_05,
                                                           ARGS_06,
                                                           ARGS_07> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 8
template <class RET, class FUNC, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08>
struct Function_InvokerUtil_IsFuncInvocable<RET(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08), FUNC>
: Function_InvokerUtil_IsFuncInvocableImp<void, RET, FUNC, ARGS_01,
                                                           ARGS_02,
                                                           ARGS_03,
                                                           ARGS_04,
                                                           ARGS_05,
                                                           ARGS_06,
                                                           ARGS_07,
                                                           ARGS_08> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 9
template <class RET, class FUNC, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09>
struct Function_InvokerUtil_IsFuncInvocable<RET(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08,
                                                ARGS_09), FUNC>
: Function_InvokerUtil_IsFuncInvocableImp<void, RET, FUNC, ARGS_01,
                                                           ARGS_02,
                                                           ARGS_03,
                                                           ARGS_04,
                                                           ARGS_05,
                                                           ARGS_06,
                                                           ARGS_07,
                                                           ARGS_08,
                                                           ARGS_09> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 10
template <class RET, class FUNC, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10>
struct Function_InvokerUtil_IsFuncInvocable<RET(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08,
                                                ARGS_09,
                                                ARGS_10), FUNC>
: Function_InvokerUtil_IsFuncInvocableImp<void, RET, FUNC, ARGS_01,
                                                           ARGS_02,
                                                           ARGS_03,
                                                           ARGS_04,
                                                           ARGS_05,
                                                           ARGS_06,
                                                           ARGS_07,
                                                           ARGS_08,
                                                           ARGS_09,
                                                           ARGS_10> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 11
template <class RET, class FUNC, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11>
struct Function_InvokerUtil_IsFuncInvocable<RET(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08,
                                                ARGS_09,
                                                ARGS_10,
                                                ARGS_11), FUNC>
: Function_InvokerUtil_IsFuncInvocableImp<void, RET, FUNC, ARGS_01,
                                                           ARGS_02,
                                                           ARGS_03,
                                                           ARGS_04,
                                                           ARGS_05,
                                                           ARGS_06,
                                                           ARGS_07,
                                                           ARGS_08,
                                                           ARGS_09,
                                                           ARGS_10,
                                                           ARGS_11> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 12
template <class RET, class FUNC, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12>
struct Function_InvokerUtil_IsFuncInvocable<RET(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08,
                                                ARGS_09,
                                                ARGS_10,
                                                ARGS_11,
                                                ARGS_12), FUNC>
: Function_InvokerUtil_IsFuncInvocableImp<void, RET, FUNC, ARGS_01,
                                                           ARGS_02,
                                                           ARGS_03,
                                                           ARGS_04,
                                                           ARGS_05,
                                                           ARGS_06,
                                                           ARGS_07,
                                                           ARGS_08,
                                                           ARGS_09,
                                                           ARGS_10,
                                                           ARGS_11,
                                                           ARGS_12> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 13
template <class RET, class FUNC, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12,
                                 class ARGS_13>
struct Function_InvokerUtil_IsFuncInvocable<RET(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08,
                                                ARGS_09,
                                                ARGS_10,
                                                ARGS_11,
                                                ARGS_12,
                                                ARGS_13), FUNC>
: Function_InvokerUtil_IsFuncInvocableImp<void, RET, FUNC, ARGS_01,
                                                           ARGS_02,
                                                           ARGS_03,
                                                           ARGS_04,
                                                           ARGS_05,
                                                           ARGS_06,
                                                           ARGS_07,
                                                           ARGS_08,
                                                           ARGS_09,
                                                           ARGS_10,
                                                           ARGS_11,
                                                           ARGS_12,
                                                           ARGS_13> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 13



template <class ARG>
struct Function_InvokerUtil_ForwardType;

template <class FROM, class TO>
struct Function_InvokerUtil_IsExplicitlyConvertible;

template <class FUNC
#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 0
        , class ARGS_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 1
        , class ARGS_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 2
        , class ARGS_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 3
        , class ARGS_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 4
        , class ARGS_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 5
        , class ARGS_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 6
        , class ARGS_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 7
        , class ARGS_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 8
        , class ARGS_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 9
        , class ARGS_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 10
        , class ARGS_10 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 11
        , class ARGS_11 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 12
        , class ARGS_12 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 12
        , class = BSLS_COMPILERFEATURES_NILT>
struct Function_InvokerUtil_ResultType;


#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 0
template <class VOID_TYPE, class RET, class FUNC>
struct Function_InvokerUtil_IsFuncInvocableImp<VOID_TYPE, RET, FUNC
                                                          > : bsl::false_type {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 1
template <class VOID_TYPE, class RET, class FUNC, class ARGS_01>
struct Function_InvokerUtil_IsFuncInvocableImp<VOID_TYPE, RET, FUNC, ARGS_01
                                                          > : bsl::false_type {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 2
template <class VOID_TYPE, class RET, class FUNC, class ARGS_01,
                                                  class ARGS_02>
struct Function_InvokerUtil_IsFuncInvocableImp<VOID_TYPE, RET, FUNC, ARGS_01,
                                                                     ARGS_02
                                                          > : bsl::false_type {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 3
template <class VOID_TYPE, class RET, class FUNC, class ARGS_01,
                                                  class ARGS_02,
                                                  class ARGS_03>
struct Function_InvokerUtil_IsFuncInvocableImp<VOID_TYPE, RET, FUNC, ARGS_01,
                                                                     ARGS_02,
                                                                     ARGS_03
                                                          > : bsl::false_type {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 4
template <class VOID_TYPE, class RET, class FUNC, class ARGS_01,
                                                  class ARGS_02,
                                                  class ARGS_03,
                                                  class ARGS_04>
struct Function_InvokerUtil_IsFuncInvocableImp<VOID_TYPE, RET, FUNC, ARGS_01,
                                                                     ARGS_02,
                                                                     ARGS_03,
                                                                     ARGS_04
                                                          > : bsl::false_type {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 5
template <class VOID_TYPE, class RET, class FUNC, class ARGS_01,
                                                  class ARGS_02,
                                                  class ARGS_03,
                                                  class ARGS_04,
                                                  class ARGS_05>
struct Function_InvokerUtil_IsFuncInvocableImp<VOID_TYPE, RET, FUNC, ARGS_01,
                                                                     ARGS_02,
                                                                     ARGS_03,
                                                                     ARGS_04,
                                                                     ARGS_05
                                                          > : bsl::false_type {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 6
template <class VOID_TYPE, class RET, class FUNC, class ARGS_01,
                                                  class ARGS_02,
                                                  class ARGS_03,
                                                  class ARGS_04,
                                                  class ARGS_05,
                                                  class ARGS_06>
struct Function_InvokerUtil_IsFuncInvocableImp<VOID_TYPE, RET, FUNC, ARGS_01,
                                                                     ARGS_02,
                                                                     ARGS_03,
                                                                     ARGS_04,
                                                                     ARGS_05,
                                                                     ARGS_06
                                                          > : bsl::false_type {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 7
template <class VOID_TYPE, class RET, class FUNC, class ARGS_01,
                                                  class ARGS_02,
                                                  class ARGS_03,
                                                  class ARGS_04,
                                                  class ARGS_05,
                                                  class ARGS_06,
                                                  class ARGS_07>
struct Function_InvokerUtil_IsFuncInvocableImp<VOID_TYPE, RET, FUNC, ARGS_01,
                                                                     ARGS_02,
                                                                     ARGS_03,
                                                                     ARGS_04,
                                                                     ARGS_05,
                                                                     ARGS_06,
                                                                     ARGS_07
                                                          > : bsl::false_type {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 8
template <class VOID_TYPE, class RET, class FUNC, class ARGS_01,
                                                  class ARGS_02,
                                                  class ARGS_03,
                                                  class ARGS_04,
                                                  class ARGS_05,
                                                  class ARGS_06,
                                                  class ARGS_07,
                                                  class ARGS_08>
struct Function_InvokerUtil_IsFuncInvocableImp<VOID_TYPE, RET, FUNC, ARGS_01,
                                                                     ARGS_02,
                                                                     ARGS_03,
                                                                     ARGS_04,
                                                                     ARGS_05,
                                                                     ARGS_06,
                                                                     ARGS_07,
                                                                     ARGS_08
                                                          > : bsl::false_type {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 9
template <class VOID_TYPE, class RET, class FUNC, class ARGS_01,
                                                  class ARGS_02,
                                                  class ARGS_03,
                                                  class ARGS_04,
                                                  class ARGS_05,
                                                  class ARGS_06,
                                                  class ARGS_07,
                                                  class ARGS_08,
                                                  class ARGS_09>
struct Function_InvokerUtil_IsFuncInvocableImp<VOID_TYPE, RET, FUNC, ARGS_01,
                                                                     ARGS_02,
                                                                     ARGS_03,
                                                                     ARGS_04,
                                                                     ARGS_05,
                                                                     ARGS_06,
                                                                     ARGS_07,
                                                                     ARGS_08,
                                                                     ARGS_09
                                                          > : bsl::false_type {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 10
template <class VOID_TYPE, class RET, class FUNC, class ARGS_01,
                                                  class ARGS_02,
                                                  class ARGS_03,
                                                  class ARGS_04,
                                                  class ARGS_05,
                                                  class ARGS_06,
                                                  class ARGS_07,
                                                  class ARGS_08,
                                                  class ARGS_09,
                                                  class ARGS_10>
struct Function_InvokerUtil_IsFuncInvocableImp<VOID_TYPE, RET, FUNC, ARGS_01,
                                                                     ARGS_02,
                                                                     ARGS_03,
                                                                     ARGS_04,
                                                                     ARGS_05,
                                                                     ARGS_06,
                                                                     ARGS_07,
                                                                     ARGS_08,
                                                                     ARGS_09,
                                                                     ARGS_10
                                                          > : bsl::false_type {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 11
template <class VOID_TYPE, class RET, class FUNC, class ARGS_01,
                                                  class ARGS_02,
                                                  class ARGS_03,
                                                  class ARGS_04,
                                                  class ARGS_05,
                                                  class ARGS_06,
                                                  class ARGS_07,
                                                  class ARGS_08,
                                                  class ARGS_09,
                                                  class ARGS_10,
                                                  class ARGS_11>
struct Function_InvokerUtil_IsFuncInvocableImp<VOID_TYPE, RET, FUNC, ARGS_01,
                                                                     ARGS_02,
                                                                     ARGS_03,
                                                                     ARGS_04,
                                                                     ARGS_05,
                                                                     ARGS_06,
                                                                     ARGS_07,
                                                                     ARGS_08,
                                                                     ARGS_09,
                                                                     ARGS_10,
                                                                     ARGS_11
                                                          > : bsl::false_type {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 12
template <class VOID_TYPE, class RET, class FUNC, class ARGS_01,
                                                  class ARGS_02,
                                                  class ARGS_03,
                                                  class ARGS_04,
                                                  class ARGS_05,
                                                  class ARGS_06,
                                                  class ARGS_07,
                                                  class ARGS_08,
                                                  class ARGS_09,
                                                  class ARGS_10,
                                                  class ARGS_11,
                                                  class ARGS_12>
struct Function_InvokerUtil_IsFuncInvocableImp<VOID_TYPE, RET, FUNC, ARGS_01,
                                                                     ARGS_02,
                                                                     ARGS_03,
                                                                     ARGS_04,
                                                                     ARGS_05,
                                                                     ARGS_06,
                                                                     ARGS_07,
                                                                     ARGS_08,
                                                                     ARGS_09,
                                                                     ARGS_10,
                                                                     ARGS_11,
                                                                     ARGS_12
                                                          > : bsl::false_type {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 13
template <class VOID_TYPE, class RET, class FUNC, class ARGS_01,
                                                  class ARGS_02,
                                                  class ARGS_03,
                                                  class ARGS_04,
                                                  class ARGS_05,
                                                  class ARGS_06,
                                                  class ARGS_07,
                                                  class ARGS_08,
                                                  class ARGS_09,
                                                  class ARGS_10,
                                                  class ARGS_11,
                                                  class ARGS_12,
                                                  class ARGS_13>
struct Function_InvokerUtil_IsFuncInvocableImp<VOID_TYPE, RET, FUNC, ARGS_01,
                                                                     ARGS_02,
                                                                     ARGS_03,
                                                                     ARGS_04,
                                                                     ARGS_05,
                                                                     ARGS_06,
                                                                     ARGS_07,
                                                                     ARGS_08,
                                                                     ARGS_09,
                                                                     ARGS_10,
                                                                     ARGS_11,
                                                                     ARGS_12,
                                                                     ARGS_13
                                                          > : bsl::false_type {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 13


#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 0
template <class RET, class FUNC>
struct Function_InvokerUtil_IsFuncInvocableImp<
    typename bslmf::VoidType<
        typename Function_InvokerUtil_ResultType<FUNC>::type>::type,
    RET,
    FUNC>
: bsl::conditional<
      bsl::is_void<RET>::value,
      bsl::true_type,
      Function_InvokerUtil_IsExplicitlyConvertible<
          typename Function_InvokerUtil_ResultType<FUNC>::type,
          RET> >::type {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 1
template <class RET, class FUNC, class ARGS_01>
struct Function_InvokerUtil_IsFuncInvocableImp<
    typename bslmf::VoidType<
        typename Function_InvokerUtil_ResultType<FUNC, ARGS_01>::type>::type,
    RET,
    FUNC,
    ARGS_01>
: bsl::conditional<
      bsl::is_void<RET>::value,
      bsl::true_type,
      Function_InvokerUtil_IsExplicitlyConvertible<
          typename Function_InvokerUtil_ResultType<FUNC, ARGS_01>::type,
          RET> >::type {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 2
template <class RET, class FUNC, class ARGS_01,
                                 class ARGS_02>
struct Function_InvokerUtil_IsFuncInvocableImp<
    typename bslmf::VoidType<
        typename Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                                       ARGS_02>::type>::type,
    RET,
    FUNC,
    ARGS_01,
    ARGS_02>
: bsl::conditional<
      bsl::is_void<RET>::value,
      bsl::true_type,
      Function_InvokerUtil_IsExplicitlyConvertible<
          typename Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                                         ARGS_02>::type,
          RET> >::type {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 3
template <class RET, class FUNC, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03>
struct Function_InvokerUtil_IsFuncInvocableImp<
    typename bslmf::VoidType<
        typename Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                                       ARGS_02,
                                                       ARGS_03>::type>::type,
    RET,
    FUNC,
    ARGS_01,
    ARGS_02,
    ARGS_03>
: bsl::conditional<
      bsl::is_void<RET>::value,
      bsl::true_type,
      Function_InvokerUtil_IsExplicitlyConvertible<
          typename Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                                         ARGS_02,
                                                         ARGS_03>::type,
          RET> >::type {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 4
template <class RET, class FUNC, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04>
struct Function_InvokerUtil_IsFuncInvocableImp<
    typename bslmf::VoidType<
        typename Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                                       ARGS_02,
                                                       ARGS_03,
                                                       ARGS_04>::type>::type,
    RET,
    FUNC,
    ARGS_01,
    ARGS_02,
    ARGS_03,
    ARGS_04>
: bsl::conditional<
      bsl::is_void<RET>::value,
      bsl::true_type,
      Function_InvokerUtil_IsExplicitlyConvertible<
          typename Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                                         ARGS_02,
                                                         ARGS_03,
                                                         ARGS_04>::type,
          RET> >::type {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 5
template <class RET, class FUNC, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05>
struct Function_InvokerUtil_IsFuncInvocableImp<
    typename bslmf::VoidType<
        typename Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                                       ARGS_02,
                                                       ARGS_03,
                                                       ARGS_04,
                                                       ARGS_05>::type>::type,
    RET,
    FUNC,
    ARGS_01,
    ARGS_02,
    ARGS_03,
    ARGS_04,
    ARGS_05>
: bsl::conditional<
      bsl::is_void<RET>::value,
      bsl::true_type,
      Function_InvokerUtil_IsExplicitlyConvertible<
          typename Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                                         ARGS_02,
                                                         ARGS_03,
                                                         ARGS_04,
                                                         ARGS_05>::type,
          RET> >::type {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 6
template <class RET, class FUNC, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06>
struct Function_InvokerUtil_IsFuncInvocableImp<
    typename bslmf::VoidType<
        typename Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                                       ARGS_02,
                                                       ARGS_03,
                                                       ARGS_04,
                                                       ARGS_05,
                                                       ARGS_06>::type>::type,
    RET,
    FUNC,
    ARGS_01,
    ARGS_02,
    ARGS_03,
    ARGS_04,
    ARGS_05,
    ARGS_06>
: bsl::conditional<
      bsl::is_void<RET>::value,
      bsl::true_type,
      Function_InvokerUtil_IsExplicitlyConvertible<
          typename Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                                         ARGS_02,
                                                         ARGS_03,
                                                         ARGS_04,
                                                         ARGS_05,
                                                         ARGS_06>::type,
          RET> >::type {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 7
template <class RET, class FUNC, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07>
struct Function_InvokerUtil_IsFuncInvocableImp<
    typename bslmf::VoidType<
        typename Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                                       ARGS_02,
                                                       ARGS_03,
                                                       ARGS_04,
                                                       ARGS_05,
                                                       ARGS_06,
                                                       ARGS_07>::type>::type,
    RET,
    FUNC,
    ARGS_01,
    ARGS_02,
    ARGS_03,
    ARGS_04,
    ARGS_05,
    ARGS_06,
    ARGS_07>
: bsl::conditional<
      bsl::is_void<RET>::value,
      bsl::true_type,
      Function_InvokerUtil_IsExplicitlyConvertible<
          typename Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                                         ARGS_02,
                                                         ARGS_03,
                                                         ARGS_04,
                                                         ARGS_05,
                                                         ARGS_06,
                                                         ARGS_07>::type,
          RET> >::type {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 8
template <class RET, class FUNC, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08>
struct Function_InvokerUtil_IsFuncInvocableImp<
    typename bslmf::VoidType<
        typename Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                                       ARGS_02,
                                                       ARGS_03,
                                                       ARGS_04,
                                                       ARGS_05,
                                                       ARGS_06,
                                                       ARGS_07,
                                                       ARGS_08>::type>::type,
    RET,
    FUNC,
    ARGS_01,
    ARGS_02,
    ARGS_03,
    ARGS_04,
    ARGS_05,
    ARGS_06,
    ARGS_07,
    ARGS_08>
: bsl::conditional<
      bsl::is_void<RET>::value,
      bsl::true_type,
      Function_InvokerUtil_IsExplicitlyConvertible<
          typename Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                                         ARGS_02,
                                                         ARGS_03,
                                                         ARGS_04,
                                                         ARGS_05,
                                                         ARGS_06,
                                                         ARGS_07,
                                                         ARGS_08>::type,
          RET> >::type {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 9
template <class RET, class FUNC, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09>
struct Function_InvokerUtil_IsFuncInvocableImp<
    typename bslmf::VoidType<
        typename Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                                       ARGS_02,
                                                       ARGS_03,
                                                       ARGS_04,
                                                       ARGS_05,
                                                       ARGS_06,
                                                       ARGS_07,
                                                       ARGS_08,
                                                       ARGS_09>::type>::type,
    RET,
    FUNC,
    ARGS_01,
    ARGS_02,
    ARGS_03,
    ARGS_04,
    ARGS_05,
    ARGS_06,
    ARGS_07,
    ARGS_08,
    ARGS_09>
: bsl::conditional<
      bsl::is_void<RET>::value,
      bsl::true_type,
      Function_InvokerUtil_IsExplicitlyConvertible<
          typename Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                                         ARGS_02,
                                                         ARGS_03,
                                                         ARGS_04,
                                                         ARGS_05,
                                                         ARGS_06,
                                                         ARGS_07,
                                                         ARGS_08,
                                                         ARGS_09>::type,
          RET> >::type {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 10
template <class RET, class FUNC, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10>
struct Function_InvokerUtil_IsFuncInvocableImp<
    typename bslmf::VoidType<
        typename Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                                       ARGS_02,
                                                       ARGS_03,
                                                       ARGS_04,
                                                       ARGS_05,
                                                       ARGS_06,
                                                       ARGS_07,
                                                       ARGS_08,
                                                       ARGS_09,
                                                       ARGS_10>::type>::type,
    RET,
    FUNC,
    ARGS_01,
    ARGS_02,
    ARGS_03,
    ARGS_04,
    ARGS_05,
    ARGS_06,
    ARGS_07,
    ARGS_08,
    ARGS_09,
    ARGS_10>
: bsl::conditional<
      bsl::is_void<RET>::value,
      bsl::true_type,
      Function_InvokerUtil_IsExplicitlyConvertible<
          typename Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                                         ARGS_02,
                                                         ARGS_03,
                                                         ARGS_04,
                                                         ARGS_05,
                                                         ARGS_06,
                                                         ARGS_07,
                                                         ARGS_08,
                                                         ARGS_09,
                                                         ARGS_10>::type,
          RET> >::type {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 11
template <class RET, class FUNC, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11>
struct Function_InvokerUtil_IsFuncInvocableImp<
    typename bslmf::VoidType<
        typename Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                                       ARGS_02,
                                                       ARGS_03,
                                                       ARGS_04,
                                                       ARGS_05,
                                                       ARGS_06,
                                                       ARGS_07,
                                                       ARGS_08,
                                                       ARGS_09,
                                                       ARGS_10,
                                                       ARGS_11>::type>::type,
    RET,
    FUNC,
    ARGS_01,
    ARGS_02,
    ARGS_03,
    ARGS_04,
    ARGS_05,
    ARGS_06,
    ARGS_07,
    ARGS_08,
    ARGS_09,
    ARGS_10,
    ARGS_11>
: bsl::conditional<
      bsl::is_void<RET>::value,
      bsl::true_type,
      Function_InvokerUtil_IsExplicitlyConvertible<
          typename Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                                         ARGS_02,
                                                         ARGS_03,
                                                         ARGS_04,
                                                         ARGS_05,
                                                         ARGS_06,
                                                         ARGS_07,
                                                         ARGS_08,
                                                         ARGS_09,
                                                         ARGS_10,
                                                         ARGS_11>::type,
          RET> >::type {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 12
template <class RET, class FUNC, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12>
struct Function_InvokerUtil_IsFuncInvocableImp<
    typename bslmf::VoidType<
        typename Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                                       ARGS_02,
                                                       ARGS_03,
                                                       ARGS_04,
                                                       ARGS_05,
                                                       ARGS_06,
                                                       ARGS_07,
                                                       ARGS_08,
                                                       ARGS_09,
                                                       ARGS_10,
                                                       ARGS_11,
                                                       ARGS_12>::type>::type,
    RET,
    FUNC,
    ARGS_01,
    ARGS_02,
    ARGS_03,
    ARGS_04,
    ARGS_05,
    ARGS_06,
    ARGS_07,
    ARGS_08,
    ARGS_09,
    ARGS_10,
    ARGS_11,
    ARGS_12>
: bsl::conditional<
      bsl::is_void<RET>::value,
      bsl::true_type,
      Function_InvokerUtil_IsExplicitlyConvertible<
          typename Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                                         ARGS_02,
                                                         ARGS_03,
                                                         ARGS_04,
                                                         ARGS_05,
                                                         ARGS_06,
                                                         ARGS_07,
                                                         ARGS_08,
                                                         ARGS_09,
                                                         ARGS_10,
                                                         ARGS_11,
                                                         ARGS_12>::type,
          RET> >::type {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 13
template <class RET, class FUNC, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12,
                                 class ARGS_13>
struct Function_InvokerUtil_IsFuncInvocableImp<
    typename bslmf::VoidType<
        typename Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                                       ARGS_02,
                                                       ARGS_03,
                                                       ARGS_04,
                                                       ARGS_05,
                                                       ARGS_06,
                                                       ARGS_07,
                                                       ARGS_08,
                                                       ARGS_09,
                                                       ARGS_10,
                                                       ARGS_11,
                                                       ARGS_12,
                                                       ARGS_13>::type>::type,
    RET,
    FUNC,
    ARGS_01,
    ARGS_02,
    ARGS_03,
    ARGS_04,
    ARGS_05,
    ARGS_06,
    ARGS_07,
    ARGS_08,
    ARGS_09,
    ARGS_10,
    ARGS_11,
    ARGS_12,
    ARGS_13>
: bsl::conditional<
      bsl::is_void<RET>::value,
      bsl::true_type,
      Function_InvokerUtil_IsExplicitlyConvertible<
          typename Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                                         ARGS_02,
                                                         ARGS_03,
                                                         ARGS_04,
                                                         ARGS_05,
                                                         ARGS_06,
                                                         ARGS_07,
                                                         ARGS_08,
                                                         ARGS_09,
                                                         ARGS_10,
                                                         ARGS_11,
                                                         ARGS_12,
                                                         ARGS_13>::type,
          RET> >::type {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 13



template <class VOID_TYPE,
          class FUNC
#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 0
        , class ARGS_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 1
        , class ARGS_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 2
        , class ARGS_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 3
        , class ARGS_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 4
        , class ARGS_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 5
        , class ARGS_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 6
        , class ARGS_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 7
        , class ARGS_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 8
        , class ARGS_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 9
        , class ARGS_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 10
        , class ARGS_10 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 11
        , class ARGS_11 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 12
        , class ARGS_12 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 12
        , class = BSLS_COMPILERFEATURES_NILT>
struct Function_InvokerUtil_ResultTypeImp;


#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 0
template <class FUNC>
struct Function_InvokerUtil_ResultType<FUNC>
: Function_InvokerUtil_ResultTypeImp<void, FUNC> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 1
template <class FUNC, class ARGS_01>
struct Function_InvokerUtil_ResultType<FUNC, ARGS_01>
: Function_InvokerUtil_ResultTypeImp<void, FUNC, ARGS_01> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 2
template <class FUNC, class ARGS_01,
                      class ARGS_02>
struct Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                             ARGS_02>
: Function_InvokerUtil_ResultTypeImp<void, FUNC, ARGS_01,
                                                 ARGS_02> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 3
template <class FUNC, class ARGS_01,
                      class ARGS_02,
                      class ARGS_03>
struct Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                             ARGS_02,
                                             ARGS_03>
: Function_InvokerUtil_ResultTypeImp<void, FUNC, ARGS_01,
                                                 ARGS_02,
                                                 ARGS_03> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 4
template <class FUNC, class ARGS_01,
                      class ARGS_02,
                      class ARGS_03,
                      class ARGS_04>
struct Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04>
: Function_InvokerUtil_ResultTypeImp<void, FUNC, ARGS_01,
                                                 ARGS_02,
                                                 ARGS_03,
                                                 ARGS_04> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 5
template <class FUNC, class ARGS_01,
                      class ARGS_02,
                      class ARGS_03,
                      class ARGS_04,
                      class ARGS_05>
struct Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05>
: Function_InvokerUtil_ResultTypeImp<void, FUNC, ARGS_01,
                                                 ARGS_02,
                                                 ARGS_03,
                                                 ARGS_04,
                                                 ARGS_05> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 6
template <class FUNC, class ARGS_01,
                      class ARGS_02,
                      class ARGS_03,
                      class ARGS_04,
                      class ARGS_05,
                      class ARGS_06>
struct Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06>
: Function_InvokerUtil_ResultTypeImp<void, FUNC, ARGS_01,
                                                 ARGS_02,
                                                 ARGS_03,
                                                 ARGS_04,
                                                 ARGS_05,
                                                 ARGS_06> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 7
template <class FUNC, class ARGS_01,
                      class ARGS_02,
                      class ARGS_03,
                      class ARGS_04,
                      class ARGS_05,
                      class ARGS_06,
                      class ARGS_07>
struct Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07>
: Function_InvokerUtil_ResultTypeImp<void, FUNC, ARGS_01,
                                                 ARGS_02,
                                                 ARGS_03,
                                                 ARGS_04,
                                                 ARGS_05,
                                                 ARGS_06,
                                                 ARGS_07> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 8
template <class FUNC, class ARGS_01,
                      class ARGS_02,
                      class ARGS_03,
                      class ARGS_04,
                      class ARGS_05,
                      class ARGS_06,
                      class ARGS_07,
                      class ARGS_08>
struct Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08>
: Function_InvokerUtil_ResultTypeImp<void, FUNC, ARGS_01,
                                                 ARGS_02,
                                                 ARGS_03,
                                                 ARGS_04,
                                                 ARGS_05,
                                                 ARGS_06,
                                                 ARGS_07,
                                                 ARGS_08> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 9
template <class FUNC, class ARGS_01,
                      class ARGS_02,
                      class ARGS_03,
                      class ARGS_04,
                      class ARGS_05,
                      class ARGS_06,
                      class ARGS_07,
                      class ARGS_08,
                      class ARGS_09>
struct Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09>
: Function_InvokerUtil_ResultTypeImp<void, FUNC, ARGS_01,
                                                 ARGS_02,
                                                 ARGS_03,
                                                 ARGS_04,
                                                 ARGS_05,
                                                 ARGS_06,
                                                 ARGS_07,
                                                 ARGS_08,
                                                 ARGS_09> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 10
template <class FUNC, class ARGS_01,
                      class ARGS_02,
                      class ARGS_03,
                      class ARGS_04,
                      class ARGS_05,
                      class ARGS_06,
                      class ARGS_07,
                      class ARGS_08,
                      class ARGS_09,
                      class ARGS_10>
struct Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09,
                                             ARGS_10>
: Function_InvokerUtil_ResultTypeImp<void, FUNC, ARGS_01,
                                                 ARGS_02,
                                                 ARGS_03,
                                                 ARGS_04,
                                                 ARGS_05,
                                                 ARGS_06,
                                                 ARGS_07,
                                                 ARGS_08,
                                                 ARGS_09,
                                                 ARGS_10> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 11
template <class FUNC, class ARGS_01,
                      class ARGS_02,
                      class ARGS_03,
                      class ARGS_04,
                      class ARGS_05,
                      class ARGS_06,
                      class ARGS_07,
                      class ARGS_08,
                      class ARGS_09,
                      class ARGS_10,
                      class ARGS_11>
struct Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09,
                                             ARGS_10,
                                             ARGS_11>
: Function_InvokerUtil_ResultTypeImp<void, FUNC, ARGS_01,
                                                 ARGS_02,
                                                 ARGS_03,
                                                 ARGS_04,
                                                 ARGS_05,
                                                 ARGS_06,
                                                 ARGS_07,
                                                 ARGS_08,
                                                 ARGS_09,
                                                 ARGS_10,
                                                 ARGS_11> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 12
template <class FUNC, class ARGS_01,
                      class ARGS_02,
                      class ARGS_03,
                      class ARGS_04,
                      class ARGS_05,
                      class ARGS_06,
                      class ARGS_07,
                      class ARGS_08,
                      class ARGS_09,
                      class ARGS_10,
                      class ARGS_11,
                      class ARGS_12>
struct Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09,
                                             ARGS_10,
                                             ARGS_11,
                                             ARGS_12>
: Function_InvokerUtil_ResultTypeImp<void, FUNC, ARGS_01,
                                                 ARGS_02,
                                                 ARGS_03,
                                                 ARGS_04,
                                                 ARGS_05,
                                                 ARGS_06,
                                                 ARGS_07,
                                                 ARGS_08,
                                                 ARGS_09,
                                                 ARGS_10,
                                                 ARGS_11,
                                                 ARGS_12> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 13
template <class FUNC, class ARGS_01,
                      class ARGS_02,
                      class ARGS_03,
                      class ARGS_04,
                      class ARGS_05,
                      class ARGS_06,
                      class ARGS_07,
                      class ARGS_08,
                      class ARGS_09,
                      class ARGS_10,
                      class ARGS_11,
                      class ARGS_12,
                      class ARGS_13>
struct Function_InvokerUtil_ResultType<FUNC, ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09,
                                             ARGS_10,
                                             ARGS_11,
                                             ARGS_12,
                                             ARGS_13>
: Function_InvokerUtil_ResultTypeImp<void, FUNC, ARGS_01,
                                                 ARGS_02,
                                                 ARGS_03,
                                                 ARGS_04,
                                                 ARGS_05,
                                                 ARGS_06,
                                                 ARGS_07,
                                                 ARGS_08,
                                                 ARGS_09,
                                                 ARGS_10,
                                                 ARGS_11,
                                                 ARGS_12,
                                                 ARGS_13> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 13



#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 0
template <class VOID_TYPE, class FUNC>
struct Function_InvokerUtil_ResultTypeImp<VOID_TYPE, FUNC> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 1
template <class VOID_TYPE, class FUNC, class ARGS_01>
struct Function_InvokerUtil_ResultTypeImp<VOID_TYPE, FUNC, ARGS_01> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 2
template <class VOID_TYPE, class FUNC, class ARGS_01,
                                       class ARGS_02>
struct Function_InvokerUtil_ResultTypeImp<VOID_TYPE, FUNC, ARGS_01,
                                                           ARGS_02> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 3
template <class VOID_TYPE, class FUNC, class ARGS_01,
                                       class ARGS_02,
                                       class ARGS_03>
struct Function_InvokerUtil_ResultTypeImp<VOID_TYPE, FUNC, ARGS_01,
                                                           ARGS_02,
                                                           ARGS_03> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 4
template <class VOID_TYPE, class FUNC, class ARGS_01,
                                       class ARGS_02,
                                       class ARGS_03,
                                       class ARGS_04>
struct Function_InvokerUtil_ResultTypeImp<VOID_TYPE, FUNC, ARGS_01,
                                                           ARGS_02,
                                                           ARGS_03,
                                                           ARGS_04> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 5
template <class VOID_TYPE, class FUNC, class ARGS_01,
                                       class ARGS_02,
                                       class ARGS_03,
                                       class ARGS_04,
                                       class ARGS_05>
struct Function_InvokerUtil_ResultTypeImp<VOID_TYPE, FUNC, ARGS_01,
                                                           ARGS_02,
                                                           ARGS_03,
                                                           ARGS_04,
                                                           ARGS_05> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 6
template <class VOID_TYPE, class FUNC, class ARGS_01,
                                       class ARGS_02,
                                       class ARGS_03,
                                       class ARGS_04,
                                       class ARGS_05,
                                       class ARGS_06>
struct Function_InvokerUtil_ResultTypeImp<VOID_TYPE, FUNC, ARGS_01,
                                                           ARGS_02,
                                                           ARGS_03,
                                                           ARGS_04,
                                                           ARGS_05,
                                                           ARGS_06> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 7
template <class VOID_TYPE, class FUNC, class ARGS_01,
                                       class ARGS_02,
                                       class ARGS_03,
                                       class ARGS_04,
                                       class ARGS_05,
                                       class ARGS_06,
                                       class ARGS_07>
struct Function_InvokerUtil_ResultTypeImp<VOID_TYPE, FUNC, ARGS_01,
                                                           ARGS_02,
                                                           ARGS_03,
                                                           ARGS_04,
                                                           ARGS_05,
                                                           ARGS_06,
                                                           ARGS_07> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 8
template <class VOID_TYPE, class FUNC, class ARGS_01,
                                       class ARGS_02,
                                       class ARGS_03,
                                       class ARGS_04,
                                       class ARGS_05,
                                       class ARGS_06,
                                       class ARGS_07,
                                       class ARGS_08>
struct Function_InvokerUtil_ResultTypeImp<VOID_TYPE, FUNC, ARGS_01,
                                                           ARGS_02,
                                                           ARGS_03,
                                                           ARGS_04,
                                                           ARGS_05,
                                                           ARGS_06,
                                                           ARGS_07,
                                                           ARGS_08> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 9
template <class VOID_TYPE, class FUNC, class ARGS_01,
                                       class ARGS_02,
                                       class ARGS_03,
                                       class ARGS_04,
                                       class ARGS_05,
                                       class ARGS_06,
                                       class ARGS_07,
                                       class ARGS_08,
                                       class ARGS_09>
struct Function_InvokerUtil_ResultTypeImp<VOID_TYPE, FUNC, ARGS_01,
                                                           ARGS_02,
                                                           ARGS_03,
                                                           ARGS_04,
                                                           ARGS_05,
                                                           ARGS_06,
                                                           ARGS_07,
                                                           ARGS_08,
                                                           ARGS_09> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 10
template <class VOID_TYPE, class FUNC, class ARGS_01,
                                       class ARGS_02,
                                       class ARGS_03,
                                       class ARGS_04,
                                       class ARGS_05,
                                       class ARGS_06,
                                       class ARGS_07,
                                       class ARGS_08,
                                       class ARGS_09,
                                       class ARGS_10>
struct Function_InvokerUtil_ResultTypeImp<VOID_TYPE, FUNC, ARGS_01,
                                                           ARGS_02,
                                                           ARGS_03,
                                                           ARGS_04,
                                                           ARGS_05,
                                                           ARGS_06,
                                                           ARGS_07,
                                                           ARGS_08,
                                                           ARGS_09,
                                                           ARGS_10> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 11
template <class VOID_TYPE, class FUNC, class ARGS_01,
                                       class ARGS_02,
                                       class ARGS_03,
                                       class ARGS_04,
                                       class ARGS_05,
                                       class ARGS_06,
                                       class ARGS_07,
                                       class ARGS_08,
                                       class ARGS_09,
                                       class ARGS_10,
                                       class ARGS_11>
struct Function_InvokerUtil_ResultTypeImp<VOID_TYPE, FUNC, ARGS_01,
                                                           ARGS_02,
                                                           ARGS_03,
                                                           ARGS_04,
                                                           ARGS_05,
                                                           ARGS_06,
                                                           ARGS_07,
                                                           ARGS_08,
                                                           ARGS_09,
                                                           ARGS_10,
                                                           ARGS_11> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 12
template <class VOID_TYPE, class FUNC, class ARGS_01,
                                       class ARGS_02,
                                       class ARGS_03,
                                       class ARGS_04,
                                       class ARGS_05,
                                       class ARGS_06,
                                       class ARGS_07,
                                       class ARGS_08,
                                       class ARGS_09,
                                       class ARGS_10,
                                       class ARGS_11,
                                       class ARGS_12>
struct Function_InvokerUtil_ResultTypeImp<VOID_TYPE, FUNC, ARGS_01,
                                                           ARGS_02,
                                                           ARGS_03,
                                                           ARGS_04,
                                                           ARGS_05,
                                                           ARGS_06,
                                                           ARGS_07,
                                                           ARGS_08,
                                                           ARGS_09,
                                                           ARGS_10,
                                                           ARGS_11,
                                                           ARGS_12> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 13
template <class VOID_TYPE, class FUNC, class ARGS_01,
                                       class ARGS_02,
                                       class ARGS_03,
                                       class ARGS_04,
                                       class ARGS_05,
                                       class ARGS_06,
                                       class ARGS_07,
                                       class ARGS_08,
                                       class ARGS_09,
                                       class ARGS_10,
                                       class ARGS_11,
                                       class ARGS_12,
                                       class ARGS_13>
struct Function_InvokerUtil_ResultTypeImp<VOID_TYPE, FUNC, ARGS_01,
                                                           ARGS_02,
                                                           ARGS_03,
                                                           ARGS_04,
                                                           ARGS_05,
                                                           ARGS_06,
                                                           ARGS_07,
                                                           ARGS_08,
                                                           ARGS_09,
                                                           ARGS_10,
                                                           ARGS_11,
                                                           ARGS_12,
                                                           ARGS_13> {
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 13


#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 0
template <class FUNC>
struct Function_InvokerUtil_ResultTypeImp<
    typename bslmf::VoidType<
        >::type,
    FUNC>
: bsl::invoke_result<
      typename bsl::add_lvalue_reference<typename bslalg::NothrowMovableUtil::
                                             UnwrappedType<FUNC>::type>::type> {

};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 1
template <class FUNC, class ARGS_01>
struct Function_InvokerUtil_ResultTypeImp<
    typename bslmf::VoidType<
        typename Function_InvokerUtil_ForwardType<ARGS_01>::Type>::type,
    FUNC,
    ARGS_01>
: bsl::invoke_result<
      typename bsl::add_lvalue_reference<typename bslalg::NothrowMovableUtil::
                                             UnwrappedType<FUNC>::type>::type,
      typename Function_InvokerUtil_ForwardType<ARGS_01>::Type> {

};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 2
template <class FUNC, class ARGS_01,
                      class ARGS_02>
struct Function_InvokerUtil_ResultTypeImp<
    typename bslmf::VoidType<
        typename Function_InvokerUtil_ForwardType<ARGS_01>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_02>::Type>::type,
    FUNC,
    ARGS_01,
    ARGS_02>
: bsl::invoke_result<
      typename bsl::add_lvalue_reference<typename bslalg::NothrowMovableUtil::
                                             UnwrappedType<FUNC>::type>::type,
      typename Function_InvokerUtil_ForwardType<ARGS_01>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_02>::Type> {

};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 3
template <class FUNC, class ARGS_01,
                      class ARGS_02,
                      class ARGS_03>
struct Function_InvokerUtil_ResultTypeImp<
    typename bslmf::VoidType<
        typename Function_InvokerUtil_ForwardType<ARGS_01>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_02>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_03>::Type>::type,
    FUNC,
    ARGS_01,
    ARGS_02,
    ARGS_03>
: bsl::invoke_result<
      typename bsl::add_lvalue_reference<typename bslalg::NothrowMovableUtil::
                                             UnwrappedType<FUNC>::type>::type,
      typename Function_InvokerUtil_ForwardType<ARGS_01>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_02>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_03>::Type> {

};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 4
template <class FUNC, class ARGS_01,
                      class ARGS_02,
                      class ARGS_03,
                      class ARGS_04>
struct Function_InvokerUtil_ResultTypeImp<
    typename bslmf::VoidType<
        typename Function_InvokerUtil_ForwardType<ARGS_01>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_02>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_03>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_04>::Type>::type,
    FUNC,
    ARGS_01,
    ARGS_02,
    ARGS_03,
    ARGS_04>
: bsl::invoke_result<
      typename bsl::add_lvalue_reference<typename bslalg::NothrowMovableUtil::
                                             UnwrappedType<FUNC>::type>::type,
      typename Function_InvokerUtil_ForwardType<ARGS_01>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_02>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_03>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_04>::Type> {

};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 5
template <class FUNC, class ARGS_01,
                      class ARGS_02,
                      class ARGS_03,
                      class ARGS_04,
                      class ARGS_05>
struct Function_InvokerUtil_ResultTypeImp<
    typename bslmf::VoidType<
        typename Function_InvokerUtil_ForwardType<ARGS_01>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_02>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_03>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_04>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_05>::Type>::type,
    FUNC,
    ARGS_01,
    ARGS_02,
    ARGS_03,
    ARGS_04,
    ARGS_05>
: bsl::invoke_result<
      typename bsl::add_lvalue_reference<typename bslalg::NothrowMovableUtil::
                                             UnwrappedType<FUNC>::type>::type,
      typename Function_InvokerUtil_ForwardType<ARGS_01>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_02>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_03>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_04>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_05>::Type> {

};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 6
template <class FUNC, class ARGS_01,
                      class ARGS_02,
                      class ARGS_03,
                      class ARGS_04,
                      class ARGS_05,
                      class ARGS_06>
struct Function_InvokerUtil_ResultTypeImp<
    typename bslmf::VoidType<
        typename Function_InvokerUtil_ForwardType<ARGS_01>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_02>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_03>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_04>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_05>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_06>::Type>::type,
    FUNC,
    ARGS_01,
    ARGS_02,
    ARGS_03,
    ARGS_04,
    ARGS_05,
    ARGS_06>
: bsl::invoke_result<
      typename bsl::add_lvalue_reference<typename bslalg::NothrowMovableUtil::
                                             UnwrappedType<FUNC>::type>::type,
      typename Function_InvokerUtil_ForwardType<ARGS_01>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_02>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_03>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_04>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_05>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_06>::Type> {

};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 7
template <class FUNC, class ARGS_01,
                      class ARGS_02,
                      class ARGS_03,
                      class ARGS_04,
                      class ARGS_05,
                      class ARGS_06,
                      class ARGS_07>
struct Function_InvokerUtil_ResultTypeImp<
    typename bslmf::VoidType<
        typename Function_InvokerUtil_ForwardType<ARGS_01>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_02>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_03>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_04>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_05>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_06>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_07>::Type>::type,
    FUNC,
    ARGS_01,
    ARGS_02,
    ARGS_03,
    ARGS_04,
    ARGS_05,
    ARGS_06,
    ARGS_07>
: bsl::invoke_result<
      typename bsl::add_lvalue_reference<typename bslalg::NothrowMovableUtil::
                                             UnwrappedType<FUNC>::type>::type,
      typename Function_InvokerUtil_ForwardType<ARGS_01>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_02>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_03>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_04>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_05>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_06>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_07>::Type> {

};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 8
template <class FUNC, class ARGS_01,
                      class ARGS_02,
                      class ARGS_03,
                      class ARGS_04,
                      class ARGS_05,
                      class ARGS_06,
                      class ARGS_07,
                      class ARGS_08>
struct Function_InvokerUtil_ResultTypeImp<
    typename bslmf::VoidType<
        typename Function_InvokerUtil_ForwardType<ARGS_01>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_02>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_03>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_04>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_05>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_06>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_07>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_08>::Type>::type,
    FUNC,
    ARGS_01,
    ARGS_02,
    ARGS_03,
    ARGS_04,
    ARGS_05,
    ARGS_06,
    ARGS_07,
    ARGS_08>
: bsl::invoke_result<
      typename bsl::add_lvalue_reference<typename bslalg::NothrowMovableUtil::
                                             UnwrappedType<FUNC>::type>::type,
      typename Function_InvokerUtil_ForwardType<ARGS_01>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_02>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_03>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_04>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_05>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_06>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_07>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_08>::Type> {

};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 9
template <class FUNC, class ARGS_01,
                      class ARGS_02,
                      class ARGS_03,
                      class ARGS_04,
                      class ARGS_05,
                      class ARGS_06,
                      class ARGS_07,
                      class ARGS_08,
                      class ARGS_09>
struct Function_InvokerUtil_ResultTypeImp<
    typename bslmf::VoidType<
        typename Function_InvokerUtil_ForwardType<ARGS_01>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_02>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_03>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_04>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_05>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_06>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_07>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_08>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_09>::Type>::type,
    FUNC,
    ARGS_01,
    ARGS_02,
    ARGS_03,
    ARGS_04,
    ARGS_05,
    ARGS_06,
    ARGS_07,
    ARGS_08,
    ARGS_09>
: bsl::invoke_result<
      typename bsl::add_lvalue_reference<typename bslalg::NothrowMovableUtil::
                                             UnwrappedType<FUNC>::type>::type,
      typename Function_InvokerUtil_ForwardType<ARGS_01>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_02>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_03>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_04>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_05>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_06>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_07>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_08>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_09>::Type> {

};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 10
template <class FUNC, class ARGS_01,
                      class ARGS_02,
                      class ARGS_03,
                      class ARGS_04,
                      class ARGS_05,
                      class ARGS_06,
                      class ARGS_07,
                      class ARGS_08,
                      class ARGS_09,
                      class ARGS_10>
struct Function_InvokerUtil_ResultTypeImp<
    typename bslmf::VoidType<
        typename Function_InvokerUtil_ForwardType<ARGS_01>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_02>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_03>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_04>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_05>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_06>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_07>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_08>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_09>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_10>::Type>::type,
    FUNC,
    ARGS_01,
    ARGS_02,
    ARGS_03,
    ARGS_04,
    ARGS_05,
    ARGS_06,
    ARGS_07,
    ARGS_08,
    ARGS_09,
    ARGS_10>
: bsl::invoke_result<
      typename bsl::add_lvalue_reference<typename bslalg::NothrowMovableUtil::
                                             UnwrappedType<FUNC>::type>::type,
      typename Function_InvokerUtil_ForwardType<ARGS_01>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_02>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_03>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_04>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_05>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_06>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_07>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_08>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_09>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_10>::Type> {

};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 11
template <class FUNC, class ARGS_01,
                      class ARGS_02,
                      class ARGS_03,
                      class ARGS_04,
                      class ARGS_05,
                      class ARGS_06,
                      class ARGS_07,
                      class ARGS_08,
                      class ARGS_09,
                      class ARGS_10,
                      class ARGS_11>
struct Function_InvokerUtil_ResultTypeImp<
    typename bslmf::VoidType<
        typename Function_InvokerUtil_ForwardType<ARGS_01>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_02>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_03>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_04>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_05>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_06>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_07>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_08>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_09>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_10>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_11>::Type>::type,
    FUNC,
    ARGS_01,
    ARGS_02,
    ARGS_03,
    ARGS_04,
    ARGS_05,
    ARGS_06,
    ARGS_07,
    ARGS_08,
    ARGS_09,
    ARGS_10,
    ARGS_11>
: bsl::invoke_result<
      typename bsl::add_lvalue_reference<typename bslalg::NothrowMovableUtil::
                                             UnwrappedType<FUNC>::type>::type,
      typename Function_InvokerUtil_ForwardType<ARGS_01>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_02>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_03>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_04>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_05>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_06>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_07>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_08>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_09>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_10>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_11>::Type> {

};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 12
template <class FUNC, class ARGS_01,
                      class ARGS_02,
                      class ARGS_03,
                      class ARGS_04,
                      class ARGS_05,
                      class ARGS_06,
                      class ARGS_07,
                      class ARGS_08,
                      class ARGS_09,
                      class ARGS_10,
                      class ARGS_11,
                      class ARGS_12>
struct Function_InvokerUtil_ResultTypeImp<
    typename bslmf::VoidType<
        typename Function_InvokerUtil_ForwardType<ARGS_01>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_02>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_03>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_04>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_05>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_06>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_07>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_08>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_09>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_10>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_11>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_12>::Type>::type,
    FUNC,
    ARGS_01,
    ARGS_02,
    ARGS_03,
    ARGS_04,
    ARGS_05,
    ARGS_06,
    ARGS_07,
    ARGS_08,
    ARGS_09,
    ARGS_10,
    ARGS_11,
    ARGS_12>
: bsl::invoke_result<
      typename bsl::add_lvalue_reference<typename bslalg::NothrowMovableUtil::
                                             UnwrappedType<FUNC>::type>::type,
      typename Function_InvokerUtil_ForwardType<ARGS_01>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_02>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_03>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_04>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_05>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_06>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_07>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_08>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_09>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_10>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_11>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_12>::Type> {

};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 13
template <class FUNC, class ARGS_01,
                      class ARGS_02,
                      class ARGS_03,
                      class ARGS_04,
                      class ARGS_05,
                      class ARGS_06,
                      class ARGS_07,
                      class ARGS_08,
                      class ARGS_09,
                      class ARGS_10,
                      class ARGS_11,
                      class ARGS_12,
                      class ARGS_13>
struct Function_InvokerUtil_ResultTypeImp<
    typename bslmf::VoidType<
        typename Function_InvokerUtil_ForwardType<ARGS_01>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_02>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_03>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_04>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_05>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_06>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_07>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_08>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_09>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_10>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_11>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_12>::Type,
        typename Function_InvokerUtil_ForwardType<ARGS_13>::Type>::type,
    FUNC,
    ARGS_01,
    ARGS_02,
    ARGS_03,
    ARGS_04,
    ARGS_05,
    ARGS_06,
    ARGS_07,
    ARGS_08,
    ARGS_09,
    ARGS_10,
    ARGS_11,
    ARGS_12,
    ARGS_13>
: bsl::invoke_result<
      typename bsl::add_lvalue_reference<typename bslalg::NothrowMovableUtil::
                                             UnwrappedType<FUNC>::type>::type,
      typename Function_InvokerUtil_ForwardType<ARGS_01>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_02>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_03>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_04>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_05>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_06>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_07>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_08>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_09>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_10>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_11>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_12>::Type,
      typename Function_InvokerUtil_ForwardType<ARGS_13>::Type> {

};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 13



template <class VOID_TYPE, class ARG>
struct Function_InvokerUtil_ForwardTypeImp;

template <class ARG>
struct Function_InvokerUtil_ForwardType
: Function_InvokerUtil_ForwardTypeImp<void, ARG> {
};


template <class VOID_TYPE, class ARG>
struct Function_InvokerUtil_ForwardTypeImp {
};

template <class ARG>
struct Function_InvokerUtil_ForwardTypeImp<
    typename bslmf::VoidType<decltype(
        bslmf::ForwardingTypeUtil<ARG>::forwardToTarget(
            std::declval<typename bsl::add_lvalue_reference<
                typename bslmf::ForwardingType<ARG>::Type>::type>()))>::type,
    ARG> {


    typedef decltype(bslmf::ForwardingTypeUtil<ARG>::forwardToTarget(
        std::declval<typename bsl::add_lvalue_reference<
            typename bslmf::ForwardingType<ARG>::Type>::type>())) Type;
};


template <class VOID_TYPE, class FROM, class TO>
struct Function_InvokerUtil_IsExplicitlyConvertibleImp;

template <class FROM, class TO>
struct Function_InvokerUtil_IsExplicitlyConvertible
: Function_InvokerUtil_IsExplicitlyConvertibleImp<void, FROM, TO> {
};

template <class FROM_TO>
struct Function_InvokerUtil_IsExplicitlyConvertible<FROM_TO, FROM_TO>
: bsl::true_type {
};


template <class VOID_TYPE, class FROM, class TO>
struct Function_InvokerUtil_IsExplicitlyConvertibleImp :  bsl::false_type {
};

template <class FROM, class TO>
struct Function_InvokerUtil_IsExplicitlyConvertibleImp<
    typename bslmf::VoidType<decltype(
       static_cast<TO>(std::declval<FROM>()))>::type,
    FROM,
    TO> : bsl::true_type {
};

#endif
#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.


#ifdef BSLSTL_FUNCTION_INVOKERUTIL_SUPPORT_IS_FUNC_INVOCABLE

template <class VOID_TYPE, class RET, class FUNC, class... ARGS>
struct Function_InvokerUtil_IsFuncInvocableImp;

template <class RET, class FUNC, class... ARGS>
struct Function_InvokerUtil_IsFuncInvocable<RET(ARGS...), FUNC>
: Function_InvokerUtil_IsFuncInvocableImp<void, RET, FUNC, ARGS...> {
};


template <class ARG>
struct Function_InvokerUtil_ForwardType;

template <class FROM, class TO>
struct Function_InvokerUtil_IsExplicitlyConvertible;

template <class FUNC, class... ARGS>
struct Function_InvokerUtil_ResultType;

template <class VOID_TYPE, class RET, class FUNC, class... ARGS>
struct Function_InvokerUtil_IsFuncInvocableImp : bsl::false_type {
};

template <class RET, class FUNC, class... ARGS>
struct Function_InvokerUtil_IsFuncInvocableImp<
    typename bslmf::VoidType<
        typename Function_InvokerUtil_ResultType<FUNC, ARGS...>::type>::type,
    RET,
    FUNC,
    ARGS...>
: bsl::conditional<
      bsl::is_void<RET>::value,
      bsl::true_type,
      Function_InvokerUtil_IsExplicitlyConvertible<
          typename Function_InvokerUtil_ResultType<FUNC, ARGS...>::type,
          RET> >::type {
};


template <class VOID_TYPE, class FUNC, class... ARGS>
struct Function_InvokerUtil_ResultTypeImp;

template <class FUNC, class... ARGS>
struct Function_InvokerUtil_ResultType
: Function_InvokerUtil_ResultTypeImp<void, FUNC, ARGS...> {
};


template <class VOID_TYPE, class FUNC, class... ARGS>
struct Function_InvokerUtil_ResultTypeImp {
};

template <class FUNC, class... ARGS>
struct Function_InvokerUtil_ResultTypeImp<
    typename bslmf::VoidType<
        typename Function_InvokerUtil_ForwardType<ARGS>::Type...>::type,
    FUNC,
    ARGS...>
: bsl::invoke_result<
      typename bsl::add_lvalue_reference<typename bslalg::NothrowMovableUtil::
                                             UnwrappedType<FUNC>::type>::type,
      typename Function_InvokerUtil_ForwardType<ARGS>::Type...> {

};


template <class VOID_TYPE, class ARG>
struct Function_InvokerUtil_ForwardTypeImp;

template <class ARG>
struct Function_InvokerUtil_ForwardType
: Function_InvokerUtil_ForwardTypeImp<void, ARG> {
};


template <class VOID_TYPE, class ARG>
struct Function_InvokerUtil_ForwardTypeImp {
};

template <class ARG>
struct Function_InvokerUtil_ForwardTypeImp<
    typename bslmf::VoidType<decltype(
        bslmf::ForwardingTypeUtil<ARG>::forwardToTarget(
            std::declval<typename bsl::add_lvalue_reference<
                typename bslmf::ForwardingType<ARG>::Type>::type>()))>::type,
    ARG> {


    typedef decltype(bslmf::ForwardingTypeUtil<ARG>::forwardToTarget(
        std::declval<typename bsl::add_lvalue_reference<
            typename bslmf::ForwardingType<ARG>::Type>::type>())) Type;
};


template <class VOID_TYPE, class FROM, class TO>
struct Function_InvokerUtil_IsExplicitlyConvertibleImp;

template <class FROM, class TO>
struct Function_InvokerUtil_IsExplicitlyConvertible
: Function_InvokerUtil_IsExplicitlyConvertibleImp<void, FROM, TO> {
};

template <class FROM_TO>
struct Function_InvokerUtil_IsExplicitlyConvertible<FROM_TO, FROM_TO>
: bsl::true_type {
};


template <class VOID_TYPE, class FROM, class TO>
struct Function_InvokerUtil_IsExplicitlyConvertibleImp :  bsl::false_type {
};

template <class FROM, class TO>
struct Function_InvokerUtil_IsExplicitlyConvertibleImp<
    typename bslmf::VoidType<decltype(
       static_cast<TO>(std::declval<FROM>()))>::type,
    FROM,
    TO> : bsl::true_type {
};

#endif
// }}} END GENERATED CODE
#endif

               // =============================================
               // template struct Function_InvokerUtil_Dispatch
               // =============================================

/// Specializations of this class contain a static `invoke` method that can
/// invoke a callable object of type `FUNC`, converting each argument in
/// `PROTOTYPE` (a function prototype) to the corresponding argument in the
/// invocation of the callable object and converting the return value of the
/// invocation to the return type of `PROTOTYPE`.  The `INVOCATION_TYPE`
/// specifies the category of callable object: pointer to function, pointer
/// to member function, pointer to data member, inplace functor (i.e., one
/// that qualifies for the small-object optimization) and out-of-place
/// functor (i.e., one that is not stored in the small-object buffer).
template <int INVOCATION_TYPE, class PROTOTYPE, class FUNC>
struct Function_InvokerUtil_Dispatch;

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_function_invokerutil.h
#ifndef BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT
#define BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT 13
#endif
#ifndef BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B
#define BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT
#endif


#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 0
template <class FUNC, class RET>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(), FUNC> {


    static RET invoke(const Function_Rep                            *rep);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 1
template <class FUNC, class RET, class ARGS_01>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(ARGS_01), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 2
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(ARGS_01,
                                         ARGS_02), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 3
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 4
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 5
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 6
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 7
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 8
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 9
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 10
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09,
                                         ARGS_10), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 11
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09,
                                         ARGS_10,
                                         ARGS_11), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                      typename bslmf::ForwardingType<ARGS_11>::Type args_11);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 12
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09,
                                         ARGS_10,
                                         ARGS_11,
                                         ARGS_12), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                      typename bslmf::ForwardingType<ARGS_11>::Type args_11,
                      typename bslmf::ForwardingType<ARGS_12>::Type args_12);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 13
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12,
                                 class ARGS_13>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09,
                                         ARGS_10,
                                         ARGS_11,
                                         ARGS_12,
                                         ARGS_13), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                      typename bslmf::ForwardingType<ARGS_11>::Type args_11,
                      typename bslmf::ForwardingType<ARGS_12>::Type args_12,
                      typename bslmf::ForwardingType<ARGS_13>::Type args_13);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 13


#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 0
template <class FUNC, class RET, class ARG0>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0), FUNC> {

  private:

    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj);

  public:

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 1
template <class FUNC, class RET, class ARG0, class ARGS_01>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0, ARGS_01), FUNC> {

  private:

    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01);

  public:

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 2
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0, ARGS_01,
                                               ARGS_02), FUNC> {

  private:

    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02);

  public:

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 3
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0, ARGS_01,
                                               ARGS_02,
                                               ARGS_03), FUNC> {

  private:

    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03);

  public:

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 4
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0, ARGS_01,
                                               ARGS_02,
                                               ARGS_03,
                                               ARGS_04), FUNC> {

  private:

    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04);

  public:

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 5
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0, ARGS_01,
                                               ARGS_02,
                                               ARGS_03,
                                               ARGS_04,
                                               ARGS_05), FUNC> {

  private:

    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05);

  public:

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 6
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0, ARGS_01,
                                               ARGS_02,
                                               ARGS_03,
                                               ARGS_04,
                                               ARGS_05,
                                               ARGS_06), FUNC> {

  private:

    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06);

  public:

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 7
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0, ARGS_01,
                                               ARGS_02,
                                               ARGS_03,
                                               ARGS_04,
                                               ARGS_05,
                                               ARGS_06,
                                               ARGS_07), FUNC> {

  private:

    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                        typename bslmf::ForwardingType<ARGS_07>::Type args_07);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                        typename bslmf::ForwardingType<ARGS_07>::Type args_07);

  public:

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 8
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0, ARGS_01,
                                               ARGS_02,
                                               ARGS_03,
                                               ARGS_04,
                                               ARGS_05,
                                               ARGS_06,
                                               ARGS_07,
                                               ARGS_08), FUNC> {

  private:

    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                        typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                        typename bslmf::ForwardingType<ARGS_08>::Type args_08);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                        typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                        typename bslmf::ForwardingType<ARGS_08>::Type args_08);

  public:

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 9
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0, ARGS_01,
                                               ARGS_02,
                                               ARGS_03,
                                               ARGS_04,
                                               ARGS_05,
                                               ARGS_06,
                                               ARGS_07,
                                               ARGS_08,
                                               ARGS_09), FUNC> {

  private:

    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                        typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                        typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                        typename bslmf::ForwardingType<ARGS_09>::Type args_09);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                        typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                        typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                        typename bslmf::ForwardingType<ARGS_09>::Type args_09);

  public:

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 10
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0, ARGS_01,
                                               ARGS_02,
                                               ARGS_03,
                                               ARGS_04,
                                               ARGS_05,
                                               ARGS_06,
                                               ARGS_07,
                                               ARGS_08,
                                               ARGS_09,
                                               ARGS_10), FUNC> {

  private:

    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                        typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                        typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                        typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                        typename bslmf::ForwardingType<ARGS_10>::Type args_10);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                        typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                        typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                        typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                        typename bslmf::ForwardingType<ARGS_10>::Type args_10);

  public:

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 11
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0, ARGS_01,
                                               ARGS_02,
                                               ARGS_03,
                                               ARGS_04,
                                               ARGS_05,
                                               ARGS_06,
                                               ARGS_07,
                                               ARGS_08,
                                               ARGS_09,
                                               ARGS_10,
                                               ARGS_11), FUNC> {

  private:

    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                        typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                        typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                        typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                        typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                        typename bslmf::ForwardingType<ARGS_11>::Type args_11);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                        typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                        typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                        typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                        typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                        typename bslmf::ForwardingType<ARGS_11>::Type args_11);

  public:

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                      typename bslmf::ForwardingType<ARGS_11>::Type args_11);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 12
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11,
                                             class ARGS_12>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0, ARGS_01,
                                               ARGS_02,
                                               ARGS_03,
                                               ARGS_04,
                                               ARGS_05,
                                               ARGS_06,
                                               ARGS_07,
                                               ARGS_08,
                                               ARGS_09,
                                               ARGS_10,
                                               ARGS_11,
                                               ARGS_12), FUNC> {

  private:

    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                        typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                        typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                        typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                        typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                        typename bslmf::ForwardingType<ARGS_11>::Type args_11,
                        typename bslmf::ForwardingType<ARGS_12>::Type args_12);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                        typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                        typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                        typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                        typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                        typename bslmf::ForwardingType<ARGS_11>::Type args_11,
                        typename bslmf::ForwardingType<ARGS_12>::Type args_12);

  public:

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                      typename bslmf::ForwardingType<ARGS_11>::Type args_11,
                      typename bslmf::ForwardingType<ARGS_12>::Type args_12);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 13
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11,
                                             class ARGS_12,
                                             class ARGS_13>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0, ARGS_01,
                                               ARGS_02,
                                               ARGS_03,
                                               ARGS_04,
                                               ARGS_05,
                                               ARGS_06,
                                               ARGS_07,
                                               ARGS_08,
                                               ARGS_09,
                                               ARGS_10,
                                               ARGS_11,
                                               ARGS_12,
                                               ARGS_13), FUNC> {

  private:

    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                        typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                        typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                        typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                        typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                        typename bslmf::ForwardingType<ARGS_11>::Type args_11,
                        typename bslmf::ForwardingType<ARGS_12>::Type args_12,
                        typename bslmf::ForwardingType<ARGS_13>::Type args_13);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                        typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                        typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                        typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                        typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                        typename bslmf::ForwardingType<ARGS_11>::Type args_11,
                        typename bslmf::ForwardingType<ARGS_12>::Type args_12,
                        typename bslmf::ForwardingType<ARGS_13>::Type args_13);

  public:

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                      typename bslmf::ForwardingType<ARGS_11>::Type args_11,
                      typename bslmf::ForwardingType<ARGS_12>::Type args_12,
                      typename bslmf::ForwardingType<ARGS_13>::Type args_13);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 13


template <class MEMBER_TYPE, class CLASS_TYPE, class RET, class ARG0>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemDataPtr,
                                     RET(ARG0), MEMBER_TYPE CLASS_TYPE::*> {
  private:
    typedef MEMBER_TYPE CLASS_TYPE::* Func;

    static RET invokeImp(bsl::true_type ,
                         Func                                        f,
                         typename bslmf::ForwardingType<ARG0>::Type  obj);

    static RET invokeImp(bsl::false_type ,
                         Func                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj);

  public:

    static RET invoke(const Function_Rep                         *rep,
                      typename bslmf::ForwardingType<ARG0>::Type  obj);
};

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 0
template <class FUNC, class RET>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(), FUNC> {


    static RET invoke(const Function_Rep                            *rep);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 1
template <class FUNC, class RET, class ARGS_01>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(ARGS_01), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 2
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 3
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 4
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 5
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 6
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 7
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 8
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 9
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 10
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09,
                                         ARGS_10), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 11
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09,
                                         ARGS_10,
                                         ARGS_11), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                      typename bslmf::ForwardingType<ARGS_11>::Type args_11);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 12
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09,
                                         ARGS_10,
                                         ARGS_11,
                                         ARGS_12), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                      typename bslmf::ForwardingType<ARGS_11>::Type args_11,
                      typename bslmf::ForwardingType<ARGS_12>::Type args_12);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 13
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12,
                                 class ARGS_13>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09,
                                         ARGS_10,
                                         ARGS_11,
                                         ARGS_12,
                                         ARGS_13), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                      typename bslmf::ForwardingType<ARGS_11>::Type args_11,
                      typename bslmf::ForwardingType<ARGS_12>::Type args_12,
                      typename bslmf::ForwardingType<ARGS_13>::Type args_13);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 13


#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 0
template <class FUNC, class RET>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(), FUNC> {


    static RET invoke(const Function_Rep                            *rep);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 1
template <class FUNC, class RET, class ARGS_01>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(ARGS_01), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 2
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 3
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 4
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 5
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 6
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 7
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 8
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 9
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 10
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09,
                                         ARGS_10), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 11
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09,
                                         ARGS_10,
                                         ARGS_11), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                      typename bslmf::ForwardingType<ARGS_11>::Type args_11);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 12
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09,
                                         ARGS_10,
                                         ARGS_11,
                                         ARGS_12), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                      typename bslmf::ForwardingType<ARGS_11>::Type args_11,
                      typename bslmf::ForwardingType<ARGS_12>::Type args_12);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 13
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12,
                                 class ARGS_13>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09,
                                         ARGS_10,
                                         ARGS_11,
                                         ARGS_12,
                                         ARGS_13), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                      typename bslmf::ForwardingType<ARGS_11>::Type args_11,
                      typename bslmf::ForwardingType<ARGS_12>::Type args_12,
                      typename bslmf::ForwardingType<ARGS_13>::Type args_13);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 13

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.


template <class FUNC, class RET, class... ARGS>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(ARGS...), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS>::Type...  args);
};

template <class FUNC, class RET, class ARG0, class... ARGS>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0, ARGS...), FUNC> {

  private:

    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                         typename bslmf::ForwardingType<ARGS>::Type...  args);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                         typename bslmf::ForwardingType<ARGS>::Type...  args);

  public:

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj,
                      typename bslmf::ForwardingType<ARGS>::Type...  args);
};

template <class MEMBER_TYPE, class CLASS_TYPE, class RET, class ARG0>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemDataPtr,
                                     RET(ARG0), MEMBER_TYPE CLASS_TYPE::*> {
  private:
    typedef MEMBER_TYPE CLASS_TYPE::* Func;

    static RET invokeImp(bsl::true_type ,
                         Func                                        f,
                         typename bslmf::ForwardingType<ARG0>::Type  obj);

    static RET invokeImp(bsl::false_type ,
                         Func                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj);

  public:

    static RET invoke(const Function_Rep                         *rep,
                      typename bslmf::ForwardingType<ARG0>::Type  obj);
};

template <class FUNC, class RET, class... ARGS>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(ARGS...), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS>::Type...  args);
};

template <class FUNC, class RET, class... ARGS>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(ARGS...), FUNC> {


    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS>::Type...  args);
};

// }}} END GENERATED CODE
#endif

// ===========================================================================
//                TEMPLATE AND INLINE FUNCTION IMPLEMENTATIONS
// ===========================================================================

                        // ---------------------------
                        // struct Function_InvokerUtil
                        // ---------------------------

template <class PROTOTYPE>
inline
bslstl::Function_InvokerUtil::GenericInvoker *
bslstl::Function_InvokerUtil::invokerForFunc(const bsl::nullptr_t&)
{
    return 0;
}

template <class PROTOTYPE, class FUNC>
bslstl::Function_InvokerUtil::GenericInvoker *
bslstl::Function_InvokerUtil::invokerForFunc(const FUNC& f)
{
    typedef bslstl::Function_SmallObjectOptimization Soo;

    // Strip 'NothrowMovableWrapper' (if any) off of 'FUNC' type.
    typedef typename
        bslalg::NothrowMovableUtil::UnwrappedType<FUNC>::type UwFuncType;

    // Categorize the type of invocable corresponding to 'FUNC'.  Note that the
    // parameter to 'Soo::Inplace' is 'FUNC', not 'UwFuncType'.  That is
    // because 'Soo::Inplace' takes the wrapper into account when determining
    // whether the type should be inplace or not.
    static const int k_INVOCATION_TYPE =
        bslmf::IsFunctionPointer<UwFuncType>::value       ? e_FunctionPtr    :
        bslmf::IsMemberFunctionPointer<UwFuncType>::value ? e_MemFunctionPtr :
        bsl::is_member_pointer<UwFuncType>::value         ? e_MemDataPtr     :
        Soo::IsInplaceFunc<FUNC>::value                   ? e_InplaceFunctor :
        e_OutofplaceFunctor;

    // Instantiate the class for checking for null object
    typedef Function_InvokerUtilNullCheck<UwFuncType> NullCheckerClass;

    // Instantiate the class for dispatching the invoker
    typedef Function_InvokerUtil_Dispatch<k_INVOCATION_TYPE,
                                          PROTOTYPE,
                                          UwFuncType> DispatcherClass;

    // If a the object is "null", e.g., for a pointer, then return null.
    if (NullCheckerClass::isNull(bslalg::NothrowMovableUtil::unwrap(f)))
    {
        return 0;                                                     // RETURN
    }

    // Verify the assumption that all function pointers are the same size.
    BSLMF_ASSERT(sizeof(&DispatcherClass::invoke) ==
                 sizeof(Function_Rep::GenericInvoker *));

    // Return a pointer to the actual invoker function
    return reinterpret_cast<Function_Rep::GenericInvoker *>(
                                                 &DispatcherClass::invoke);
}

               // ---------------------------------------------
               // struct template Function_InvokerUtilNullCheck
               // ---------------------------------------------

// STATIC MEMBER FUNCTIONS

template <class FUNC>
inline
bool Function_InvokerUtilNullCheck<FUNC>::isNull(const FUNC&)
{
    return false;
}

template <class FUNC>
inline
bool Function_InvokerUtilNullCheck<FUNC *>::isNull(FUNC* f)
{
    return 0 == f;
}

template <class CLASS, class MEMTYPE>
inline
bool
Function_InvokerUtilNullCheck<MEMTYPE CLASS::*>::isNull(MEMTYPE CLASS::* f)
{
    return 0 == f;
}


               // ---------------------------------------------
               // struct template Function_InvokerUtil_Dispatch
               // ---------------------------------------------

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_function_invokerutil.h
#ifndef BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT
#define BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT 13
#endif
#ifndef BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C
#define BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT
#endif

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 0
template <class FUNC, class RET>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(), FUNC>::
invoke(const Function_Rep                            *rep)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f());
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 1
template <class FUNC, class RET, class ARGS_01>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(ARGS_01), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 2
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(ARGS_01,
                                  ARGS_02), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 3
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 4
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 5
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 6
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 7
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 8
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 9
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 10
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09,
                                  ARGS_10), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
          bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 11
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09,
                                  ARGS_10,
                                  ARGS_11), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10,
       typename bslmf::ForwardingType<ARGS_11>::Type args_11)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
          bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
          bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 12
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09,
                                  ARGS_10,
                                  ARGS_11,
                                  ARGS_12), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10,
       typename bslmf::ForwardingType<ARGS_11>::Type args_11,
       typename bslmf::ForwardingType<ARGS_12>::Type args_12)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
          bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
          bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11),
          bslmf::ForwardingTypeUtil<ARGS_12>::forwardToTarget(args_12)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 13
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12,
                                 class ARGS_13>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09,
                                  ARGS_10,
                                  ARGS_11,
                                  ARGS_12,
                                  ARGS_13), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10,
       typename bslmf::ForwardingType<ARGS_11>::Type args_11,
       typename bslmf::ForwardingType<ARGS_12>::Type args_12,
       typename bslmf::ForwardingType<ARGS_13>::Type args_13)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
          bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
          bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11),
          bslmf::ForwardingTypeUtil<ARGS_12>::forwardToTarget(args_12),
          bslmf::ForwardingTypeUtil<ARGS_13>::forwardToTarget(args_13)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 13


#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 0
template <class FUNC, class RET, class ARG0>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            ));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 1
template <class FUNC, class RET, class ARG0, class ARGS_01>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 2
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 3
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 4
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 5
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 6
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 7
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06,
          typename bslmf::ForwardingType<ARGS_07>::Type args_07)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
            bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 8
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06,
          typename bslmf::ForwardingType<ARGS_07>::Type args_07,
          typename bslmf::ForwardingType<ARGS_08>::Type args_08)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
            bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
            bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 9
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06,
          typename bslmf::ForwardingType<ARGS_07>::Type args_07,
          typename bslmf::ForwardingType<ARGS_08>::Type args_08,
          typename bslmf::ForwardingType<ARGS_09>::Type args_09)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
            bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
            bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
            bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 10
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06,
          typename bslmf::ForwardingType<ARGS_07>::Type args_07,
          typename bslmf::ForwardingType<ARGS_08>::Type args_08,
          typename bslmf::ForwardingType<ARGS_09>::Type args_09,
          typename bslmf::ForwardingType<ARGS_10>::Type args_10)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
            bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
            bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
            bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
            bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 11
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10,
                                        ARGS_11), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06,
          typename bslmf::ForwardingType<ARGS_07>::Type args_07,
          typename bslmf::ForwardingType<ARGS_08>::Type args_08,
          typename bslmf::ForwardingType<ARGS_09>::Type args_09,
          typename bslmf::ForwardingType<ARGS_10>::Type args_10,
          typename bslmf::ForwardingType<ARGS_11>::Type args_11)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
            bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
            bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
            bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
            bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
            bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 12
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11,
                                             class ARGS_12>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10,
                                        ARGS_11,
                                        ARGS_12), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06,
          typename bslmf::ForwardingType<ARGS_07>::Type args_07,
          typename bslmf::ForwardingType<ARGS_08>::Type args_08,
          typename bslmf::ForwardingType<ARGS_09>::Type args_09,
          typename bslmf::ForwardingType<ARGS_10>::Type args_10,
          typename bslmf::ForwardingType<ARGS_11>::Type args_11,
          typename bslmf::ForwardingType<ARGS_12>::Type args_12)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
            bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
            bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
            bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
            bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
            bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11),
            bslmf::ForwardingTypeUtil<ARGS_12>::forwardToTarget(args_12)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 13
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11,
                                             class ARGS_12,
                                             class ARGS_13>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10,
                                        ARGS_11,
                                        ARGS_12,
                                        ARGS_13), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06,
          typename bslmf::ForwardingType<ARGS_07>::Type args_07,
          typename bslmf::ForwardingType<ARGS_08>::Type args_08,
          typename bslmf::ForwardingType<ARGS_09>::Type args_09,
          typename bslmf::ForwardingType<ARGS_10>::Type args_10,
          typename bslmf::ForwardingType<ARGS_11>::Type args_11,
          typename bslmf::ForwardingType<ARGS_12>::Type args_12,
          typename bslmf::ForwardingType<ARGS_13>::Type args_13)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
            bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
            bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
            bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
            bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
            bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11),
            bslmf::ForwardingTypeUtil<ARGS_12>::forwardToTarget(args_12),
            bslmf::ForwardingTypeUtil<ARGS_13>::forwardToTarget(args_13)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 13


#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 0
template <class FUNC, class RET, class ARG0>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            ));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 1
template <class FUNC, class RET, class ARG0, class ARGS_01>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 2
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 3
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 4
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 5
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 6
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 7
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06,
          typename bslmf::ForwardingType<ARGS_07>::Type args_07)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
            bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 8
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06,
          typename bslmf::ForwardingType<ARGS_07>::Type args_07,
          typename bslmf::ForwardingType<ARGS_08>::Type args_08)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
            bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
            bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 9
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06,
          typename bslmf::ForwardingType<ARGS_07>::Type args_07,
          typename bslmf::ForwardingType<ARGS_08>::Type args_08,
          typename bslmf::ForwardingType<ARGS_09>::Type args_09)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
            bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
            bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
            bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 10
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06,
          typename bslmf::ForwardingType<ARGS_07>::Type args_07,
          typename bslmf::ForwardingType<ARGS_08>::Type args_08,
          typename bslmf::ForwardingType<ARGS_09>::Type args_09,
          typename bslmf::ForwardingType<ARGS_10>::Type args_10)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
            bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
            bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
            bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
            bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 11
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10,
                                        ARGS_11), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06,
          typename bslmf::ForwardingType<ARGS_07>::Type args_07,
          typename bslmf::ForwardingType<ARGS_08>::Type args_08,
          typename bslmf::ForwardingType<ARGS_09>::Type args_09,
          typename bslmf::ForwardingType<ARGS_10>::Type args_10,
          typename bslmf::ForwardingType<ARGS_11>::Type args_11)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
            bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
            bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
            bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
            bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
            bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 12
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11,
                                             class ARGS_12>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10,
                                        ARGS_11,
                                        ARGS_12), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06,
          typename bslmf::ForwardingType<ARGS_07>::Type args_07,
          typename bslmf::ForwardingType<ARGS_08>::Type args_08,
          typename bslmf::ForwardingType<ARGS_09>::Type args_09,
          typename bslmf::ForwardingType<ARGS_10>::Type args_10,
          typename bslmf::ForwardingType<ARGS_11>::Type args_11,
          typename bslmf::ForwardingType<ARGS_12>::Type args_12)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
            bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
            bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
            bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
            bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
            bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11),
            bslmf::ForwardingTypeUtil<ARGS_12>::forwardToTarget(args_12)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 13
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11,
                                             class ARGS_12,
                                             class ARGS_13>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10,
                                        ARGS_11,
                                        ARGS_12,
                                        ARGS_13), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06,
          typename bslmf::ForwardingType<ARGS_07>::Type args_07,
          typename bslmf::ForwardingType<ARGS_08>::Type args_08,
          typename bslmf::ForwardingType<ARGS_09>::Type args_09,
          typename bslmf::ForwardingType<ARGS_10>::Type args_10,
          typename bslmf::ForwardingType<ARGS_11>::Type args_11,
          typename bslmf::ForwardingType<ARGS_12>::Type args_12,
          typename bslmf::ForwardingType<ARGS_13>::Type args_13)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
            bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
            bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
            bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
            bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
            bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11),
            bslmf::ForwardingTypeUtil<ARGS_12>::forwardToTarget(args_12),
            bslmf::ForwardingTypeUtil<ARGS_13>::forwardToTarget(args_13)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 13


#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 0
template <class FUNC, class RET, class ARG0>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 1
template <class FUNC, class RET, class ARG0, class ARGS_01>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj,
                                                            args_01));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 2
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj,
                                                            args_01,
                                                            args_02));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 3
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj,
                                                            args_01,
                                                            args_02,
                                                            args_03));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 4
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj,
                                                            args_01,
                                                            args_02,
                                                            args_03,
                                                            args_04));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 5
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj,
                                                            args_01,
                                                            args_02,
                                                            args_03,
                                                            args_04,
                                                            args_05));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 6
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj,
                                                            args_01,
                                                            args_02,
                                                            args_03,
                                                            args_04,
                                                            args_05,
                                                            args_06));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 7
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj,
                                                            args_01,
                                                            args_02,
                                                            args_03,
                                                            args_04,
                                                            args_05,
                                                            args_06,
                                                            args_07));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 8
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj,
                                                            args_01,
                                                            args_02,
                                                            args_03,
                                                            args_04,
                                                            args_05,
                                                            args_06,
                                                            args_07,
                                                            args_08));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 9
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj,
                                                            args_01,
                                                            args_02,
                                                            args_03,
                                                            args_04,
                                                            args_05,
                                                            args_06,
                                                            args_07,
                                                            args_08,
                                                            args_09));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 10
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj,
                                                            args_01,
                                                            args_02,
                                                            args_03,
                                                            args_04,
                                                            args_05,
                                                            args_06,
                                                            args_07,
                                                            args_08,
                                                            args_09,
                                                            args_10));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 11
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10,
                                        ARGS_11), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10,
       typename bslmf::ForwardingType<ARGS_11>::Type args_11)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj,
                                                            args_01,
                                                            args_02,
                                                            args_03,
                                                            args_04,
                                                            args_05,
                                                            args_06,
                                                            args_07,
                                                            args_08,
                                                            args_09,
                                                            args_10,
                                                            args_11));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 12
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11,
                                             class ARGS_12>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10,
                                        ARGS_11,
                                        ARGS_12), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10,
       typename bslmf::ForwardingType<ARGS_11>::Type args_11,
       typename bslmf::ForwardingType<ARGS_12>::Type args_12)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj,
                                                            args_01,
                                                            args_02,
                                                            args_03,
                                                            args_04,
                                                            args_05,
                                                            args_06,
                                                            args_07,
                                                            args_08,
                                                            args_09,
                                                            args_10,
                                                            args_11,
                                                            args_12));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 13
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11,
                                             class ARGS_12,
                                             class ARGS_13>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10,
                                        ARGS_11,
                                        ARGS_12,
                                        ARGS_13), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10,
       typename bslmf::ForwardingType<ARGS_11>::Type args_11,
       typename bslmf::ForwardingType<ARGS_12>::Type args_12,
       typename bslmf::ForwardingType<ARGS_13>::Type args_13)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj,
                                                            args_01,
                                                            args_02,
                                                            args_03,
                                                            args_04,
                                                            args_05,
                                                            args_06,
                                                            args_07,
                                                            args_08,
                                                            args_09,
                                                            args_10,
                                                            args_11,
                                                            args_12,
                                                            args_13));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 13


template <class MEMBER_TYPE, class CLASS_TYPE, class RET, class ARG0>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemDataPtr,
                              RET(ARG0), MEMBER_TYPE CLASS_TYPE::*>::
invokeImp(bsl::true_type ,
          Func                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f));
}

template <class MEMBER_TYPE, class CLASS_TYPE, class RET, class ARG0>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemDataPtr,
                              RET(ARG0), MEMBER_TYPE CLASS_TYPE::*>::
invokeImp(bsl::false_type ,
          Func                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f));
}

template <class MEMBER_TYPE, class CLASS_TYPE, class RET, class ARG0>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemDataPtr,
                              RET(ARG0), MEMBER_TYPE CLASS_TYPE::*>::
invoke(const Function_Rep                         *rep,
       typename bslmf::ForwardingType<ARG0>::Type  obj)
{
    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            const volatile CLASS_TYPE *
        >::type IsDirect;

    Func f = *rep->targetRaw<Func, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, invokeImp(IsDirect(), f, obj));
}

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 0
template <class FUNC, class RET>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(), FUNC>::
invoke(const Function_Rep                            *rep)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f());
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 1
template <class FUNC, class RET, class ARGS_01>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(ARGS_01), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 2
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 3
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 4
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 5
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 6
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 7
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 8
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 9
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 10
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09,
                                  ARGS_10), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
          bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 11
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09,
                                  ARGS_10,
                                  ARGS_11), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10,
       typename bslmf::ForwardingType<ARGS_11>::Type args_11)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
          bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
          bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 12
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09,
                                  ARGS_10,
                                  ARGS_11,
                                  ARGS_12), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10,
       typename bslmf::ForwardingType<ARGS_11>::Type args_11,
       typename bslmf::ForwardingType<ARGS_12>::Type args_12)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
          bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
          bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11),
          bslmf::ForwardingTypeUtil<ARGS_12>::forwardToTarget(args_12)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 13
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12,
                                 class ARGS_13>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09,
                                  ARGS_10,
                                  ARGS_11,
                                  ARGS_12,
                                  ARGS_13), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10,
       typename bslmf::ForwardingType<ARGS_11>::Type args_11,
       typename bslmf::ForwardingType<ARGS_12>::Type args_12,
       typename bslmf::ForwardingType<ARGS_13>::Type args_13)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
          bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
          bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11),
          bslmf::ForwardingTypeUtil<ARGS_12>::forwardToTarget(args_12),
          bslmf::ForwardingTypeUtil<ARGS_13>::forwardToTarget(args_13)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 13


#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 0
template <class FUNC, class RET>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(), FUNC>::
invoke(const Function_Rep                            *rep)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f());
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 1
template <class FUNC, class RET, class ARGS_01>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(ARGS_01), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 2
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 3
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 4
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 5
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 6
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 7
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 8
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 9
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 10
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09,
                                  ARGS_10), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
          bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 11
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09,
                                  ARGS_10,
                                  ARGS_11), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10,
       typename bslmf::ForwardingType<ARGS_11>::Type args_11)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
          bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
          bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 12
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09,
                                  ARGS_10,
                                  ARGS_11,
                                  ARGS_12), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10,
       typename bslmf::ForwardingType<ARGS_11>::Type args_11,
       typename bslmf::ForwardingType<ARGS_12>::Type args_12)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
          bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
          bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11),
          bslmf::ForwardingTypeUtil<ARGS_12>::forwardToTarget(args_12)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 13
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12,
                                 class ARGS_13>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09,
                                  ARGS_10,
                                  ARGS_11,
                                  ARGS_12,
                                  ARGS_13), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10,
       typename bslmf::ForwardingType<ARGS_11>::Type args_11,
       typename bslmf::ForwardingType<ARGS_12>::Type args_12,
       typename bslmf::ForwardingType<ARGS_13>::Type args_13)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
          bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
          bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11),
          bslmf::ForwardingTypeUtil<ARGS_12>::forwardToTarget(args_12),
          bslmf::ForwardingTypeUtil<ARGS_13>::forwardToTarget(args_13)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_C >= 13

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.

template <class FUNC, class RET, class... ARGS>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(ARGS...), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS>::Type...  args)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS>::forwardToTarget(args)...));
}

template <class FUNC, class RET, class ARG0, class... ARGS>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS...), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS>::Type...  args)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            bslmf::ForwardingTypeUtil<ARGS>::forwardToTarget(args)...));
}

template <class FUNC, class RET, class ARG0, class... ARGS>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS...), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS>::Type...  args)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            bslmf::ForwardingTypeUtil<ARGS>::forwardToTarget(args)...));
}

template <class FUNC, class RET, class ARG0, class... ARGS>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS...), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj,
       typename bslmf::ForwardingType<ARGS>::Type...  args)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj,
                                                            args...));
}

template <class MEMBER_TYPE, class CLASS_TYPE, class RET, class ARG0>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemDataPtr,
                              RET(ARG0), MEMBER_TYPE CLASS_TYPE::*>::
invokeImp(bsl::true_type ,
          Func                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f));
}

template <class MEMBER_TYPE, class CLASS_TYPE, class RET, class ARG0>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemDataPtr,
                              RET(ARG0), MEMBER_TYPE CLASS_TYPE::*>::
invokeImp(bsl::false_type ,
          Func                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f));
}

template <class MEMBER_TYPE, class CLASS_TYPE, class RET, class ARG0>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemDataPtr,
                              RET(ARG0), MEMBER_TYPE CLASS_TYPE::*>::
invoke(const Function_Rep                         *rep,
       typename bslmf::ForwardingType<ARG0>::Type  obj)
{
    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            const volatile CLASS_TYPE *
        >::type IsDirect;

    Func f = *rep->targetRaw<Func, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, invokeImp(IsDirect(), f, obj));
}

template <class FUNC, class RET, class... ARGS>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(ARGS...), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS>::Type...  args)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS>::forwardToTarget(args)...));
}

template <class FUNC, class RET, class... ARGS>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(ARGS...), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS>::Type...  args)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS>::forwardToTarget(args)...));
}

// }}} END GENERATED CODE
#endif

}  // close package namespace
}  // close enterprise namespace

#else // if ! defined(DEFINED_BSLSTL_FUNCTION_INVOKERUTIL_H)
# error Not valid except when included from bslstl_function_invokerutil.h
#endif // ! defined(COMPILING_BSLSTL_FUNCTION_INVOKERUTIL_H)

#endif // ! defined(INCLUDED_BSLSTL_FUNCTION_INVOKERUTIL_CPP03)

// ----------------------------------------------------------------------------
// Copyright 2020 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
