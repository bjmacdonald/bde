// bslmf_disjunction_cpp03.h                                          -*-C++-*-

// Automatically generated file.  **DO NOT EDIT**

#ifndef INCLUDED_BSLMF_DISJUNCTION_CPP03
#define INCLUDED_BSLMF_DISJUNCTION_CPP03

//@PURPOSE: Provide C++03 implementation for bslmf_disjunction.h
//
//@CLASSES: See bslmf_disjunction.h for list of classes
//
//@SEE_ALSO: bslmf_disjunction
//
//@DESCRIPTION:  This component is the C++03 translation of a C++11 component,
// generated by the 'sim_cpp11_features.pl' program.  If the original header
// contains any specially delimited regions of C++11 code, then this generated
// file contains the C++03 equivalent, i.e., with variadic templates expanded
// and rvalue-references replaced by 'bslmf::MovableRef' objects.  The header
// code in this file is designed to be '#include'd into the original header
// when compiling with a C++03 compiler.  If there are no specially delimited
// regions of C++11 code, then this header contains no code and is not
// '#include'd in the original header.
//
// Generated on Thu Feb 22 04:02:11 2024
// Command line: sim_cpp11_features.pl bslmf_disjunction.h

#ifdef COMPILING_BSLMF_DISJUNCTION_H

namespace bsl {

#ifdef BSLS_LIBRARYFEATURES_HAS_CPP17_BASELINE_LIBRARY

using std::disjunction;
using std::disjunction_v;

#else

                         // ==================
                         // struct disjunction
                         // ==================

// forward declaration (required for C++03)
#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslmf_disjunction.h
#ifndef BSLMF_DISJUNCTION_VARIADIC_LIMIT
#define BSLMF_DISJUNCTION_VARIADIC_LIMIT 10
#endif
#ifndef BSLMF_DISJUNCTION_VARIADIC_LIMIT_A
#define BSLMF_DISJUNCTION_VARIADIC_LIMIT_A BSLMF_DISJUNCTION_VARIADIC_LIMIT
#endif
template <
#if BSLMF_DISJUNCTION_VARIADIC_LIMIT_A >= 0
class B_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_DISJUNCTION_VARIADIC_LIMIT_A >= 0

#if BSLMF_DISJUNCTION_VARIADIC_LIMIT_A >= 1
        , class B_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_DISJUNCTION_VARIADIC_LIMIT_A >= 1

#if BSLMF_DISJUNCTION_VARIADIC_LIMIT_A >= 2
        , class B_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_DISJUNCTION_VARIADIC_LIMIT_A >= 2

#if BSLMF_DISJUNCTION_VARIADIC_LIMIT_A >= 3
        , class B_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_DISJUNCTION_VARIADIC_LIMIT_A >= 3

#if BSLMF_DISJUNCTION_VARIADIC_LIMIT_A >= 4
        , class B_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_DISJUNCTION_VARIADIC_LIMIT_A >= 4

#if BSLMF_DISJUNCTION_VARIADIC_LIMIT_A >= 5
        , class B_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_DISJUNCTION_VARIADIC_LIMIT_A >= 5

#if BSLMF_DISJUNCTION_VARIADIC_LIMIT_A >= 6
        , class B_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_DISJUNCTION_VARIADIC_LIMIT_A >= 6

#if BSLMF_DISJUNCTION_VARIADIC_LIMIT_A >= 7
        , class B_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_DISJUNCTION_VARIADIC_LIMIT_A >= 7

#if BSLMF_DISJUNCTION_VARIADIC_LIMIT_A >= 8
        , class B_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_DISJUNCTION_VARIADIC_LIMIT_A >= 8

#if BSLMF_DISJUNCTION_VARIADIC_LIMIT_A >= 9
        , class B_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_DISJUNCTION_VARIADIC_LIMIT_A >= 9
        , class = BSLS_COMPILERFEATURES_NILT>
struct disjunction;

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class... B>
struct disjunction;
// }}} END GENERATED CODE
#endif

// 0 args specialization
#ifdef BSLS_COMPILERFEATURES_SUPPORT_VARIADIC_TEMPLATES
template <class...>
struct disjunction : false_type {
};
#else
template <>
struct disjunction<> : false_type {
};
#endif

// 1 arg specialization
template <class B1>
struct disjunction<B1> : B1 {
};

// other cases
#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslmf_disjunction.h
#ifndef BSLMF_DISJUNCTION_VARIADIC_LIMIT
#define BSLMF_DISJUNCTION_VARIADIC_LIMIT 10
#endif
#ifndef BSLMF_DISJUNCTION_VARIADIC_LIMIT_B
#define BSLMF_DISJUNCTION_VARIADIC_LIMIT_B BSLMF_DISJUNCTION_VARIADIC_LIMIT
#endif
#if BSLMF_DISJUNCTION_VARIADIC_LIMIT_B >= 0
template <class B1, class B2>
struct disjunction<B1, B2> :
    conditional<bool(B1::value), B1, disjunction<B2> >::type {
};
#endif  // BSLMF_DISJUNCTION_VARIADIC_LIMIT_B >= 0

#if BSLMF_DISJUNCTION_VARIADIC_LIMIT_B >= 1
template <class B1, class B2, class Bn_1>
struct disjunction<B1, B2, Bn_1> :
    conditional<bool(B1::value), B1, disjunction<B2, Bn_1> >::type {
};
#endif  // BSLMF_DISJUNCTION_VARIADIC_LIMIT_B >= 1

#if BSLMF_DISJUNCTION_VARIADIC_LIMIT_B >= 2
template <class B1, class B2, class Bn_1,
                              class Bn_2>
struct disjunction<B1, B2, Bn_1,
                           Bn_2> :
    conditional<bool(B1::value), B1, disjunction<B2, Bn_1,
                                                     Bn_2> >::type {
};
#endif  // BSLMF_DISJUNCTION_VARIADIC_LIMIT_B >= 2

#if BSLMF_DISJUNCTION_VARIADIC_LIMIT_B >= 3
template <class B1, class B2, class Bn_1,
                              class Bn_2,
                              class Bn_3>
struct disjunction<B1, B2, Bn_1,
                           Bn_2,
                           Bn_3> :
    conditional<bool(B1::value), B1, disjunction<B2, Bn_1,
                                                     Bn_2,
                                                     Bn_3> >::type {
};
#endif  // BSLMF_DISJUNCTION_VARIADIC_LIMIT_B >= 3

#if BSLMF_DISJUNCTION_VARIADIC_LIMIT_B >= 4
template <class B1, class B2, class Bn_1,
                              class Bn_2,
                              class Bn_3,
                              class Bn_4>
struct disjunction<B1, B2, Bn_1,
                           Bn_2,
                           Bn_3,
                           Bn_4> :
    conditional<bool(B1::value), B1, disjunction<B2, Bn_1,
                                                     Bn_2,
                                                     Bn_3,
                                                     Bn_4> >::type {
};
#endif  // BSLMF_DISJUNCTION_VARIADIC_LIMIT_B >= 4

#if BSLMF_DISJUNCTION_VARIADIC_LIMIT_B >= 5
template <class B1, class B2, class Bn_1,
                              class Bn_2,
                              class Bn_3,
                              class Bn_4,
                              class Bn_5>
struct disjunction<B1, B2, Bn_1,
                           Bn_2,
                           Bn_3,
                           Bn_4,
                           Bn_5> :
    conditional<bool(B1::value), B1, disjunction<B2, Bn_1,
                                                     Bn_2,
                                                     Bn_3,
                                                     Bn_4,
                                                     Bn_5> >::type {
};
#endif  // BSLMF_DISJUNCTION_VARIADIC_LIMIT_B >= 5

#if BSLMF_DISJUNCTION_VARIADIC_LIMIT_B >= 6
template <class B1, class B2, class Bn_1,
                              class Bn_2,
                              class Bn_3,
                              class Bn_4,
                              class Bn_5,
                              class Bn_6>
struct disjunction<B1, B2, Bn_1,
                           Bn_2,
                           Bn_3,
                           Bn_4,
                           Bn_5,
                           Bn_6> :
    conditional<bool(B1::value), B1, disjunction<B2, Bn_1,
                                                     Bn_2,
                                                     Bn_3,
                                                     Bn_4,
                                                     Bn_5,
                                                     Bn_6> >::type {
};
#endif  // BSLMF_DISJUNCTION_VARIADIC_LIMIT_B >= 6

#if BSLMF_DISJUNCTION_VARIADIC_LIMIT_B >= 7
template <class B1, class B2, class Bn_1,
                              class Bn_2,
                              class Bn_3,
                              class Bn_4,
                              class Bn_5,
                              class Bn_6,
                              class Bn_7>
struct disjunction<B1, B2, Bn_1,
                           Bn_2,
                           Bn_3,
                           Bn_4,
                           Bn_5,
                           Bn_6,
                           Bn_7> :
    conditional<bool(B1::value), B1, disjunction<B2, Bn_1,
                                                     Bn_2,
                                                     Bn_3,
                                                     Bn_4,
                                                     Bn_5,
                                                     Bn_6,
                                                     Bn_7> >::type {
};
#endif  // BSLMF_DISJUNCTION_VARIADIC_LIMIT_B >= 7

#if BSLMF_DISJUNCTION_VARIADIC_LIMIT_B >= 8
template <class B1, class B2, class Bn_1,
                              class Bn_2,
                              class Bn_3,
                              class Bn_4,
                              class Bn_5,
                              class Bn_6,
                              class Bn_7,
                              class Bn_8>
struct disjunction<B1, B2, Bn_1,
                           Bn_2,
                           Bn_3,
                           Bn_4,
                           Bn_5,
                           Bn_6,
                           Bn_7,
                           Bn_8> :
    conditional<bool(B1::value), B1, disjunction<B2, Bn_1,
                                                     Bn_2,
                                                     Bn_3,
                                                     Bn_4,
                                                     Bn_5,
                                                     Bn_6,
                                                     Bn_7,
                                                     Bn_8> >::type {
};
#endif  // BSLMF_DISJUNCTION_VARIADIC_LIMIT_B >= 8

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class B1, class B2, class... Bn>
struct disjunction<B1, B2, Bn...> :
    conditional<bool(B1::value), B1, disjunction<B2, Bn...> >::type {
};
// }}} END GENERATED CODE
#endif

#ifdef BSLS_COMPILERFEATURES_SUPPORT_VARIABLE_TEMPLATES
template <class... B>
BSLS_KEYWORD_INLINE_VARIABLE
constexpr bool disjunction_v = disjunction<B...>::value;
#endif

#endif

}  // close namespace bsl

#else // if ! defined(DEFINED_BSLMF_DISJUNCTION_H)
# error Not valid except when included from bslmf_disjunction.h
#endif // ! defined(COMPILING_BSLMF_DISJUNCTION_H)

#endif // ! defined(INCLUDED_BSLMF_DISJUNCTION_CPP03)

// ----------------------------------------------------------------------------
// Copyright 2024 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
