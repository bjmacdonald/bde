// bslmf_conjunction_cpp03.h                                          -*-C++-*-

// Automatically generated file.  **DO NOT EDIT**

#ifndef INCLUDED_BSLMF_CONJUNCTION_CPP03
#define INCLUDED_BSLMF_CONJUNCTION_CPP03

//@PURPOSE: Provide C++03 implementation for bslmf_conjunction.h
//
//@CLASSES: See bslmf_conjunction.h for list of classes
//
//@SEE_ALSO: bslmf_conjunction
//
//@DESCRIPTION:  This component is the C++03 translation of a C++11 component,
// generated by the 'sim_cpp11_features.pl' program.  If the original header
// contains any specially delimited regions of C++11 code, then this generated
// file contains the C++03 equivalent, i.e., with variadic templates expanded
// and rvalue-references replaced by 'bslmf::MovableRef' objects.  The header
// code in this file is designed to be '#include'd into the original header
// when compiling with a C++03 compiler.  If there are no specially delimited
// regions of C++11 code, then this header contains no code and is not
// '#include'd in the original header.
//
// Generated on Thu Feb 22 04:02:11 2024
// Command line: sim_cpp11_features.pl bslmf_conjunction.h

#ifdef COMPILING_BSLMF_CONJUNCTION_H

namespace bsl {

#ifdef BSLS_LIBRARYFEATURES_HAS_CPP17_BASELINE_LIBRARY

using std::conjunction;
using std::conjunction_v;

#else

                         // ==================
                         // struct conjunction
                         // ==================

// forward declaration (required for C++03)
#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslmf_conjunction.h
#ifndef BSLMF_CONJUNCTION_VARIADIC_LIMIT
#define BSLMF_CONJUNCTION_VARIADIC_LIMIT 10
#endif
#ifndef BSLMF_CONJUNCTION_VARIADIC_LIMIT_A
#define BSLMF_CONJUNCTION_VARIADIC_LIMIT_A BSLMF_CONJUNCTION_VARIADIC_LIMIT
#endif
template <
#if BSLMF_CONJUNCTION_VARIADIC_LIMIT_A >= 0
class B_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_CONJUNCTION_VARIADIC_LIMIT_A >= 0

#if BSLMF_CONJUNCTION_VARIADIC_LIMIT_A >= 1
        , class B_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_CONJUNCTION_VARIADIC_LIMIT_A >= 1

#if BSLMF_CONJUNCTION_VARIADIC_LIMIT_A >= 2
        , class B_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_CONJUNCTION_VARIADIC_LIMIT_A >= 2

#if BSLMF_CONJUNCTION_VARIADIC_LIMIT_A >= 3
        , class B_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_CONJUNCTION_VARIADIC_LIMIT_A >= 3

#if BSLMF_CONJUNCTION_VARIADIC_LIMIT_A >= 4
        , class B_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_CONJUNCTION_VARIADIC_LIMIT_A >= 4

#if BSLMF_CONJUNCTION_VARIADIC_LIMIT_A >= 5
        , class B_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_CONJUNCTION_VARIADIC_LIMIT_A >= 5

#if BSLMF_CONJUNCTION_VARIADIC_LIMIT_A >= 6
        , class B_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_CONJUNCTION_VARIADIC_LIMIT_A >= 6

#if BSLMF_CONJUNCTION_VARIADIC_LIMIT_A >= 7
        , class B_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_CONJUNCTION_VARIADIC_LIMIT_A >= 7

#if BSLMF_CONJUNCTION_VARIADIC_LIMIT_A >= 8
        , class B_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_CONJUNCTION_VARIADIC_LIMIT_A >= 8

#if BSLMF_CONJUNCTION_VARIADIC_LIMIT_A >= 9
        , class B_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_CONJUNCTION_VARIADIC_LIMIT_A >= 9
        , class = BSLS_COMPILERFEATURES_NILT>
struct conjunction;

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class... B>
struct conjunction;
// }}} END GENERATED CODE
#endif

// 0 args specialization
#ifdef BSLS_COMPILERFEATURES_SUPPORT_VARIADIC_TEMPLATES
template <class...>
struct conjunction : true_type {
};
#else
template <>
struct conjunction<> : true_type {
};
#endif

// 1 arg specialization
template <class B1>
struct conjunction<B1> : B1 {
};

// other cases
#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslmf_conjunction.h
#ifndef BSLMF_CONJUNCTION_VARIADIC_LIMIT
#define BSLMF_CONJUNCTION_VARIADIC_LIMIT 10
#endif
#ifndef BSLMF_CONJUNCTION_VARIADIC_LIMIT_B
#define BSLMF_CONJUNCTION_VARIADIC_LIMIT_B BSLMF_CONJUNCTION_VARIADIC_LIMIT
#endif
#if BSLMF_CONJUNCTION_VARIADIC_LIMIT_B >= 0
template <class B1, class B2>
struct conjunction<B1, B2> :
    conditional<bool(B1::value), conjunction<B2>, B1>::type {
};
#endif  // BSLMF_CONJUNCTION_VARIADIC_LIMIT_B >= 0

#if BSLMF_CONJUNCTION_VARIADIC_LIMIT_B >= 1
template <class B1, class B2, class Bn_1>
struct conjunction<B1, B2, Bn_1> :
    conditional<bool(B1::value), conjunction<B2, Bn_1>, B1>::type {
};
#endif  // BSLMF_CONJUNCTION_VARIADIC_LIMIT_B >= 1

#if BSLMF_CONJUNCTION_VARIADIC_LIMIT_B >= 2
template <class B1, class B2, class Bn_1,
                              class Bn_2>
struct conjunction<B1, B2, Bn_1,
                           Bn_2> :
    conditional<bool(B1::value), conjunction<B2, Bn_1,
                                                 Bn_2>, B1>::type {
};
#endif  // BSLMF_CONJUNCTION_VARIADIC_LIMIT_B >= 2

#if BSLMF_CONJUNCTION_VARIADIC_LIMIT_B >= 3
template <class B1, class B2, class Bn_1,
                              class Bn_2,
                              class Bn_3>
struct conjunction<B1, B2, Bn_1,
                           Bn_2,
                           Bn_3> :
    conditional<bool(B1::value), conjunction<B2, Bn_1,
                                                 Bn_2,
                                                 Bn_3>, B1>::type {
};
#endif  // BSLMF_CONJUNCTION_VARIADIC_LIMIT_B >= 3

#if BSLMF_CONJUNCTION_VARIADIC_LIMIT_B >= 4
template <class B1, class B2, class Bn_1,
                              class Bn_2,
                              class Bn_3,
                              class Bn_4>
struct conjunction<B1, B2, Bn_1,
                           Bn_2,
                           Bn_3,
                           Bn_4> :
    conditional<bool(B1::value), conjunction<B2, Bn_1,
                                                 Bn_2,
                                                 Bn_3,
                                                 Bn_4>, B1>::type {
};
#endif  // BSLMF_CONJUNCTION_VARIADIC_LIMIT_B >= 4

#if BSLMF_CONJUNCTION_VARIADIC_LIMIT_B >= 5
template <class B1, class B2, class Bn_1,
                              class Bn_2,
                              class Bn_3,
                              class Bn_4,
                              class Bn_5>
struct conjunction<B1, B2, Bn_1,
                           Bn_2,
                           Bn_3,
                           Bn_4,
                           Bn_5> :
    conditional<bool(B1::value), conjunction<B2, Bn_1,
                                                 Bn_2,
                                                 Bn_3,
                                                 Bn_4,
                                                 Bn_5>, B1>::type {
};
#endif  // BSLMF_CONJUNCTION_VARIADIC_LIMIT_B >= 5

#if BSLMF_CONJUNCTION_VARIADIC_LIMIT_B >= 6
template <class B1, class B2, class Bn_1,
                              class Bn_2,
                              class Bn_3,
                              class Bn_4,
                              class Bn_5,
                              class Bn_6>
struct conjunction<B1, B2, Bn_1,
                           Bn_2,
                           Bn_3,
                           Bn_4,
                           Bn_5,
                           Bn_6> :
    conditional<bool(B1::value), conjunction<B2, Bn_1,
                                                 Bn_2,
                                                 Bn_3,
                                                 Bn_4,
                                                 Bn_5,
                                                 Bn_6>, B1>::type {
};
#endif  // BSLMF_CONJUNCTION_VARIADIC_LIMIT_B >= 6

#if BSLMF_CONJUNCTION_VARIADIC_LIMIT_B >= 7
template <class B1, class B2, class Bn_1,
                              class Bn_2,
                              class Bn_3,
                              class Bn_4,
                              class Bn_5,
                              class Bn_6,
                              class Bn_7>
struct conjunction<B1, B2, Bn_1,
                           Bn_2,
                           Bn_3,
                           Bn_4,
                           Bn_5,
                           Bn_6,
                           Bn_7> :
    conditional<bool(B1::value), conjunction<B2, Bn_1,
                                                 Bn_2,
                                                 Bn_3,
                                                 Bn_4,
                                                 Bn_5,
                                                 Bn_6,
                                                 Bn_7>, B1>::type {
};
#endif  // BSLMF_CONJUNCTION_VARIADIC_LIMIT_B >= 7

#if BSLMF_CONJUNCTION_VARIADIC_LIMIT_B >= 8
template <class B1, class B2, class Bn_1,
                              class Bn_2,
                              class Bn_3,
                              class Bn_4,
                              class Bn_5,
                              class Bn_6,
                              class Bn_7,
                              class Bn_8>
struct conjunction<B1, B2, Bn_1,
                           Bn_2,
                           Bn_3,
                           Bn_4,
                           Bn_5,
                           Bn_6,
                           Bn_7,
                           Bn_8> :
    conditional<bool(B1::value), conjunction<B2, Bn_1,
                                                 Bn_2,
                                                 Bn_3,
                                                 Bn_4,
                                                 Bn_5,
                                                 Bn_6,
                                                 Bn_7,
                                                 Bn_8>, B1>::type {
};
#endif  // BSLMF_CONJUNCTION_VARIADIC_LIMIT_B >= 8

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class B1, class B2, class... Bn>
struct conjunction<B1, B2, Bn...> :
    conditional<bool(B1::value), conjunction<B2, Bn...>, B1>::type {
};
// }}} END GENERATED CODE
#endif

#ifdef BSLS_COMPILERFEATURES_SUPPORT_VARIABLE_TEMPLATES
template <class... B>
BSLS_KEYWORD_INLINE_VARIABLE
constexpr bool conjunction_v = conjunction<B...>::value;
#endif

#endif

}  // close namespace bsl

#else // if ! defined(DEFINED_BSLMF_CONJUNCTION_H)
# error Not valid except when included from bslmf_conjunction.h
#endif // ! defined(COMPILING_BSLMF_CONJUNCTION_H)

#endif // ! defined(INCLUDED_BSLMF_CONJUNCTION_CPP03)

// ----------------------------------------------------------------------------
// Copyright 2024 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
