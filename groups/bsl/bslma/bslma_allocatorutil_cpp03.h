// bslma_allocatorutil_cpp03.h                                        -*-C++-*-

// Automatically generated file.  **DO NOT EDIT**

#ifndef INCLUDED_BSLMA_ALLOCATORUTIL_CPP03
#define INCLUDED_BSLMA_ALLOCATORUTIL_CPP03

//@PURPOSE: Provide C++03 implementation for bslma_allocatorutil.h
//
//@CLASSES: See bslma_allocatorutil.h for list of classes
//
//@SEE_ALSO: bslma_allocatorutil
//
//@DESCRIPTION:  This component is the C++03 translation of a C++11 component,
// generated by the 'sim_cpp11_features.pl' program.  If the original header
// contains any specially delimited regions of C++11 code, then this generated
// file contains the C++03 equivalent, i.e., with variadic templates expanded
// and rvalue-references replaced by 'bslmf::MovableRef' objects.  The header
// code in this file is designed to be '#include'd into the original header
// when compiling with a C++03 compiler.  If there are no specially delimited
// regions of C++11 code, then this header contains no code and is not
// '#include'd in the original header.
//
// Generated on Sun Dec 10 17:15:40 2023
// Command line: sim_cpp11_features.pl bslma_allocatorutil.h

#ifdef COMPILING_BSLMA_ALLOCATORUTIL_H

namespace BloombergLP {
namespace bslma {

// FORWARD DECLARATIONS
template <class t_ALLOCATOR, class t_TYPE = char>
struct AllocatorUtil_Traits;

                        // ===================
                        // class AllocatorUtil
                        // ===================

struct AllocatorUtil {
    // Namespace for utility functions on allocators

  private:
    // PRIVATE CONSTANTS
    enum { k_MAX_ALIGNMENT = bsls::AlignmentUtil::BSLS_MAX_ALIGNMENT };

    // PRIVATE CLASS METHODS
    template <class t_TYPE>
    static char matchBslAlloc(bsl::allocator<t_TYPE> *, int);
    static long matchBslAlloc(void *,                 ...);
        // DECLARED BUT NOT DEFINED

    template <class t_TYPE>
    static
    void *allocateBytesImp(const bsl::polymorphic_allocator<t_TYPE>& allocator,
                           std::size_t                             nbytes,
                           std::size_t                             alignment);
    template <class t_TYPE>
    static
    void *allocateBytesImp(const bsl::allocator<t_TYPE>& allocator,
                           std::size_t                 nbytes,
                           std::size_t                 alignment);
    template <class t_ALLOCATOR>
    static
    typename AllocatorUtil_Traits<t_ALLOCATOR>::void_pointer
    allocateBytesImp(const t_ALLOCATOR&          allocator,
                     std::size_t               nbytes,
                     std::size_t               alignment);
        // Return the specified 'nbytes' raw bytes having the specified
        // 'alignment' allocated from the specified 'allocator'.  If
        // 'alignment' is larger than the largest supported alignment, the
        // behavior is determined by the allocator.

    template <class t_TYPE>
    static void
    deallocateBytesImp(const bsl::polymorphic_allocator<t_TYPE>&  allocator,
                       void                                    *p,
                       std::size_t                              nbytes,
                       std::size_t                              alignment);
    template <class t_TYPE>
    static void
    deallocateBytesImp(const bsl::allocator<t_TYPE>&  allocator,
                       void                        *p,
                       std::size_t                  nbytes,
                       std::size_t                  alignment);
    template <class t_ALLOCATOR>
    static void deallocateBytesImp(
        const t_ALLOCATOR&                                       allocator,
        typename AllocatorUtil_Traits<t_ALLOCATOR>::void_pointer p,
        std::size_t                                            nbytes,
        std::size_t                                            alignment);
        // Return, to the specified 'allocator', the block of raw memory at the
        // specified 'p' address having the specified 'nbytes' size and the
        // specified 'alignment'.  The behavior is undefined unless 'p' refers
        // to a block having the same size and alignment allocated from a copy
        // of 'allocator' and not yet deallocated.

    template <class t_ALLOCATOR, class t_POINTER, class t_VALUE_TYPE>
    static void deallocateObjectImp(const t_ALLOCATOR&  allocator,
                                    t_POINTER           p,
                                    std::size_t       n,
                                    const t_VALUE_TYPE& );

    template <class t_ALLOCATOR, class t_POINTER, class t_VALUE_TYPE>
    static void deleteObjectImp(const t_ALLOCATOR&  allocator,
                                t_POINTER           p,
                                const t_VALUE_TYPE& );

    static bool isPowerOf2(std::size_t alignment);
        // Return 'true' if the specified 'alignment' is a (positive) power of
        // two; otherwise return false.

    // PRIVATE TYPES
    template <class t_ALLOC>
    struct IsDerivedFromBslAllocator
        : bsl::integral_constant<bool,
                                 1 == sizeof(matchBslAlloc((t_ALLOC *) 0, 0))>
    {
        // Metafunction derives from 'true_type' if (template argument)
        // 't_ALLOC' is derived from any specialization of 'bsl::allocator';
        // else derives from 'false_type'.
    };

  public:
    // CLASS METHODS
    template <class t_ALLOC>
    static typename bsl::enable_if<
        ! IsDerivedFromBslAllocator<t_ALLOC>::value,
        t_ALLOC>::type
    adapt(const t_ALLOC& from);
    template <class t_TYPE>
    static bslma::Allocator *adapt(const bsl::allocator<t_TYPE>& from);
        // Return the specified 'from' allocator adapted to a type most likely
        // to be usable for initializing another AA object.  Specifically,
        // return 'from.mechanism()' if 'from' is a specialization of
        // 'bsl::allocator' (or a class derived from 'bsl::allocator');
        // otherwise return 'from' unchanged.

    template <class t_ALLOCATOR>
    static typename AllocatorUtil_Traits<t_ALLOCATOR>::void_pointer
    allocateBytes(const t_ALLOCATOR& allocator,
                  std::size_t      nbytes,
                  std::size_t      alignment = k_MAX_ALIGNMENT);
        // Return a pointer to a block of raw memory allocated from the
        // specified 'allocator' having the specified 'nbytes' size and
        // optionally specified 'alignment'.  If 'alignment' is larger than the
        // largest supported alignment, either the block will be aligned to the
        // maxiumum supported alignment or an exception will be thrown.  The
        // specific choice of behavior is determined by the allocator: for
        // polymorphic allocators the behavior is determined by the memory
        // resource, whereas for non-polymorphic allocators, the alignment is
        // always truncated to the maximum non-extended alignment.

    template <class t_TYPE, class t_ALLOCATOR>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    allocateObject(const t_ALLOCATOR& allocator, std::size_t n = 1);
        // Return a pointer to a block of raw memory allocated from the
        // specified 'allocator' having a size and alignment appropriate for an
        // object of (templatize parameter) 't_TYPE'.  Optionally specify 'n'
        // for the number of objects; otherwise space for a single object is
        // allocated.  Since 't_TYPE' cannot be deduced from the function
        // parameters, it must be supplied explicitly (in '<>' brackets) by the
        // caller.

    template <class t_TYPE>
    static t_TYPE& assign(t_TYPE         *lhs,
                          const t_TYPE&   rhs,
                          bsl::true_type  allowed);
    template <class t_TYPE>
    static t_TYPE& assign(t_TYPE          *lhs,
                          const t_TYPE&    rhs,
                          bsl::false_type  allowed);
        // If the specified 'allowed' tag is 'bsl::true_type' assign the
        // allocator object at the specified 'lhs' address the value of the
        // specified 'rhs'; otherwise, do nothing, and, in both cases, return a
        // modifiable reference to '*lhs'.  The 't_TYPE' template parameter is
        // typically an allocator type and the 'allowed' flag is typically a
        // propagation trait dependant on the calling context, such as
        // 'propagate_on_container_copy_assignment' or
        // 'propagate_on_container_move_assignment'.  Instantiation will fail
        // if 'allowed' is 'true_type' and 't_TYPE' lacks a publically
        // accessible copy assignment operator.  The behavior is undefined
        // unless 'allowed' is 'true_type' or '*lhs == rhs' before the call.

    template <class t_ALLOCATOR>
    static void deallocateBytes(
        const t_ALLOCATOR&                                       allocator,
        typename AllocatorUtil_Traits<t_ALLOCATOR>::void_pointer p,
        std::size_t                                            nbytes,
        std::size_t                                            alignment
                                                            = k_MAX_ALIGNMENT);
        // Return to the specified allocator the block raw memory at the
        // specified 'p' address having the specified 'nbytes' size and
        // optionally specified 'alignment'.  The behavior is undefined unless
        // 'p' refers to a block having the same size and alignment previously
        // allocated from a copy of 'allocator' and not yet deallocated.

    template <class t_ALLOCATOR, class t_POINTER>
    static void deallocateObject(const t_ALLOCATOR& allocator,
                                 t_POINTER          p,
                                 std::size_t      n = 1);
        // Return to the specified 'allocator' a block of raw memory at the
        // specified 'p' address that is suitably sized and aligned to hold an
        // object of (templatize parameter) 't_TYPE'.  Optionally specify 'n'
        // for the number of objects; otherwise a single object is assumed.
        // The behavior is undefined unless 'p' refers to a block with the same
        // type and number of objects previously allocated from a copy of
        // 'allocator' and not yet deallocated.

    template <class t_ALLOCATOR, class t_POINTER>
    static void deleteObject(const t_ALLOCATOR& allocator, t_POINTER p);
        // Destroy the object at the specified 'p' address and return the block
        // of memory at 'p' to the specified 'allocator'.  The behavior is
        // undefined unless 'p' refers to a fully constructed object allocated
        // from a copy of 'allocator' and not yet destroyed or deallocated.

    template <class t_TYPE, class t_ALLOCATOR>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator);
        // Return an object of (template parameter) 't_TYPE' allocated from the
        // specified 'allocator' and constructed with no arguments except that,
        // for scoped allocator types such as 'bsl::allocator' and
        // 'bsl::polymorphic_allocator', 'allocator' may be passed to the
        // 't_TYPE' constructor (i.e., if 't_TYPE' is AA).

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslma_allocatorutil.h
#ifndef BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT
#define BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT 13
#endif
#ifndef BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A
#define BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT
#endif
# ifndef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 0
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 0

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 1
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 1

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 2
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 2

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 3
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 3

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 4
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 4

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 5
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 5

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 6
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 6

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 7
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06,
                                                             class t_ARGS_07>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 7

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 8
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06,
                                                             class t_ARGS_07,
                                                             class t_ARGS_08>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 8

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 9
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06,
                                                             class t_ARGS_07,
                                                             class t_ARGS_08,
                                                             class t_ARGS_09>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 9

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 10
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06,
                                                             class t_ARGS_07,
                                                             class t_ARGS_08,
                                                             class t_ARGS_09,
                                                             class t_ARGS_10>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 10

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 11
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06,
                                                             class t_ARGS_07,
                                                             class t_ARGS_08,
                                                             class t_ARGS_09,
                                                             class t_ARGS_10,
                                                             class t_ARGS_11>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_11) arguments_11);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 11

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 12
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06,
                                                             class t_ARGS_07,
                                                             class t_ARGS_08,
                                                             class t_ARGS_09,
                                                             class t_ARGS_10,
                                                             class t_ARGS_11,
                                                             class t_ARGS_12>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_11) arguments_11,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_12) arguments_12);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 12

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 13
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06,
                                                             class t_ARGS_07,
                                                             class t_ARGS_08,
                                                             class t_ARGS_09,
                                                             class t_ARGS_10,
                                                             class t_ARGS_11,
                                                             class t_ARGS_12,
                                                             class t_ARGS_13>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_11) arguments_11,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_12) arguments_12,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_13) arguments_13);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 13

# endif
#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 0
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 0

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 1
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 1

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 2
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 2

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 3
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 3

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 4
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 4

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 5
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 5

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 6
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 6

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 7
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06,
                                                             class t_ARGS_07>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 7

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 8
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06,
                                                             class t_ARGS_07,
                                                             class t_ARGS_08>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 8

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 9
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06,
                                                             class t_ARGS_07,
                                                             class t_ARGS_08,
                                                             class t_ARGS_09>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 9

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 10
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06,
                                                             class t_ARGS_07,
                                                             class t_ARGS_08,
                                                             class t_ARGS_09,
                                                             class t_ARGS_10>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 10

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 11
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06,
                                                             class t_ARGS_07,
                                                             class t_ARGS_08,
                                                             class t_ARGS_09,
                                                             class t_ARGS_10,
                                                             class t_ARGS_11>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_11) arguments_11);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 11

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 12
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06,
                                                             class t_ARGS_07,
                                                             class t_ARGS_08,
                                                             class t_ARGS_09,
                                                             class t_ARGS_10,
                                                             class t_ARGS_11,
                                                             class t_ARGS_12>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_11) arguments_11,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_12) arguments_12);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 12

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 13
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                             class t_ARGS_02,
                                                             class t_ARGS_03,
                                                             class t_ARGS_04,
                                                             class t_ARGS_05,
                                                             class t_ARGS_06,
                                                             class t_ARGS_07,
                                                             class t_ARGS_08,
                                                             class t_ARGS_09,
                                                             class t_ARGS_10,
                                                             class t_ARGS_11,
                                                             class t_ARGS_12,
                                                             class t_ARGS_13>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_11) arguments_11,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_12) arguments_12,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_13) arguments_13);
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_A >= 13

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
# ifndef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class... t_ARGS>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR& allocator,
              t_ARG1&            argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS)... arguments);
# endif
    template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class... t_ARGS>
    static typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
    newObject(const t_ALLOCATOR&                        allocator,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
              BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS)... arguments);
// }}} END GENERATED CODE
#endif

    template <class t_TYPE>
    static void swap(t_TYPE *pa, t_TYPE *pb, bsl::false_type allowed);
    template <class t_TYPE>
    static void swap(t_TYPE *pa, t_TYPE *pb, bsl::true_type  allowed);
        // If the specified 'allowed' tag is 'bsl::true_type', swap the values
        // of allocators at the specified 'pa' and 'pb' addresses using ADL
        // swap (with 'std::swap' in scope); otherwise, do nothing.  The
        // 't_TYPE' template parameter is typically an allocator type and the
        // 'allowed' flag is typically a propagation trait dependant on the
        // calling context, such as 'propagate_on_container_swap'.
        // Instantiation will fail if 'allowed' is 'false_type' and 't_TYPE' is
        // not swappable (i.e., because it lacks a publically available
        // assignment operator).  The behavior is undefined unless 'allowed' is
        // 'true_type' or '*pa ==
        // *pb' before the call.
};

// ============================================================================
//                TEMPLATE AND INLINE FUNCTION IMPLEMENTATIONS
// ============================================================================

                    // --------------------------
                    // class AllocatorUtil_Traits
                    // --------------------------

template <class t_ALLOCATOR, class t_TYPE>
struct AllocatorUtil_Traits
    : bsl::allocator_traits<t_ALLOCATOR>::template rebind_traits<t_TYPE> {
    // Extend the notion of 'allocator_traits' to apply to both standard
    // allocator and to pointer-to-memory-resource types.  If the (template
    // parameter) 't_ALLOCATOR' is a non-pointer type (i.e., an allocator
    // class), then inherits from
    // 'bsl::allocator_traits<t_ALLOCATOR>::rebind_traits<t_TYPE>'.  However,
    // if 't_ALLOCATOR' is a pointer type, then inherits from
    // 'bsl::allocator_traits<bsl::allocator<t_TYPE>>' for pointers to classes
    // derived from 'bslma::Allocator' and from
    // 'bsl::allocator_traits<bsl::polymorphic_allocator<t_TYPE>>' for pointers
    // to other classes derived from 'bsl::memory_resource'.  This primary
    // template is for non-pointer 't_ALLOCATOR' template arguments.

    BSLMF_ASSERT(! bsl::is_const<t_TYPE>::value);
    BSLMF_ASSERT(! bsl::is_volatile<t_TYPE>::value);
};

template <class t_MEMORY_RSRC, class t_TYPE>
struct AllocatorUtil_Traits<t_MEMORY_RSRC *, t_TYPE> : bsl::allocator_traits<
    typename bsl::conditional<
            bsl::is_convertible<t_MEMORY_RSRC *, bslma::Allocator *>::value,
            bsl::allocator<t_TYPE>,
            bsl::polymorphic_allocator<t_TYPE> >::type
    >
{
    // This specialization is for allocators expressed as a pointer to class
    // derived from 'bsl::memory_resource'.  The base class will be
    // 'bsl::allocator_traits<bsl::allocator<t_TYPE>>' if 't_MEMORY_RSRC' is
    // derived from 'bsl::Allocator'; otherwise the base class will be
    // 'bsl::allocator_traits<bsl::polymorphic_allocator<t_TYPE>>'.

    // MANDATES
    BSLMF_ASSERT((bsl::is_convertible<t_MEMORY_RSRC *,
                                      bsl::memory_resource *>::value));
    BSLMF_ASSERT(! bsl::is_const<t_TYPE>::value);
    BSLMF_ASSERT(! bsl::is_volatile<t_TYPE>::value);
};

                        // -------------------
                        // class AllocatorUtil
                        // -------------------

// PRIVATE CLASS METHODS
template <class t_TYPE>
inline
void *AllocatorUtil::allocateBytesImp(
                       const bsl::polymorphic_allocator<t_TYPE>& allocator,
                       std::size_t                             nbytes,
                       std::size_t                             alignment)
{
    return allocator.resource()->allocate(nbytes, alignment);
}

template <class t_TYPE>
inline
void *AllocatorUtil::allocateBytesImp(const bsl::allocator<t_TYPE>& allocator,
                                      std::size_t                 nbytes,
                                      std::size_t                 alignment)
{
    return allocator.resource()->allocate(nbytes, alignment);
}

template <class t_ALLOCATOR>
typename AllocatorUtil_Traits<t_ALLOCATOR>::void_pointer
AllocatorUtil::allocateBytesImp(const t_ALLOCATOR& allocator,
                                std::size_t      nbytes,
                                std::size_t      alignment)
{
    BSLMF_ASSERT(4 <= k_MAX_ALIGNMENT && k_MAX_ALIGNMENT <= 32);

    static const int k_8  = k_MAX_ALIGNMENT <  8 ? k_MAX_ALIGNMENT :  8;
    static const int k_16 = k_MAX_ALIGNMENT < 16 ? k_MAX_ALIGNMENT : 16;

    typedef typename bsls::AlignmentToType<  1>::Type             AlignType1;
    typedef typename bsls::AlignmentToType<  2>::Type             AlignType2;
    typedef typename bsls::AlignmentToType<  4>::Type             AlignType4;
    typedef typename bsls::AlignmentToType<k_8>::Type             AlignType8;
    typedef typename bsls::AlignmentToType<k_16>::Type            AlignType16;
    typedef typename bsls::AlignmentToType<k_MAX_ALIGNMENT>::Type AlignTypeMax;

    if (alignment > k_MAX_ALIGNMENT) {
        alignment = k_MAX_ALIGNMENT;
    }

    std::size_t n = (nbytes + alignment - 1) / alignment;

    switch (alignment) {
      case  1: return allocateObject<AlignType1  >(allocator, n);
      case  2: return allocateObject<AlignType2  >(allocator, n);
      case  4: return allocateObject<AlignType4  >(allocator, n);
      case  8: return allocateObject<AlignType8  >(allocator, n);
      case 16: return allocateObject<AlignType16 >(allocator, n);
      default: return allocateObject<AlignTypeMax>(allocator, n);
    }
}

template <class t_TYPE>
inline
void AllocatorUtil::deallocateBytesImp(
                          const bsl::polymorphic_allocator<t_TYPE>&  allocator,
                          void                                    *p,
                          std::size_t                              nbytes,
                          std::size_t                              alignment)
{
    return allocator.resource()->deallocate(p, nbytes, alignment);
}

template <class t_TYPE>
inline
void AllocatorUtil::deallocateBytesImp(
                                      const bsl::allocator<t_TYPE>&  allocator,
                                      void                          *p,
                                      std::size_t                    nbytes,
                                      std::size_t                    alignment)
{
    return allocator.resource()->deallocate(p, nbytes, alignment);
}

template <class t_ALLOCATOR>
void AllocatorUtil::deallocateBytesImp(
    const t_ALLOCATOR&                                       allocator,
    typename AllocatorUtil_Traits<t_ALLOCATOR>::void_pointer p,
    std::size_t                                            nbytes,
    std::size_t                                            alignment)
{
    BSLMF_ASSERT(4 <= k_MAX_ALIGNMENT && k_MAX_ALIGNMENT <= 32);

    static const int k_8  = k_MAX_ALIGNMENT <  8 ? k_MAX_ALIGNMENT :  8;
    static const int k_16 = k_MAX_ALIGNMENT < 16 ? k_MAX_ALIGNMENT : 16;

    typedef typename bsls::AlignmentToType<  1>::Type             AlignType1;
    typedef typename bsls::AlignmentToType<  2>::Type             AlignType2;
    typedef typename bsls::AlignmentToType<  4>::Type             AlignType4;
    typedef typename bsls::AlignmentToType<k_8>::Type             AlignType8;
    typedef typename bsls::AlignmentToType<k_16>::Type            AlignType16;
    typedef typename bsls::AlignmentToType<k_MAX_ALIGNMENT>::Type AlignTypeMax;

    typedef typename AllocatorUtil_Traits<t_ALLOCATOR,
                                          AlignType1  >::pointer Ptr1;
    typedef typename AllocatorUtil_Traits<t_ALLOCATOR,
                                          AlignType2  >::pointer Ptr2;
    typedef typename AllocatorUtil_Traits<t_ALLOCATOR,
                                          AlignType4  >::pointer Ptr4;
    typedef typename AllocatorUtil_Traits<t_ALLOCATOR,
                                          AlignType8  >::pointer Ptr8;
    typedef typename AllocatorUtil_Traits<t_ALLOCATOR,
                                          AlignType16 >::pointer Ptr16;
    typedef typename AllocatorUtil_Traits<t_ALLOCATOR,
                                          AlignTypeMax>::pointer PtrMax;

    if (alignment > k_MAX_ALIGNMENT) {
        alignment = k_MAX_ALIGNMENT;
    }

    std::size_t n = (nbytes + alignment - 1) / alignment;

    switch (alignment) {
      case  1: deallocateObject(allocator, static_cast<Ptr1  >(p), n); break;
      case  2: deallocateObject(allocator, static_cast<Ptr2  >(p), n); break;
      case  4: deallocateObject(allocator, static_cast<Ptr4  >(p), n); break;
      case  8: deallocateObject(allocator, static_cast<Ptr8  >(p), n); break;
      case 16: deallocateObject(allocator, static_cast<Ptr16 >(p), n); break;
      default: deallocateObject(allocator, static_cast<PtrMax>(p), n); break;
    }
}

template <class t_ALLOCATOR, class t_POINTER, class t_VALUE_TYPE>
inline
void AllocatorUtil::deallocateObjectImp(const t_ALLOCATOR&  allocator,
                                        t_POINTER           p,
                                        std::size_t       n,
                                        const t_VALUE_TYPE& )
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_VALUE_TYPE> Traits;

    BSLMF_ASSERT((bsl::is_same<t_POINTER, typename Traits::pointer>::value));

    typename Traits::allocator_type reboundAlloc(allocator);
    reboundAlloc.deallocate(p, n);
}

template <class t_ALLOCATOR, class t_POINTER, class t_VALUE_TYPE>
inline
void AllocatorUtil::deleteObjectImp(const t_ALLOCATOR&  allocator,
                                    t_POINTER           p,
                                    const t_VALUE_TYPE& )
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_VALUE_TYPE> Traits;

    BSLMF_ASSERT((bsl::is_same<t_POINTER, typename Traits::pointer>::value));

    typename Traits::allocator_type reboundAlloc(allocator);
    Traits::destroy(reboundAlloc, BSLS_UTIL_ADDRESSOF(*p));
    reboundAlloc.deallocate(p, 1);
}

inline
bool AllocatorUtil::isPowerOf2(std::size_t alignment)
{
    return (0 < alignment) && (0 == (alignment & (alignment - 1)));
}


// CLASS METHODS
template <class t_ALLOC>
inline
typename bsl::enable_if<
        ! AllocatorUtil::IsDerivedFromBslAllocator<t_ALLOC>::value,
        t_ALLOC>::type
AllocatorUtil::adapt(const t_ALLOC& from)
{
    return from;
}

template <class t_TYPE>
inline
bslma::Allocator *AllocatorUtil::adapt(const bsl::allocator<t_TYPE>& from)
{
    return from.mechanism();
}

template <class t_ALLOCATOR>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR>::void_pointer
AllocatorUtil::allocateBytes(const t_ALLOCATOR& allocator,
                             std::size_t      nbytes,
                             std::size_t      alignment)
{
    BSLS_ASSERT(isPowerOf2(alignment));

    typedef
        typename AllocatorUtil_Traits<t_ALLOCATOR>::allocator_type StdAlloc;
    return allocateBytesImp(StdAlloc(allocator), nbytes, alignment);
}

template <class t_TYPE, class t_ALLOCATOR>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::allocateObject(const t_ALLOCATOR& allocator, std::size_t n)
{
    typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::allocator_type
        reboundAlloc(allocator);
    return reboundAlloc.allocate(n);
}

template <class t_TYPE>
inline
t_TYPE& AllocatorUtil::assign(t_TYPE *lhs, const t_TYPE& rhs, bsl::false_type)
{
    BSLS_ASSERT(*lhs == rhs);
    (void)rhs;
    return *lhs;
}

template <class t_TYPE>
inline
t_TYPE& AllocatorUtil::assign(t_TYPE *lhs, const t_TYPE& rhs, bsl::true_type)
{
    *lhs = rhs;
    return *lhs;
}

template <class t_ALLOCATOR>
inline
void AllocatorUtil::deallocateBytes(
    const t_ALLOCATOR&                                       allocator,
    typename AllocatorUtil_Traits<t_ALLOCATOR>::void_pointer p,
    std::size_t                                            nbytes,
    std::size_t                                            alignment)
{
    BSLS_ASSERT(isPowerOf2(alignment));

    typedef
        typename AllocatorUtil_Traits<t_ALLOCATOR>::allocator_type StdAlloc;
    deallocateBytesImp(StdAlloc(allocator), p, nbytes, alignment);
}

template <class t_ALLOCATOR, class t_POINTER>
inline
void AllocatorUtil::deallocateObject(const t_ALLOCATOR& allocator,
                                     t_POINTER          p,
                                     std::size_t      n)
{
    BSLS_ASSERT(t_POINTER() != p);
    deallocateObjectImp(allocator, p, n, *p);
}

template <class t_ALLOCATOR, class t_POINTER>
inline void
AllocatorUtil::deleteObject(const t_ALLOCATOR& allocator, t_POINTER p)
{
    BSLS_ASSERT(t_POINTER() != p);
    deleteObjectImp(allocator, p, *p);
}

template <class t_TYPE, class t_ALLOCATOR>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    // Use a 'try' block because the proctor components are at a higher
    // dependency level than this component.  As there is only one possibly
    // throwing statement, correctness of the 'try' block is easily verified.
    BSLS_TRY {
        Traits::construct(reboundAlloc, BSLS_UTIL_ADDRESSOF(*p));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslma_allocatorutil.h
#ifndef BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT
#define BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT 13
#endif
#ifndef BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B
#define BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT
#endif
# ifndef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 0
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1);
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 0

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 1
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1,
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 1

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 2
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1,
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 2

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 3
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1,
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 3

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 4
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1,
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 4

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 5
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1,
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 5

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 6
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1,
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 6

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 7
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06,
                                                         class t_ARGS_07>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1,
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_07, arguments_07));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 7

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 8
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06,
                                                         class t_ARGS_07,
                                                         class t_ARGS_08>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1,
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_08, arguments_08));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 8

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 9
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06,
                                                         class t_ARGS_07,
                                                         class t_ARGS_08,
                                                         class t_ARGS_09>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1,
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_08, arguments_08),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_09, arguments_09));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 9

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 10
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06,
                                                         class t_ARGS_07,
                                                         class t_ARGS_08,
                                                         class t_ARGS_09,
                                                         class t_ARGS_10>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1,
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_08, arguments_08),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_09, arguments_09),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_10, arguments_10));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 10

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 11
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06,
                                                         class t_ARGS_07,
                                                         class t_ARGS_08,
                                                         class t_ARGS_09,
                                                         class t_ARGS_10,
                                                         class t_ARGS_11>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_11) arguments_11)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1,
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_08, arguments_08),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_09, arguments_09),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_10, arguments_10),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_11, arguments_11));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 11

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 12
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06,
                                                         class t_ARGS_07,
                                                         class t_ARGS_08,
                                                         class t_ARGS_09,
                                                         class t_ARGS_10,
                                                         class t_ARGS_11,
                                                         class t_ARGS_12>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_11) arguments_11,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_12) arguments_12)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1,
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_08, arguments_08),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_09, arguments_09),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_10, arguments_10),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_11, arguments_11),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_12, arguments_12));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 12

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 13
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06,
                                                         class t_ARGS_07,
                                                         class t_ARGS_08,
                                                         class t_ARGS_09,
                                                         class t_ARGS_10,
                                                         class t_ARGS_11,
                                                         class t_ARGS_12,
                                                         class t_ARGS_13>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_11) arguments_11,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_12) arguments_12,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_13) arguments_13)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1,
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_08, arguments_08),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_09, arguments_09),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_10, arguments_10),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_11, arguments_11),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_12, arguments_12),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_13, arguments_13));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 13

# endif

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 0
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 0

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 1
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 1

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 2
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 2

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 3
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 3

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 4
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 4

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 5
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 5

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 6
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 6

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 7
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06,
                                                         class t_ARGS_07>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_07, arguments_07));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 7

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 8
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06,
                                                         class t_ARGS_07,
                                                         class t_ARGS_08>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_08, arguments_08));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 8

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 9
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06,
                                                         class t_ARGS_07,
                                                         class t_ARGS_08,
                                                         class t_ARGS_09>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_08, arguments_08),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_09, arguments_09));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 9

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 10
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06,
                                                         class t_ARGS_07,
                                                         class t_ARGS_08,
                                                         class t_ARGS_09,
                                                         class t_ARGS_10>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_08, arguments_08),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_09, arguments_09),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_10, arguments_10));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 10

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 11
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06,
                                                         class t_ARGS_07,
                                                         class t_ARGS_08,
                                                         class t_ARGS_09,
                                                         class t_ARGS_10,
                                                         class t_ARGS_11>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_11) arguments_11)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_08, arguments_08),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_09, arguments_09),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_10, arguments_10),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_11, arguments_11));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 11

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 12
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06,
                                                         class t_ARGS_07,
                                                         class t_ARGS_08,
                                                         class t_ARGS_09,
                                                         class t_ARGS_10,
                                                         class t_ARGS_11,
                                                         class t_ARGS_12>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_11) arguments_11,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_12) arguments_12)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_08, arguments_08),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_09, arguments_09),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_10, arguments_10),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_11, arguments_11),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_12, arguments_12));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 12

#if BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 13
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class t_ARGS_01,
                                                         class t_ARGS_02,
                                                         class t_ARGS_03,
                                                         class t_ARGS_04,
                                                         class t_ARGS_05,
                                                         class t_ARGS_06,
                                                         class t_ARGS_07,
                                                         class t_ARGS_08,
                                                         class t_ARGS_09,
                                                         class t_ARGS_10,
                                                         class t_ARGS_11,
                                                         class t_ARGS_12,
                                                         class t_ARGS_13>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_01) arguments_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_02) arguments_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_03) arguments_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_04) arguments_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_05) arguments_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_06) arguments_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_07) arguments_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_08) arguments_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_09) arguments_09,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_10) arguments_10,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_11) arguments_11,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_12) arguments_12,
                     BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS_13) arguments_13)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_01, arguments_01),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_02, arguments_02),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_03, arguments_03),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_04, arguments_04),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_05, arguments_05),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_06, arguments_06),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_07, arguments_07),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_08, arguments_08),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_09, arguments_09),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_10, arguments_10),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_11, arguments_11),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_12, arguments_12),
                       BSLS_COMPILERFEATURES_FORWARD(t_ARGS_13, arguments_13));
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
#endif  // BSLMA_ALLOCATORUTIL_VARIADIC_LIMIT_B >= 13

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
# ifndef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class... t_ARGS>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR& allocator,
                         t_ARG1&            argument1,
                        BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS)... arguments)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          argument1,
                          BSLS_COMPILERFEATURES_FORWARD(t_ARGS, arguments)...);
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
# endif

template <class t_TYPE, class t_ALLOCATOR, class t_ARG1, class... t_ARGS>
inline
typename AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE>::pointer
AllocatorUtil::newObject(const t_ALLOCATOR&                        allocator,
                         BSLS_COMPILERFEATURES_FORWARD_REF(t_ARG1) argument1,
                        BSLS_COMPILERFEATURES_FORWARD_REF(t_ARGS)... arguments)
{
    typedef AllocatorUtil_Traits<t_ALLOCATOR, t_TYPE> Traits;

    typename Traits::allocator_type reboundAlloc(allocator);
    typename Traits::pointer        p = reboundAlloc.allocate(1);
    BSLS_TRY {
        Traits::construct(reboundAlloc,
                          BSLS_UTIL_ADDRESSOF(*p),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARG1, argument1),
                          BSLS_COMPILERFEATURES_FORWARD(t_ARGS, arguments)...);
    }
    BSLS_CATCH(...) {
        reboundAlloc.deallocate(p, 1);
        BSLS_RETHROW;
    }
    return p;
}
// }}} END GENERATED CODE
#endif

template <class t_TYPE>
inline
void AllocatorUtil::swap(t_TYPE *pa, t_TYPE *pb, bsl::false_type)
{
    BSLS_ASSERT(*pa == *pb);
    (void)pa; (void)pb;
}

template <class t_TYPE>
inline
void AllocatorUtil::swap(t_TYPE *pa, t_TYPE *pb, bsl::true_type)
{
    using std::swap;
    swap(*pa, *pb);
}

}  // close package namespace
}  // close enterprise namespace

#else // if ! defined(DEFINED_BSLMA_ALLOCATORUTIL_H)
# error Not valid except when included from bslma_allocatorutil.h
#endif // ! defined(COMPILING_BSLMA_ALLOCATORUTIL_H)

#endif // ! defined(INCLUDED_BSLMA_ALLOCATORUTIL_CPP03)

// ----------------------------------------------------------------------------
// Copyright 2023 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
