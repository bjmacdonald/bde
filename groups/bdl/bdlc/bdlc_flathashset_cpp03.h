// bdlc_flathashset_cpp03.h                                           -*-C++-*-

// Automatically generated file.  **DO NOT EDIT**

#ifndef INCLUDED_BDLC_FLATHASHSET_CPP03
#define INCLUDED_BDLC_FLATHASHSET_CPP03

//@PURPOSE: Provide C++03 implementation for bdlc_flathashset.h
//
//@CLASSES: See bdlc_flathashset.h for list of classes
//
//@SEE_ALSO: bdlc_flathashset
//
//@DESCRIPTION:  This component is the C++03 translation of a C++11 component,
// generated by the 'sim_cpp11_features.pl' program.  If the original header
// contains any specially delimited regions of C++11 code, then this generated
// file contains the C++03 equivalent, i.e., with variadic templates expanded
// and rvalue-references replaced by 'bslmf::MovableRef' objects.  The header
// code in this file is designed to be '#include'd into the original header
// when compiling with a C++03 compiler.  If there are no specially delimited
// regions of C++11 code, then this header contains no code and is not
// '#include'd in the original header.
//
// Generated on Thu Feb 15 08:55:18 2024
// Command line: sim_cpp11_features.pl bdlc_flathashset.h

#ifdef COMPILING_BDLC_FLATHASHSET_H

namespace BloombergLP {
namespace bdlc {

// FORWARD DECLARATIONS
template <class KEY,
          class HASH  = bslh::FibonacciBadHashWrapper<bsl::hash<KEY> >,
          class EQUAL = bsl::equal_to<KEY> >
class FlatHashSet;

template <class KEY, class HASH, class EQUAL>
bool operator==(const FlatHashSet<KEY, HASH, EQUAL> &a,
                const FlatHashSet<KEY, HASH, EQUAL> &b);

template <class KEY, class HASH, class EQUAL>
bool operator!=(const FlatHashSet<KEY, HASH, EQUAL> &a,
                const FlatHashSet<KEY, HASH, EQUAL> &b);

template <class KEY, class HASH, class EQUAL>
void swap(FlatHashSet<KEY, HASH, EQUAL>& a, FlatHashSet<KEY, HASH, EQUAL>& b);

                       // ============================
                       // struct FlatHashSet_EntryUtil
                       // ============================

template <class ENTRY>
struct FlatHashSet_EntryUtil
    // This templated utility provides methods to construct an 'ENTRY' and a
    // method to extract the key from an 'ENTRY' (which is, identically, the
    // 'ENTRY').
{
    // CLASS METHODS
#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bdlc_flathashset.h
#ifndef BDLC_FLATHASHSET_VARIADIC_LIMIT
#define BDLC_FLATHASHSET_VARIADIC_LIMIT 10
#endif
#ifndef BDLC_FLATHASHSET_VARIADIC_LIMIT_A
#define BDLC_FLATHASHSET_VARIADIC_LIMIT_A BDLC_FLATHASHSET_VARIADIC_LIMIT
#endif
#if BDLC_FLATHASHSET_VARIADIC_LIMIT_A >= 0
    static void construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_A >= 0

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_A >= 1
    template <class ARGS_01>
    static void construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_A >= 1

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_A >= 2
    template <class ARGS_01,
              class ARGS_02>
    static void construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_A >= 2

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_A >= 3
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03>
    static void construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_A >= 3

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_A >= 4
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04>
    static void construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_A >= 4

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_A >= 5
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05>
    static void construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_A >= 5

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_A >= 6
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06>
    static void construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_A >= 6

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_A >= 7
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07>
    static void construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_A >= 7

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_A >= 8
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08>
    static void construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_A >= 8

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_A >= 9
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09>
    static void construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_A >= 9

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_A >= 10
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class ARGS_10>
    static void construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_A >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
    template <class... ARGS>
    static void construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args);
// }}} END GENERATED CODE
#endif

    template <class KEY_TYPE>
    static void constructFromKey(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(KEY_TYPE)  key);
        // Load into the specified 'entry' the 'ENTRY' value comprised of the
        // specified 'key', using the specified 'allocator' to supply memory.
        // 'allocator' is ignored if the (template parameter) type 'ENTRY' is
        // not allocator aware.

    static const ENTRY& key(const ENTRY& entry);
        // Return the specified 'entry'.
};

                            // =================
                            // class FlatHashSet
                            // =================

template <class KEY, class HASH, class EQUAL>
class FlatHashSet {
    // This class template implements a value-semantic container type holding
    // an unordered set of unique values of (template parameter) type 'KEY'.
    // The (template parameter) type 'HASH' is a functor providing the hash
    // value for 'KEY'.  The (template parameter) type 'EQUAL' is a functor
    // providing the equality function for two 'KEY' values.  See {Requirements
    // on 'KEY', 'HASH', and 'EQUAL'} for more information.

  private:
    // PRIVATE TYPES
    typedef FlatHashTable<KEY,
                          KEY,
                          FlatHashSet_EntryUtil<KEY>,
                          HASH,
                          EQUAL> ImplType;
        // This is the underlying implementation class.

    // FRIENDS
    friend bool operator==<>(const FlatHashSet&, const FlatHashSet&);
    friend bool operator!=<>(const FlatHashSet&, const FlatHashSet&);

    // The following verbose declaration is required by the xlC 12.1 compiler.
    template <class K, class H, class E>
    friend void swap(FlatHashSet<K, H, E>&, FlatHashSet<K, H, E>&);

  public:
    // PUBLIC TYPES
    typedef KEY                                key_type;
    typedef KEY                                value_type;
    typedef bsl::size_t                        size_type;
    typedef bsl::ptrdiff_t                     difference_type;
    typedef EQUAL                              key_compare;
    typedef EQUAL                              value_compare;
    typedef HASH                               hasher;
    typedef value_type&                        reference;
    typedef const value_type&                  const_reference;
    typedef value_type*                        pointer;
    typedef const value_type*                  const_pointer;
    typedef typename ImplType::const_iterator  iterator;
    typedef typename ImplType::const_iterator  const_iterator;

  private:
    // DATA
    ImplType d_impl;  // underlying flat hash table used by this flat hash set

  public:
    // CREATORS
    FlatHashSet();
    explicit FlatHashSet(bslma::Allocator *basicAllocator);
    explicit FlatHashSet(bsl::size_t capacity);
    FlatHashSet(bsl::size_t capacity, bslma::Allocator *basicAllocator);
    FlatHashSet(bsl::size_t       capacity,
                const HASH&       hash,
                bslma::Allocator *basicAllocator = 0);
    FlatHashSet(bsl::size_t       capacity,
                const HASH&       hash,
                const EQUAL&      equal,
                bslma::Allocator *basicAllocator = 0);
        // Create an empty 'FlatHashSet' object.  Optionally specify a
        // 'capacity' indicating the minimum initial size of the underlying
        // array of entries of this container.  If 'capacity' is not supplied
        // or is 0, no memory is allocated.  Optionally specify a 'hash'
        // functor used to generate the hash values associated with the
        // elements in this container.  If 'hash' is not supplied, a
        // default-constructed object of the (template parameter) type 'HASH'
        // is used.  Optionally specify an equality functor 'equal' used to
        // determine whether two elements are equivalent.  If 'equal' is not
        // supplied, a default-constructed object of the (template parameter)
        // type 'EQUAL' is used.  Optionally specify a 'basicAllocator' used to
        // supply memory.  If 'basicAllocator' is not supplied or is 0, the
        // currently installed default allocator is used.

    template <class INPUT_ITERATOR>
    FlatHashSet(INPUT_ITERATOR    first,
                INPUT_ITERATOR    last,
                bslma::Allocator *basicAllocator = 0);
    template <class INPUT_ITERATOR>
    FlatHashSet(INPUT_ITERATOR    first,
                INPUT_ITERATOR    last,
                bsl::size_t       capacity,
                bslma::Allocator *basicAllocator = 0);
    template <class INPUT_ITERATOR>
    FlatHashSet(INPUT_ITERATOR    first,
                INPUT_ITERATOR    last,
                bsl::size_t       capacity,
                const HASH&       hash,
                bslma::Allocator *basicAllocator = 0);
    template <class INPUT_ITERATOR>
    FlatHashSet(INPUT_ITERATOR    first,
                INPUT_ITERATOR    last,
                bsl::size_t       capacity,
                const HASH&       hash,
                const EQUAL&      equal,
                bslma::Allocator *basicAllocator = 0);
        // Create a 'FlatHashSet' object initialized by insertion of the values
        // from the input iterator range specified by 'first' through 'last'
        // (including 'first', excluding 'last').  Optionally specify a
        // 'capacity' indicating the minimum initial size of the underlying
        // array of entries of this container.  If 'capacity' is not supplied
        // or is 0, no memory is allocated.  Optionally specify a 'hash'
        // functor used to generate hash values associated with the elements in
        // this container.  If 'hash' is not supplied, a default-constructed
        // object of the (template parameter) type 'HASH' is used.  Optionally
        // specify an equality functor 'equal' used to verify that two elements
        // are equivalent.  If 'equal' is not supplied, a default-constructed
        // object of the (template parameter) type 'EQUAL' is used.  Optionally
        // specify a 'basicAllocator' used to supply memory.  If
        // 'basicAllocator' is not supplied or is 0, the currently installed
        // default allocator is used.  The behavior is undefined unless 'first'
        // and 'last' refer to a sequence of valid values where 'first' is at a
        // position at or before 'last'.  Note that if a member of the input
        // sequence is equivalent to an earlier member, the later member will
        // not be inserted.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS)
    FlatHashSet(bsl::initializer_list<KEY>  values,
                bslma::Allocator           *basicAllocator = 0);
    FlatHashSet(bsl::initializer_list<KEY>  values,
                bsl::size_t                 capacity,
                bslma::Allocator           *basicAllocator = 0);
    FlatHashSet(bsl::initializer_list<KEY>  values,
                bsl::size_t                 capacity,
                const HASH&                 hash,
                bslma::Allocator           *basicAllocator = 0);
    FlatHashSet(bsl::initializer_list<KEY>  values,
                bsl::size_t                 capacity,
                const HASH&                 hash,
                const EQUAL&                equal,
                bslma::Allocator           *basicAllocator = 0);
        // Create a 'FlatHashSet' object initialized by insertion of the
        // specified 'values'.  Optionally specify a 'capacity' indicating the
        // minimum initial size of the underlying array of entries of this
        // container.  If 'capacity' is not supplied or is 0, no memory is
        // allocated.  Optionally specify a 'hash' functor used to generate
        // hash values associated with the elements in this container.  If
        // 'hash' is not supplied, a default-constructed object of the
        // (template parameter) type 'HASH' is used.  Optionally specify an
        // equality functor 'equal' used to verify that two elements are
        // equivalent.  If 'equal' is not supplied, a default-constructed
        // object of the (template parameter) type 'EQUAL' is used.  Optionally
        // specify a 'basicAllocator' used to supply memory.  If
        // 'basicAllocator' is not supplied or is 0, the currently installed
        // default allocator is used.  Note that if a member of 'values' has a
        // key equivalent to an earlier member, the later member will not be
        // inserted.
#endif

    FlatHashSet(const FlatHashSet&  original,
                bslma::Allocator   *basicAllocator = 0);
        // Create a 'FlatHashSet' object having the same value, hasher, and
        // equality comparator as the specified 'original' object.  Optionally
        // specify a 'basicAllocator' used to supply memory.  If
        // 'basicAllocator' is not specified or is 0, the currently installed
        // default allocator is used.

    FlatHashSet(bslmf::MovableRef<FlatHashSet> original);
        // Create a 'FlatHashSet' object having the same value, hasher,
        // equality comparator, and allocator as the specified 'original'
        // object.  The contents of 'original' are moved (in constant time) to
        // this object, 'original' is left in a (valid) unspecified state, and
        // no exceptions will be thrown.

    FlatHashSet(bslmf::MovableRef<FlatHashSet>  original,
                bslma::Allocator               *basicAllocator);
        // Create a 'FlatHashSet' object having the same value, hasher, and
        // equality comparator as the specified 'original' object, using the
        // specified 'basicAllocator' to supply memory.  If 'basicAllocator' is
        // 0, the currently installed default allocator is used.  The allocator
        // of 'original' remains unchanged.  If 'original' and the newly
        // created object have the same allocator then the contents of
        // 'original' are moved (in constant time) to this object, 'original'
        // is left in a (valid) unspecified state, and no exceptions will be
        // thrown; otherwise 'original' is unchanged (and an exception may be
        // thrown).

    ~FlatHashSet();
        // Destroy this object and each of its elements.

    // MANIPULATORS
    FlatHashSet& operator=(const FlatHashSet& rhs);
        // Assign to this object the value, hasher, and equality functor of the
        // specified 'rhs' object, and return a reference providing modifiable
        // access to this object.

    FlatHashSet& operator=(bslmf::MovableRef<FlatHashSet> rhs);
        // Assign to this object the value, hasher, and equality comparator of
        // the specified 'rhs' object, and return a reference providing
        // modifiable access to this object.  If this object and 'rhs' use the
        // same allocator the contents of 'rhs' are moved (in constant time) to
        // this object.  'rhs' is left in a (valid) unspecified state.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS)
    FlatHashSet& operator=(bsl::initializer_list<KEY> values);
        // Assign to this object the value resulting from first clearing this
        // set and then inserting each object in the specified 'values'
        // initializer list, ignoring those objects having a value equivalent
        // to that which appears earlier in the list; return a reference
        // providing modifiable access to this object.  This method requires
        // that the (template parameter) type 'KEY' be 'copy-insertable' into
        // this set (see {Requirements on 'KEY', 'HASH', and 'EQUAL'}).
#endif

    void clear();
        // Remove all elements from this set.  Note that this set will be empty
        // after calling this method, but allocated memory may be retained for
        // future use.  See the 'capacity' method.

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bdlc_flathashset.h
#ifndef BDLC_FLATHASHSET_VARIADIC_LIMIT
#define BDLC_FLATHASHSET_VARIADIC_LIMIT 10
#endif
#ifndef BDLC_FLATHASHSET_VARIADIC_LIMIT_B
#define BDLC_FLATHASHSET_VARIADIC_LIMIT_B BDLC_FLATHASHSET_VARIADIC_LIMIT
#endif
#if BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 0
    bsl::pair<iterator, bool> emplace(
                              );
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 0

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 1
    template <class ARGS_01>
    bsl::pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 1

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 2
    template <class ARGS_01,
              class ARGS_02>
    bsl::pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 2

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 3
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03>
    bsl::pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 3

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 4
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04>
    bsl::pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 4

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 5
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05>
    bsl::pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 5

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 6
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06>
    bsl::pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 6

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 7
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07>
    bsl::pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 7

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 8
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08>
    bsl::pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 8

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 9
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09>
    bsl::pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 9

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 10
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class ARGS_10>
    bsl::pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 10


#if BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 0
    iterator emplace_hint(const_iterator hint);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 0

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 1
    template <class ARGS_01>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 1

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 2
    template <class ARGS_01,
              class ARGS_02>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 2

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 3
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 3

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 4
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 4

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 5
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 5

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 6
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 6

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 7
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 7

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 8
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 8

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 9
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 9

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 10
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class ARGS_10>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10);
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_B >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
    template <class... ARGS>
    bsl::pair<iterator, bool> emplace(
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args);

    template <class... ARGS>
    iterator emplace_hint(const_iterator hint,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args);

// }}} END GENERATED CODE
#endif

    bsl::size_t erase(const KEY& key);
        // Remove from this set the element whose key is equal to the specified
        // 'key', if it exists, and return 1; otherwise (there is no element
        // having 'key' in this set), return 0 with no other effect.  This
        // method invalidates all iterators and references to the removed
        // element.

    const_iterator erase(const_iterator position);
        // Remove from this set the element at the specified 'position', and
        // return a 'const_iterator' referring to the element immediately
        // following the removed element, or to the past-the-end position if
        // the removed element was the last element in the sequence of elements
        // maintained by this set.  This method invalidates all iterators and
        // references to the removed element.  The behavior is undefined unless
        // 'position' refers to an element in this set.

    const_iterator erase(const_iterator first, const_iterator last);
        // Remove from this set the elements starting at the specified 'first'
        // position up to, but not including, the specified 'last' position,
        // and return 'last'.  This method invalidates all iterators and
        // references to the removed elements.  The behavior is undefined
        // unless 'first' and 'last' are valid iterators on this set, and the
        // 'first' position is at or before the 'last' position in the
        // iteration sequence provided by this container.

#if defined(BSLS_PLATFORM_CMP_SUN) && BSLS_PLATFORM_CMP_VERSION < 0x5130
    template <class KEY_TYPE>
    bsl::pair<const_iterator, bool> insert(
                             BSLS_COMPILERFEATURES_FORWARD_REF(KEY_TYPE) value)
#else
    template <class KEY_TYPE>
    typename bsl::enable_if<bsl::is_convertible<KEY_TYPE, KEY>::value,
                            bsl::pair<const_iterator, bool> >::type
                      insert(BSLS_COMPILERFEATURES_FORWARD_REF(KEY_TYPE) value)
#endif
        // Insert the specified 'value' into this set if the 'value' does not
        // already exist in this set; otherwise, this method has no effect.
        // Return a 'pair' whose 'first' member is a 'const_iterator' referring
        // to the (possibly newly inserted) element in this set whose value is
        // equivalent to that of the element to be inserted, and whose 'second'
        // member is 'true' if a new element was inserted, and 'false' if an
        // equivalent value was already present.
    {
        // Note that some compilers require functions declared with 'enable_if'
        // to be defined inline.

        return d_impl.insert(BSLS_COMPILERFEATURES_FORWARD(KEY_TYPE, value));
    }

#if defined(BSLS_PLATFORM_CMP_SUN) && BSLS_PLATFORM_CMP_VERSION < 0x5130
    template <class KEY_TYPE>
    const_iterator insert(const_iterator                              ,
                          BSLS_COMPILERFEATURES_FORWARD_REF(KEY_TYPE) value)
#else
    template <class KEY_TYPE>
    typename bsl::enable_if<bsl::is_convertible<KEY_TYPE, KEY>::value,
                            const_iterator>::type
                      insert(const_iterator                              ,
                             BSLS_COMPILERFEATURES_FORWARD_REF(KEY_TYPE) value)
#endif
        // Insert the specified 'value' into this set if the 'value' does not
        // already exist in this set; otherwise, this method has no effect.
        // Return a 'const_iterator' referring to the (possibly newly inserted)
        // element in this set whose value is equivalent to that of the
        // element to be inserted.  The supplied 'const_iterator' is ignored.
    {
        // Note that some compilers require functions declared with 'enable_if'
        // to be defined inline.

        return d_impl.insert(BSLS_COMPILERFEATURES_FORWARD(KEY_TYPE,
                                                           value)).first;
    }

    template <class INPUT_ITERATOR>
    void insert(INPUT_ITERATOR first, INPUT_ITERATOR last);
        // Insert into this set the value of each element in the input iterator
        // range specified by 'first' through 'last' (including 'first',
        // excluding 'last').  The behavior is undefined unless 'first' and
        // 'last' refer to a sequence of valid values where 'first' is at a
        // position at or before 'last'.  Note that if a member of the input
        // sequence is equivalent to an earlier member, the later member will
        // not be inserted.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS)
    void insert(bsl::initializer_list<KEY> values);
        // Insert into this set an element having the value of each object in
        // the specified 'values' initializer list if an equivalent value is
        // not already contained in this set.  This method requires that the
        // (template parameter) type 'KEY' be copy-insertable (see
        // {Requirements on 'KEY', 'HASH', and 'EQUAL'}).
#endif

    void rehash(bsl::size_t minimumCapacity);
        // Change the capacity of this set to at least the specified
        // 'minimumCapacity', and redistribute all the contained elements into
        // a new sequence of entries according to their hash values.  If
        // '0 == minimumCapacity' and '0 == size()', the set is returned to the
        // default constructed state.  After this call, 'load_factor()' will be
        // less than or equal to 'max_load_factor()' and all iterators,
        // pointers, and references to elements of this set are invalidated.

    void reserve(bsl::size_t numEntries);
        // Change the capacity of this set to at least a capacity that can
        // accommodate the specified 'numEntries' (accounting for the load
        // factor invariant), and redistribute all the contained elements into
        // a new sequence of entries according to their hash values.  If
        // '0 == numEntries' and '0 == size()', the set is returned to the
        // default constructed state.  After this call, 'load_factor()' will be
        // less than or equal to 'max_load_factor()' and all iterators,
        // pointers, and references to elements of this set are invalidated.
        // Note that this method is effectively equivalent to:
        //..
        //     rehash(bsl::ceil(numEntries / max_load_factor()))
        //..

    void reset();
        // Remove all elements from this set and release all memory from this
        // set, returning the set to the default constructed state.

                             // Aspects

    void swap(FlatHashSet& other);
        // Exchange the value of this object as well as its hasher and equality
        // functors with those of the specified 'other' object.  The behavior
        // is undefined unless this object was created with the same allocator
        // as 'other'.

    // ACCESSORS
    bsl::size_t capacity() const;
        // Return the number of elements this set could hold if the load factor
        // were 1.

    bool contains(const KEY& key) const;
        // Return 'true' if this set contains an element having the specified
        // 'key', and 'false' otherwise.

    bsl::size_t count(const KEY& key) const;
        // Return the number of elements in this set having the specified
        // 'key'.  Note that since a flat hash set maintains unique keys, the
        // returned value will be either 0 or 1.

    bool empty() const;
        // Return 'true' if this set contains no elements, and 'false'
        // otherwise.

    bsl::pair<const_iterator, const_iterator> equal_range(
                                                         const KEY& key) const;
        // Return a pair of 'const_iterator's defining the sequence of elements
        // in this set having the specified 'key', where the first iterator is
        // positioned at the start of the sequence and the second iterator is
        // positioned one past the end of the sequence.  If this set contains
        // no 'KEY' elements equivalent to 'key', then the two returned
        // iterators will have the same value.  Note that since a set maintains
        // unique keys, the range will contain at most one element.

    const_iterator find(const KEY& key) const;
        // Return a 'const_iterator' referring to the element in this set
        // having the specified 'key', or 'end()' if no such entry exists in
        // this set.

    HASH hash_function() const;
        // Return (a copy of) the unary hash functor used by this set to
        // generate a hash value (of type 'bsl::size_t') for a 'KEY' object.

    EQUAL key_eq() const;
        // Return (a copy of) the binary key-equality functor that returns
        // 'true' if the value of two 'KEY' objects are equivalent, and 'false'
        // otherwise.

    float load_factor() const;
        // Return the current ratio between the number of elements in this
        // container and its capacity.

    float max_load_factor() const;
        // Return the maximum load factor allowed for this set.  Note that if
        // an insert operation would cause the load factor to exceed
        // 'max_load_factor()', that same insert operation will increase the
        // capacity and rehash the entries of the container (see {Load Factor
        // and Resizing}).  Also note that the value returned by
        // 'max_load_factor' is implementation defined and cannot be changed by
        // the user.

    bsl::size_t size() const;
        // Return the number of elements in this set.

                          // Iterators

    const_iterator begin() const;
        // Return a 'const_iterator' to the first element in the sequence of
        // elements maintained by this set, or the 'end' iterator if this set
        // is empty.

    const_iterator cbegin() const;
        // Return a 'const_iterator' to the first element in the sequence of
        // elements maintained by this set, or the 'end' iterator if this set
        // is empty.

    const_iterator cend() const;
        // Return a 'const_iterator' to the past-the-end element in the
        // sequence of 'KEY' elements maintained by this set.

    const_iterator end() const;
        // Return a 'const_iterator' to the past-the-end element in the
        // sequence of 'KEY' elements maintained by this set.

                           // Aspects

    bslma::Allocator *allocator() const;
        // Return the allocator used by this flat hash set to supply memory.

    bsl::ostream& print(bsl::ostream& stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output 'stream' at the (absolute
        // value of) the optionally specified indentation 'level', and return a
        // reference to the modifiable 'stream'.  If 'level' is specified,
        // optionally specify 'spacesPerLevel', the number of spaces per
        // indentation level for this and all of its nested objects.  If
        // 'level' is negative, suppress indentation of the first line.  If
        // 'spacesPerLevel' is negative, format the entire output on one line,
        // suppressing all but the initial indentation (as governed by
        // 'level').  If 'stream' is not valid on entry, this operation has no
        // effect.
};

// FREE OPERATORS
template <class KEY, class HASH, class EQUAL>
bool operator==(const FlatHashSet<KEY, HASH, EQUAL> &lhs,
                const FlatHashSet<KEY, HASH, EQUAL> &rhs);
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'FlatHashSet' objects have the same
    // value if their sizes are the same and each element contained in one is
    // equal to an element of the other.  The hash and equality functors are
    // not involved in the comparison.

template <class KEY, class HASH, class EQUAL>
bool operator!=(const FlatHashSet<KEY, HASH, EQUAL> &lhs,
                const FlatHashSet<KEY, HASH, EQUAL> &rhs);
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have the
    // same value, and 'false' otherwise.  Two 'FlatHashSet' objects do not
    // have the same value if their sizes are different or one contains an
    // element equal to no element of the other.  The hash and equality
    // functors are not involved in the comparison.

template <class KEY, class HASH, class EQUAL>
bsl::ostream& operator<<(bsl::ostream&                        stream,
                         const FlatHashSet<KEY, HASH, EQUAL>& set);
    // Write the value of the specified 'set' to the specified output 'stream'
    // in a single-line format, and return a reference providing modifiable
    // access to 'stream'.  If 'stream' is not valid on entry, this operation
    // has no effect.  Note that this human-readable format is not fully
    // specified and can change without notice.

// FREE FUNCTIONS
template <class KEY, class HASH, class EQUAL>
void swap(FlatHashSet<KEY, HASH, EQUAL>& a, FlatHashSet<KEY, HASH, EQUAL>& b);
    // Exchange the value, the hasher, and the key-equality functor of the
    // specified 'a' and 'b' objects.  This function provides the no-throw
    // exception-safety guarantee if the two objects were created with the same
    // allocator and the basic guarantee otherwise.

// ============================================================================
//                  TEMPLATE AND INLINE FUNCTION DEFINITIONS
// ============================================================================

                       // ----------------------------
                       // struct FlatHashSet_EntryUtil
                       // ----------------------------

// CLASS METHODS
#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bdlc_flathashset.h
#ifndef BDLC_FLATHASHSET_VARIADIC_LIMIT
#define BDLC_FLATHASHSET_VARIADIC_LIMIT 10
#endif
#ifndef BDLC_FLATHASHSET_VARIADIC_LIMIT_C
#define BDLC_FLATHASHSET_VARIADIC_LIMIT_C BDLC_FLATHASHSET_VARIADIC_LIMIT
#endif
#if BDLC_FLATHASHSET_VARIADIC_LIMIT_C >= 0
template <class ENTRY>
inline
void FlatHashSet_EntryUtil<ENTRY>::construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator)
{
    BSLS_ASSERT_SAFE(entry);
    bslma::ConstructionUtil::construct(
                                 entry,
                                 allocator);
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_C >= 0

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_C >= 1
template <class ENTRY>
template <class ARGS_01>
inline
void FlatHashSet_EntryUtil<ENTRY>::construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01)
{
    BSLS_ASSERT_SAFE(entry);
    bslma::ConstructionUtil::construct(
                                 entry,
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01));
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_C >= 1

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_C >= 2
template <class ENTRY>
template <class ARGS_01,
          class ARGS_02>
inline
void FlatHashSet_EntryUtil<ENTRY>::construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02)
{
    BSLS_ASSERT_SAFE(entry);
    bslma::ConstructionUtil::construct(
                                 entry,
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02));
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_C >= 2

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_C >= 3
template <class ENTRY>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03>
inline
void FlatHashSet_EntryUtil<ENTRY>::construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03)
{
    BSLS_ASSERT_SAFE(entry);
    bslma::ConstructionUtil::construct(
                                 entry,
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03));
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_C >= 3

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_C >= 4
template <class ENTRY>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04>
inline
void FlatHashSet_EntryUtil<ENTRY>::construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04)
{
    BSLS_ASSERT_SAFE(entry);
    bslma::ConstructionUtil::construct(
                                 entry,
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04));
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_C >= 4

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_C >= 5
template <class ENTRY>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05>
inline
void FlatHashSet_EntryUtil<ENTRY>::construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05)
{
    BSLS_ASSERT_SAFE(entry);
    bslma::ConstructionUtil::construct(
                                 entry,
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05));
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_C >= 5

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_C >= 6
template <class ENTRY>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06>
inline
void FlatHashSet_EntryUtil<ENTRY>::construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06)
{
    BSLS_ASSERT_SAFE(entry);
    bslma::ConstructionUtil::construct(
                                 entry,
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06));
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_C >= 6

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_C >= 7
template <class ENTRY>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07>
inline
void FlatHashSet_EntryUtil<ENTRY>::construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07)
{
    BSLS_ASSERT_SAFE(entry);
    bslma::ConstructionUtil::construct(
                                 entry,
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07));
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_C >= 7

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_C >= 8
template <class ENTRY>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08>
inline
void FlatHashSet_EntryUtil<ENTRY>::construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08)
{
    BSLS_ASSERT_SAFE(entry);
    bslma::ConstructionUtil::construct(
                                 entry,
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08));
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_C >= 8

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_C >= 9
template <class ENTRY>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08,
          class ARGS_09>
inline
void FlatHashSet_EntryUtil<ENTRY>::construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09)
{
    BSLS_ASSERT_SAFE(entry);
    bslma::ConstructionUtil::construct(
                                 entry,
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09));
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_C >= 9

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_C >= 10
template <class ENTRY>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08,
          class ARGS_09,
          class ARGS_10>
inline
void FlatHashSet_EntryUtil<ENTRY>::construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10)
{
    BSLS_ASSERT_SAFE(entry);
    bslma::ConstructionUtil::construct(
                                 entry,
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_10, args_10));
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_C >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class ENTRY>
template <class... ARGS>
inline
void FlatHashSet_EntryUtil<ENTRY>::construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args)
{
    BSLS_ASSERT_SAFE(entry);
    bslma::ConstructionUtil::construct(
                                 entry,
                                 allocator,
                                 BSLS_COMPILERFEATURES_FORWARD(ARGS, args)...);
}
// }}} END GENERATED CODE
#endif

template <class ENTRY>
template <class KEY>
inline
void FlatHashSet_EntryUtil<ENTRY>::constructFromKey(
                             ENTRY                                  *entry,
                             bslma::Allocator                       *allocator,
                             BSLS_COMPILERFEATURES_FORWARD_REF(KEY)  key)
{
    BSLS_ASSERT_SAFE(entry);

    bslma::ConstructionUtil::construct(
                                 entry,
                                 allocator,
                                 BSLS_COMPILERFEATURES_FORWARD(KEY, key));
}

template <class ENTRY>
inline
const ENTRY& FlatHashSet_EntryUtil<ENTRY>::key(const ENTRY& entry)
{
    return entry;
}

                            // -----------------
                            // class FlatHashSet
                            // -----------------

// CREATORS
template <class KEY, class HASH, class EQUAL>
inline
FlatHashSet<KEY, HASH, EQUAL>::FlatHashSet()
: d_impl(0, HASH(), EQUAL())
{
}

template <class KEY, class HASH, class EQUAL>
inline
FlatHashSet<KEY, HASH, EQUAL>::FlatHashSet(bslma::Allocator *basicAllocator)
: d_impl(0, HASH(), EQUAL(), basicAllocator)
{
}

template <class KEY, class HASH, class EQUAL>
inline
FlatHashSet<KEY, HASH, EQUAL>::FlatHashSet(bsl::size_t capacity)
: d_impl(capacity, HASH(), EQUAL())
{
}

template <class KEY, class HASH, class EQUAL>
inline
FlatHashSet<KEY, HASH, EQUAL>::FlatHashSet(bsl::size_t       capacity,
                                           bslma::Allocator *basicAllocator)
: d_impl(capacity, HASH(), EQUAL(), basicAllocator)
{
}

template <class KEY, class HASH, class EQUAL>
inline
FlatHashSet<KEY, HASH, EQUAL>::FlatHashSet(bsl::size_t       capacity,
                                           const HASH&       hash,
                                           bslma::Allocator *basicAllocator)
: d_impl(capacity, hash, EQUAL(), basicAllocator)
{
}

template <class KEY, class HASH, class EQUAL>
inline
FlatHashSet<KEY, HASH, EQUAL>::FlatHashSet(bsl::size_t       capacity,
                                           const HASH&       hash,
                                           const EQUAL&      equal,
                                           bslma::Allocator *basicAllocator)
: d_impl(capacity, hash, equal, basicAllocator)
{
}

template <class KEY, class HASH, class EQUAL>
template <class INPUT_ITERATOR>
inline
FlatHashSet<KEY, HASH, EQUAL>::FlatHashSet(INPUT_ITERATOR    first,
                                           INPUT_ITERATOR    last,
                                           bslma::Allocator *basicAllocator)
: d_impl(0, HASH(), EQUAL(), basicAllocator)
{
    insert(first, last);
}

template <class KEY, class HASH, class EQUAL>
template <class INPUT_ITERATOR>
inline
FlatHashSet<KEY, HASH, EQUAL>::FlatHashSet(INPUT_ITERATOR    first,
                                           INPUT_ITERATOR    last,
                                           bsl::size_t       capacity,
                                           bslma::Allocator *basicAllocator)
: d_impl(capacity, HASH(), EQUAL(), basicAllocator)
{
    insert(first, last);
}

template <class KEY, class HASH, class EQUAL>
template <class INPUT_ITERATOR>
inline
FlatHashSet<KEY, HASH, EQUAL>::FlatHashSet(INPUT_ITERATOR    first,
                                           INPUT_ITERATOR    last,
                                           bsl::size_t       capacity,
                                           const HASH&       hash,
                                           bslma::Allocator *basicAllocator)
: d_impl(capacity, hash, EQUAL(), basicAllocator)
{
    insert(first, last);
}

template <class KEY, class HASH, class EQUAL>
template <class INPUT_ITERATOR>
inline
FlatHashSet<KEY, HASH, EQUAL>::FlatHashSet(INPUT_ITERATOR    first,
                                           INPUT_ITERATOR    last,
                                           bsl::size_t       capacity,
                                           const HASH&       hash,
                                           const EQUAL&      equal,
                                           bslma::Allocator *basicAllocator)
: d_impl(capacity, hash, equal, basicAllocator)
{
    insert(first, last);
}

#if defined(BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS)
template <class KEY, class HASH, class EQUAL>
inline
FlatHashSet<KEY, HASH, EQUAL>::FlatHashSet(
                                    bsl::initializer_list<KEY>  values,
                                    bslma::Allocator           *basicAllocator)
: FlatHashSet(values.begin(),
              values.end(),
              0,
              HASH(),
              EQUAL(),
              basicAllocator)
{
}

template <class KEY, class HASH, class EQUAL>
inline
FlatHashSet<KEY, HASH, EQUAL>::FlatHashSet(
                                    bsl::initializer_list<KEY>  values,
                                    bsl::size_t                 capacity,
                                    bslma::Allocator           *basicAllocator)
: FlatHashSet(values.begin(),
              values.end(),
              capacity,
              HASH(),
              EQUAL(),
              basicAllocator)
{
}

template <class KEY, class HASH, class EQUAL>
inline
FlatHashSet<KEY, HASH, EQUAL>::FlatHashSet(
                                    bsl::initializer_list<KEY>  values,
                                    bsl::size_t                 capacity,
                                    const HASH&                 hash,
                                    bslma::Allocator           *basicAllocator)
: FlatHashSet(values.begin(),
              values.end(),
              capacity,
              hash,
              EQUAL(),
              basicAllocator)
{
}

template <class KEY, class HASH, class EQUAL>
inline
FlatHashSet<KEY, HASH, EQUAL>::FlatHashSet(
                                    bsl::initializer_list<KEY>  values,
                                    bsl::size_t                 capacity,
                                    const HASH&                 hash,
                                    const EQUAL&                equal,
                                    bslma::Allocator           *basicAllocator)
: FlatHashSet(values.begin(),
              values.end(),
              capacity,
              hash,
              equal,
              basicAllocator)
{
}
#endif

template <class KEY, class HASH, class EQUAL>
inline
FlatHashSet<KEY, HASH, EQUAL>::FlatHashSet(const FlatHashSet&  original,
                                           bslma::Allocator   *basicAllocator)
: d_impl(original.d_impl, basicAllocator)
{
}

template <class KEY, class HASH, class EQUAL>
inline
FlatHashSet<KEY, HASH, EQUAL>::FlatHashSet(
                                       bslmf::MovableRef<FlatHashSet> original)
: d_impl(bslmf::MovableRefUtil::move(
                               bslmf::MovableRefUtil::access(original).d_impl))
{
}

template <class KEY, class HASH, class EQUAL>
inline
FlatHashSet<KEY, HASH, EQUAL>::FlatHashSet(
                                bslmf::MovableRef<FlatHashSet>  original,
                                bslma::Allocator               *basicAllocator)
: d_impl(bslmf::MovableRefUtil::move(
                               bslmf::MovableRefUtil::access(original).d_impl),
         basicAllocator)
{
}

template <class KEY, class HASH, class EQUAL>
inline
FlatHashSet<KEY, HASH, EQUAL>::~FlatHashSet()
{
}

// MANIPULATORS
template <class KEY, class HASH, class EQUAL>
inline
FlatHashSet<KEY, HASH, EQUAL>& FlatHashSet<KEY, HASH, EQUAL>::operator=(
                                                        const FlatHashSet& rhs)
{
    d_impl = rhs.d_impl;

    return *this;
}

template <class KEY, class HASH, class EQUAL>
inline
FlatHashSet<KEY, HASH, EQUAL>& FlatHashSet<KEY, HASH, EQUAL>::operator=(
                                            bslmf::MovableRef<FlatHashSet> rhs)
{
    FlatHashSet& lvalue = rhs;

    d_impl = bslmf::MovableRefUtil::move(lvalue.d_impl);

    return *this;
}

#if defined(BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS)
template <class KEY, class HASH, class EQUAL>
inline
FlatHashSet<KEY, HASH, EQUAL>& FlatHashSet<KEY, HASH, EQUAL>::operator=(
                                             bsl::initializer_list<KEY> values)
{
    FlatHashSet tmp(values.begin(),
                    values.end(),
                    0,
                    d_impl.hash_function(),
                    d_impl.key_eq(),
                    d_impl.allocator());

    this->swap(tmp);

    return *this;
}
#endif

template <class KEY, class HASH, class EQUAL>
inline
void FlatHashSet<KEY, HASH, EQUAL>::clear()
{
    d_impl.clear();
}

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bdlc_flathashset.h
#ifndef BDLC_FLATHASHSET_VARIADIC_LIMIT
#define BDLC_FLATHASHSET_VARIADIC_LIMIT 10
#endif
#ifndef BDLC_FLATHASHSET_VARIADIC_LIMIT_D
#define BDLC_FLATHASHSET_VARIADIC_LIMIT_D BDLC_FLATHASHSET_VARIADIC_LIMIT
#endif
#if BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 0
template <class KEY, class HASH, class EQUAL>
inline bsl::pair<typename FlatHashSet<KEY, HASH, EQUAL>::iterator, bool>
FlatHashSet<KEY, HASH, EQUAL>::emplace(
                               )
{
    return d_impl.emplace();
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 0

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 1
template <class KEY, class HASH, class EQUAL>
template <class ARGS_01>
inline bsl::pair<typename FlatHashSet<KEY, HASH, EQUAL>::iterator, bool>
FlatHashSet<KEY, HASH, EQUAL>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01)
{
    return d_impl.emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01));
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 1

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 2
template <class KEY, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02>
inline bsl::pair<typename FlatHashSet<KEY, HASH, EQUAL>::iterator, bool>
FlatHashSet<KEY, HASH, EQUAL>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02)
{
    return d_impl.emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02));
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 2

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 3
template <class KEY, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03>
inline bsl::pair<typename FlatHashSet<KEY, HASH, EQUAL>::iterator, bool>
FlatHashSet<KEY, HASH, EQUAL>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03)
{
    return d_impl.emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03));
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 3

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 4
template <class KEY, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04>
inline bsl::pair<typename FlatHashSet<KEY, HASH, EQUAL>::iterator, bool>
FlatHashSet<KEY, HASH, EQUAL>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04)
{
    return d_impl.emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04));
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 4

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 5
template <class KEY, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05>
inline bsl::pair<typename FlatHashSet<KEY, HASH, EQUAL>::iterator, bool>
FlatHashSet<KEY, HASH, EQUAL>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05)
{
    return d_impl.emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05));
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 5

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 6
template <class KEY, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06>
inline bsl::pair<typename FlatHashSet<KEY, HASH, EQUAL>::iterator, bool>
FlatHashSet<KEY, HASH, EQUAL>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06)
{
    return d_impl.emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06));
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 6

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 7
template <class KEY, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07>
inline bsl::pair<typename FlatHashSet<KEY, HASH, EQUAL>::iterator, bool>
FlatHashSet<KEY, HASH, EQUAL>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07)
{
    return d_impl.emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07));
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 7

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 8
template <class KEY, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08>
inline bsl::pair<typename FlatHashSet<KEY, HASH, EQUAL>::iterator, bool>
FlatHashSet<KEY, HASH, EQUAL>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08)
{
    return d_impl.emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08));
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 8

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 9
template <class KEY, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08,
          class ARGS_09>
inline bsl::pair<typename FlatHashSet<KEY, HASH, EQUAL>::iterator, bool>
FlatHashSet<KEY, HASH, EQUAL>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09)
{
    return d_impl.emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09));
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 9

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 10
template <class KEY, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08,
          class ARGS_09,
          class ARGS_10>
inline bsl::pair<typename FlatHashSet<KEY, HASH, EQUAL>::iterator, bool>
FlatHashSet<KEY, HASH, EQUAL>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10)
{
    return d_impl.emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_10, args_10));
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 10


#if BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 0
template <class KEY, class HASH, class EQUAL>
inline typename FlatHashSet<KEY, HASH, EQUAL>::iterator
FlatHashSet<KEY, HASH, EQUAL>::emplace_hint(
                  typename FlatHashSet<KEY, HASH, EQUAL>::const_iterator)
{
    return this->emplace().first;
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 0

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 1
template <class KEY, class HASH, class EQUAL>
template <class ARGS_01>
inline typename FlatHashSet<KEY, HASH, EQUAL>::iterator
FlatHashSet<KEY, HASH, EQUAL>::emplace_hint(
                  typename FlatHashSet<KEY, HASH, EQUAL>::const_iterator,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01)
{
    return this->emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01)
                         ).first;
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 1

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 2
template <class KEY, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02>
inline typename FlatHashSet<KEY, HASH, EQUAL>::iterator
FlatHashSet<KEY, HASH, EQUAL>::emplace_hint(
                  typename FlatHashSet<KEY, HASH, EQUAL>::const_iterator,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02)
{
    return this->emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02)
                         ).first;
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 2

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 3
template <class KEY, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03>
inline typename FlatHashSet<KEY, HASH, EQUAL>::iterator
FlatHashSet<KEY, HASH, EQUAL>::emplace_hint(
                  typename FlatHashSet<KEY, HASH, EQUAL>::const_iterator,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03)
{
    return this->emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03)
                         ).first;
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 3

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 4
template <class KEY, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04>
inline typename FlatHashSet<KEY, HASH, EQUAL>::iterator
FlatHashSet<KEY, HASH, EQUAL>::emplace_hint(
                  typename FlatHashSet<KEY, HASH, EQUAL>::const_iterator,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04)
{
    return this->emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04)
                         ).first;
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 4

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 5
template <class KEY, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05>
inline typename FlatHashSet<KEY, HASH, EQUAL>::iterator
FlatHashSet<KEY, HASH, EQUAL>::emplace_hint(
                  typename FlatHashSet<KEY, HASH, EQUAL>::const_iterator,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05)
{
    return this->emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05)
                         ).first;
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 5

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 6
template <class KEY, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06>
inline typename FlatHashSet<KEY, HASH, EQUAL>::iterator
FlatHashSet<KEY, HASH, EQUAL>::emplace_hint(
                  typename FlatHashSet<KEY, HASH, EQUAL>::const_iterator,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06)
{
    return this->emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06)
                         ).first;
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 6

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 7
template <class KEY, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07>
inline typename FlatHashSet<KEY, HASH, EQUAL>::iterator
FlatHashSet<KEY, HASH, EQUAL>::emplace_hint(
                  typename FlatHashSet<KEY, HASH, EQUAL>::const_iterator,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07)
{
    return this->emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07)
                         ).first;
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 7

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 8
template <class KEY, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08>
inline typename FlatHashSet<KEY, HASH, EQUAL>::iterator
FlatHashSet<KEY, HASH, EQUAL>::emplace_hint(
                  typename FlatHashSet<KEY, HASH, EQUAL>::const_iterator,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08)
{
    return this->emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08)
                         ).first;
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 8

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 9
template <class KEY, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08,
          class ARGS_09>
inline typename FlatHashSet<KEY, HASH, EQUAL>::iterator
FlatHashSet<KEY, HASH, EQUAL>::emplace_hint(
                  typename FlatHashSet<KEY, HASH, EQUAL>::const_iterator,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09)
{
    return this->emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09)
                         ).first;
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 9

#if BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 10
template <class KEY, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08,
          class ARGS_09,
          class ARGS_10>
inline typename FlatHashSet<KEY, HASH, EQUAL>::iterator
FlatHashSet<KEY, HASH, EQUAL>::emplace_hint(
                  typename FlatHashSet<KEY, HASH, EQUAL>::const_iterator,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10)
{
    return this->emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09),
                         BSLS_COMPILERFEATURES_FORWARD(ARGS_10, args_10)
                         ).first;
}
#endif  // BDLC_FLATHASHSET_VARIADIC_LIMIT_D >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class KEY, class HASH, class EQUAL>
template <class... ARGS>
inline bsl::pair<typename FlatHashSet<KEY, HASH, EQUAL>::iterator, bool>
FlatHashSet<KEY, HASH, EQUAL>::emplace(
                               BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args)
{
    return d_impl.emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS, args)...);
}

template <class KEY, class HASH, class EQUAL>
template <class... ARGS>
inline typename FlatHashSet<KEY, HASH, EQUAL>::iterator
FlatHashSet<KEY, HASH, EQUAL>::emplace_hint(
                  typename FlatHashSet<KEY, HASH, EQUAL>::const_iterator,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args)
{
    return this->emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS, args)...).first;
}

// }}} END GENERATED CODE
#endif


template <class KEY, class HASH, class EQUAL>
inline
bsl::size_t FlatHashSet<KEY, HASH, EQUAL>::erase(const KEY& key)
{
    return d_impl.erase(key);
}

template <class KEY, class HASH, class EQUAL>
inline
typename FlatHashSet<KEY, HASH, EQUAL>::const_iterator
                  FlatHashSet<KEY, HASH, EQUAL>::erase(const_iterator position)
{
    BSLS_ASSERT_SAFE(position != end());

    return d_impl.erase(position);
}

template <class KEY, class HASH, class EQUAL>
inline
typename FlatHashSet<KEY, HASH, EQUAL>::const_iterator
FlatHashSet<KEY, HASH, EQUAL>::erase(const_iterator first, const_iterator last)
{
    return d_impl.erase(first, last);
}

template <class KEY, class HASH, class EQUAL>
template <class INPUT_ITERATOR>
inline
void FlatHashSet<KEY, HASH, EQUAL>::insert(INPUT_ITERATOR first,
                                           INPUT_ITERATOR last)
{
    d_impl.insert(first, last);
}

#if defined(BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS)
template <class KEY, class HASH, class EQUAL>
inline
void FlatHashSet<KEY, HASH, EQUAL>::insert(bsl::initializer_list<KEY> values)
{
    insert(values.begin(), values.end());
}
#endif

template <class KEY, class HASH, class EQUAL>
inline
void FlatHashSet<KEY, HASH, EQUAL>::rehash(bsl::size_t minimumCapacity)
{
    d_impl.rehash(minimumCapacity);
}

template <class KEY, class HASH, class EQUAL>
inline
void FlatHashSet<KEY, HASH, EQUAL>::reserve(bsl::size_t numEntries)
{
    d_impl.reserve(numEntries);
}

template <class KEY, class HASH, class EQUAL>
inline
void FlatHashSet<KEY, HASH, EQUAL>::reset()
{
    d_impl.reset();
}

                             // Aspects

template <class KEY, class HASH, class EQUAL>
inline
void FlatHashSet<KEY, HASH, EQUAL>::swap(FlatHashSet& other)
{
    BSLS_ASSERT_SAFE(allocator() == other.allocator());

    d_impl.swap(other.d_impl);
}

// ACCESSORS
template <class KEY, class HASH, class EQUAL>
inline
bsl::size_t FlatHashSet<KEY, HASH, EQUAL>::capacity() const
{
    return d_impl.capacity();
}

template <class KEY, class HASH, class EQUAL>
inline
bool FlatHashSet<KEY, HASH, EQUAL>::contains(const KEY& key) const
{
    return d_impl.contains(key);
}

template <class KEY, class HASH, class EQUAL>
inline
bsl::size_t FlatHashSet<KEY, HASH, EQUAL>::count(const KEY& key) const
{
    return d_impl.count(key);
}

template <class KEY, class HASH, class EQUAL>
inline
bool FlatHashSet<KEY, HASH, EQUAL>::empty() const
{
    return d_impl.empty();
}

template <class KEY, class HASH, class EQUAL>
inline
bsl::pair<typename FlatHashSet<KEY, HASH, EQUAL>::const_iterator,
          typename FlatHashSet<KEY, HASH, EQUAL>::const_iterator>
               FlatHashSet<KEY, HASH, EQUAL>::equal_range(const KEY& key) const
{
    return d_impl.equal_range(key);
}

template <class KEY, class HASH, class EQUAL>
inline
typename FlatHashSet<KEY, HASH, EQUAL>::const_iterator
                      FlatHashSet<KEY, HASH, EQUAL>::find(const KEY& key) const
{
    return d_impl.find(key);
}

template <class KEY, class HASH, class EQUAL>
inline
HASH FlatHashSet<KEY, HASH, EQUAL>::hash_function() const
{
    return d_impl.hash_function();
}

template <class KEY, class HASH, class EQUAL>
inline
EQUAL FlatHashSet<KEY, HASH, EQUAL>::key_eq() const
{
    return d_impl.key_eq();
}

template <class KEY, class HASH, class EQUAL>
inline
float FlatHashSet<KEY, HASH, EQUAL>::load_factor() const
{
    return d_impl.load_factor();
}

template <class KEY, class HASH, class EQUAL>
inline
float FlatHashSet<KEY, HASH, EQUAL>::max_load_factor() const
{
    return d_impl.max_load_factor();
}

template <class KEY, class HASH, class EQUAL>
inline
bsl::size_t FlatHashSet<KEY, HASH, EQUAL>::size() const
{
    return d_impl.size();
}

                          // Iterators

template <class KEY, class HASH, class EQUAL>
inline
typename FlatHashSet<KEY, HASH, EQUAL>::const_iterator
                                   FlatHashSet<KEY, HASH, EQUAL>::begin() const
{
    return d_impl.begin();
}

template <class KEY, class HASH, class EQUAL>
inline
typename FlatHashSet<KEY, HASH, EQUAL>::const_iterator
                                 FlatHashSet<KEY, HASH, EQUAL>::cbegin() const
{
    return d_impl.cbegin();
}

template <class KEY, class HASH, class EQUAL>
inline
typename FlatHashSet<KEY, HASH, EQUAL>::const_iterator
                                   FlatHashSet<KEY, HASH, EQUAL>::cend() const
{
    return d_impl.cend();
}

template <class KEY, class HASH, class EQUAL>
inline
typename FlatHashSet<KEY, HASH, EQUAL>::const_iterator
                                     FlatHashSet<KEY, HASH, EQUAL>::end() const
{
    return d_impl.end();
}

                             // Aspects

template <class KEY, class HASH, class EQUAL>
inline
bslma::Allocator *FlatHashSet<KEY, HASH, EQUAL>::allocator() const
{
    return d_impl.allocator();
}

template <class KEY, class HASH, class EQUAL>
bsl::ostream& FlatHashSet<KEY, HASH, EQUAL>::print(
                                            bsl::ostream& stream,
                                            int           level,
                                            int           spacesPerLevel) const
{
    if (stream.bad()) {
        return stream;                                                // RETURN
    }

    bslim::Printer printer(&stream, level, spacesPerLevel);

    printer.start();

    const_iterator iter = begin();
    while (iter != end()) {
        printer.printValue(*iter);
        ++iter;
    }

    printer.end();

    return stream;
}

}  // close package namespace

// FREE OPERATORS
template <class KEY, class HASH, class EQUAL>
inline
bool bdlc::operator==(const FlatHashSet<KEY, HASH, EQUAL>& lhs,
                      const FlatHashSet<KEY, HASH, EQUAL>& rhs)
{
    return lhs.d_impl == rhs.d_impl;
}

template <class KEY, class HASH, class EQUAL>
inline
bool bdlc::operator!=(const FlatHashSet<KEY, HASH, EQUAL>& lhs,
                      const FlatHashSet<KEY, HASH, EQUAL>& rhs)
{
    return lhs.d_impl != rhs.d_impl;
}

template <class KEY, class HASH, class EQUAL>
inline
bsl::ostream& bdlc::operator<<(bsl::ostream&                        stream,
                               const FlatHashSet<KEY, HASH, EQUAL>& set)
{
    return set.print(stream, 0, -1);
}

// FREE FUNCTIONS
template <class KEY, class HASH, class EQUAL>
inline
void bdlc::swap(FlatHashSet<KEY, HASH, EQUAL>& a,
                FlatHashSet<KEY, HASH, EQUAL>& b)
{
    bslalg::SwapUtil::swap(&a.d_impl, &b.d_impl);
}

// ============================================================================
//                                TYPE TRAITS
// ============================================================================

namespace bslalg {

template <class KEY, class HASH, class EQUAL>
struct HasStlIterators<bdlc::FlatHashSet<KEY, HASH, EQUAL> >
     : bsl::true_type
{};

}  // close namespace bslalg

namespace bslma {

template <class KEY, class HASH, class EQUAL>
struct UsesBslmaAllocator<bdlc::FlatHashSet<KEY, HASH, EQUAL> >
     : bsl::true_type
{};

}  // close namespace bslma
}  // close enterprise namespace

#else // if ! defined(DEFINED_BDLC_FLATHASHSET_H)
# error Not valid except when included from bdlc_flathashset.h
#endif // ! defined(COMPILING_BDLC_FLATHASHSET_H)

#endif // ! defined(INCLUDED_BDLC_FLATHASHSET_CPP03)

// ----------------------------------------------------------------------------
// Copyright 2020 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
