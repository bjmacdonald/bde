// bdlc_flathashmap_cpp03.h                                           -*-C++-*-

// Automatically generated file.  **DO NOT EDIT**

#ifndef INCLUDED_BDLC_FLATHASHMAP_CPP03
#define INCLUDED_BDLC_FLATHASHMAP_CPP03

//@PURPOSE: Provide C++03 implementation for bdlc_flathashmap.h
//
//@CLASSES: See bdlc_flathashmap.h for list of classes
//
//@SEE_ALSO: bdlc_flathashmap
//
//@DESCRIPTION:  This component is the C++03 translation of a C++11 component,
// generated by the 'sim_cpp11_features.pl' program.  If the original header
// contains any specially delimited regions of C++11 code, then this generated
// file contains the C++03 equivalent, i.e., with variadic templates expanded
// and rvalue-references replaced by 'bslmf::MovableRef' objects.  The header
// code in this file is designed to be '#include'd into the original header
// when compiling with a C++03 compiler.  If there are no specially delimited
// regions of C++11 code, then this header contains no code and is not
// '#include'd in the original header.
//
// Generated on Tue Feb 20 18:40:11 2024
// Command line: sim_cpp11_features.pl bdlc_flathashmap.h

#ifdef COMPILING_BDLC_FLATHASHMAP_H

#if defined(BSLS_COMPILERFEATURES_SUPPORT_TRAITS_HEADER)
#include <bsl_type_traits.h>

    #ifndef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    #error Rvalue references curiously absent despite native 'type_traits'.
    #endif

#endif

namespace BloombergLP {
namespace bdlc {

// FORWARD DECLARATIONS
template <class KEY,
          class VALUE,
          class HASH  = bslh::FibonacciBadHashWrapper<bsl::hash<KEY> >,
          class EQUAL = bsl::equal_to<KEY> >
class FlatHashMap;

template <class KEY, class VALUE, class HASH, class EQUAL>
bool operator==(const FlatHashMap<KEY, VALUE, HASH, EQUAL> &lhs,
                const FlatHashMap<KEY, VALUE, HASH, EQUAL> &rhs);

template <class KEY, class VALUE, class HASH, class EQUAL>
bool operator!=(const FlatHashMap<KEY, VALUE, HASH, EQUAL> &lhs,
                const FlatHashMap<KEY, VALUE, HASH, EQUAL> &rhs);

template <class KEY, class VALUE, class HASH, class EQUAL>
void swap(FlatHashMap<KEY, VALUE, HASH, EQUAL>& a,
          FlatHashMap<KEY, VALUE, HASH, EQUAL>& b);

                       // ============================
                       // struct FlatHashMap_EntryUtil
                       // ============================

template <class KEY, class VALUE, class ENTRY>
struct FlatHashMap_EntryUtil
    // This templated utility provides methods to construct an 'ENTRY' and a
    // method to extract the key from an 'ENTRY'.
{
    // CLASS METHODS
#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bdlc_flathashmap.h
#ifndef BDLC_FLATHASHMAP_VARIADIC_LIMIT
#define BDLC_FLATHASHMAP_VARIADIC_LIMIT 10
#endif
#ifndef BDLC_FLATHASHMAP_VARIADIC_LIMIT_A
#define BDLC_FLATHASHMAP_VARIADIC_LIMIT_A BDLC_FLATHASHMAP_VARIADIC_LIMIT
#endif
#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_A >= 0
    static void construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_A >= 0

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_A >= 1
    template <class ARGS_01>
    static void construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_A >= 1

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_A >= 2
    template <class ARGS_01,
              class ARGS_02>
    static void construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_A >= 2

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_A >= 3
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03>
    static void construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_A >= 3

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_A >= 4
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04>
    static void construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_A >= 4

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_A >= 5
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05>
    static void construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_A >= 5

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_A >= 6
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06>
    static void construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_A >= 6

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_A >= 7
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07>
    static void construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_A >= 7

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_A >= 8
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08>
    static void construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_A >= 8

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_A >= 9
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09>
    static void construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_A >= 9

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_A >= 10
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class ARGS_10>
    static void construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_A >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
    template <class... ARGS>
    static void construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args);
// }}} END GENERATED CODE
#endif

    template <class KEY_TYPE>
    static void constructFromKey(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(KEY_TYPE)  key);
        // Load into the specified 'entry' the 'ENTRY' value comprised of the
        // specified 'key' and a default constructed 'VALUE', using the
        // specified 'allocator' to supply memory.  'allocator' is ignored if
        // the (template parameter) type 'ENTRY' is not allocator aware.

    static const KEY& key(const ENTRY& entry);
        // Return the key of the specified 'entry'.
};

                            // =================
                            // class FlatHashMap
                            // =================

template <class KEY, class VALUE, class HASH, class EQUAL>
class FlatHashMap {
    // This class template implements a value-semantic container type holding
    // an unordered map of 'KEY-VALUE' pairs having unique keys that provides a
    // mapping from keys of (template parameter) type 'KEY' to their associated
    // mapped values of (template parameter) type 'VALUE'.  The (template
    // parameter) type 'HASH' is a functor providing the hash value for 'KEY'.
    // The (template parameter) type 'EQUAL' is a functor providing the
    // equality function for two 'KEY' values.  See {Requirements on 'KEY',
    // 'HASH', and 'EQUAL'} for more information.

  private:
    // PRIVATE TYPES
    typedef FlatHashTable<KEY,
                          bsl::pair<KEY, VALUE>,
                          FlatHashMap_EntryUtil<KEY,
                                                VALUE,
                                                bsl::pair<KEY, VALUE> >,
                          HASH,
                          EQUAL> ImplType;
        // This is the underlying implementation class.

    // FRIENDS
    friend bool operator==<>(const FlatHashMap&, const FlatHashMap&);
    friend bool operator!=<>(const FlatHashMap&, const FlatHashMap&);

    // The following verbose declaration is required by the xlC 12.1 compiler.
    template <class K, class V, class H, class E>
    friend void swap(FlatHashMap<K, V, H, E>&, FlatHashMap<K, V, H, E>&);

  public:
    // PUBLIC TYPES
    typedef bsl::pair<typename bsl::add_const<KEY>::type, VALUE> value_type;

    typedef KEY                                key_type;
    typedef VALUE                              mapped_type;
    typedef bsl::size_t                        size_type;
    typedef bsl::ptrdiff_t                     difference_type;
    typedef EQUAL                              key_compare;
    typedef HASH                               hasher;
    typedef value_type&                        reference;
    typedef const value_type&                  const_reference;
    typedef value_type*                        pointer;
    typedef const value_type*                  const_pointer;
    typedef typename ImplType::iterator        iterator;
    typedef typename ImplType::const_iterator  const_iterator;

  private:
    // DATA
    ImplType d_impl;  // underlying flat hash table used by this flat hash map

  public:
    // CREATORS
    FlatHashMap();
    explicit FlatHashMap(bslma::Allocator *basicAllocator);
    explicit FlatHashMap(bsl::size_t capacity);
    FlatHashMap(bsl::size_t capacity, bslma::Allocator *basicAllocator);
    FlatHashMap(bsl::size_t       capacity,
                const HASH&       hash,
                bslma::Allocator *basicAllocator = 0);
    FlatHashMap(bsl::size_t       capacity,
                const HASH&       hash,
                const EQUAL&      equal,
                bslma::Allocator *basicAllocator = 0);
        // Create an empty 'FlatHashMap' object.  Optionally specify a
        // 'capacity' indicating the minimum initial size of the underlying
        // array of entries of this container.  If 'capacity' is not supplied
        // or is 0, no memory is allocated.  Optionally specify a 'hash'
        // functor used to generate the hash values associated with the keys of
        // elements in this container.  If 'hash' is not supplied, a
        // default-constructed object of the (template parameter) type 'HASH'
        // is used.  Optionally specify an equality functor 'equal' used to
        // determine whether the keys of two elements are equivalent.  If
        // 'equal' is not supplied, a default-constructed object of the
        // (template parameter) type 'EQUAL' is used.  Optionally specify a
        // 'basicAllocator' used to supply memory.  If 'basicAllocator' is not
        // supplied or is 0, the currently installed default allocator is used.

    template <class INPUT_ITERATOR>
    FlatHashMap(INPUT_ITERATOR    first,
                INPUT_ITERATOR    last,
                bslma::Allocator *basicAllocator = 0);
    template <class INPUT_ITERATOR>
    FlatHashMap(INPUT_ITERATOR    first,
                INPUT_ITERATOR    last,
                bsl::size_t       capacity,
                bslma::Allocator *basicAllocator = 0);
    template <class INPUT_ITERATOR>
    FlatHashMap(INPUT_ITERATOR    first,
                INPUT_ITERATOR    last,
                bsl::size_t       capacity,
                const HASH&       hash,
                bslma::Allocator *basicAllocator = 0);
    template <class INPUT_ITERATOR>
    FlatHashMap(INPUT_ITERATOR    first,
                INPUT_ITERATOR    last,
                bsl::size_t       capacity,
                const HASH&       hash,
                const EQUAL&      equal,
                bslma::Allocator *basicAllocator = 0);
        // Create a 'FlatHashMap' object initialized by insertion of the values
        // from the input iterator range specified by 'first' through 'last'
        // (including 'first', excluding 'last').  Optionally specify a
        // 'capacity' indicating the minimum initial size of the underlying
        // array of entries of this container.  If 'capacity' is not supplied
        // or is 0, no memory is allocated.  Optionally specify a 'hash'
        // functor used to generate hash values associated with the keys of the
        // elements in this container.  If 'hash' is not supplied, a
        // default-constructed object of the (template parameter) type 'HASH'
        // is used.  Optionally specify an equality functor 'equal' used to
        // determine whether the keys of two elements are equivalent.  If
        // 'equal' is not supplied, a default-constructed object of the
        // (template parameter) type 'EQUAL' is used.  Optionally specify a
        // 'basicAllocator' used to supply memory.  If 'basicAllocator' is not
        // supplied or is 0, the currently installed default allocator is used.
        // The behavior is undefined unless 'first' and 'last' refer to a
        // sequence of valid values where 'first' is at a position at or before
        // 'last'.  Note that if a member of the input sequence has an
        // equivalent key to an earlier member, the later member will not be
        // inserted.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS)
    FlatHashMap(bsl::initializer_list<value_type>  values,
                bslma::Allocator                  *basicAllocator = 0);
    FlatHashMap(bsl::initializer_list<value_type>  values,
                bsl::size_t                        capacity,
                bslma::Allocator                  *basicAllocator = 0);
    FlatHashMap(bsl::initializer_list<value_type>  values,
                bsl::size_t                        capacity,
                const HASH&                        hash,
                bslma::Allocator                  *basicAllocator = 0);
    FlatHashMap(bsl::initializer_list<value_type>  values,
                bsl::size_t                        capacity,
                const HASH&                        hash,
                const EQUAL&                       equal,
                bslma::Allocator                  *basicAllocator = 0);
        // Create a 'FlatHashMap' object initialized by insertion of the
        // specified 'values'.  Optionally specify a 'capacity' indicating the
        // minimum initial size of the underlying array of entries of this
        // container.  If 'capacity' is not supplied or is 0, no memory is
        // allocated.  Optionally specify a 'hash' functor used to generate
        // hash values associated with the keys of elements in this container.
        // If 'hash' is not supplied, a default-constructed object of the
        // (template parameter) type 'HASH' is used.  Optionally specify an
        // equality functor 'equal' used to determine whether the keys of two
        // elements are equivalent.  If 'equal' is not supplied, a
        // default-constructed object of the (template parameter) type 'EQUAL'
        // is used.  Optionally specify a 'basicAllocator' used to supply
        // memory.  If 'basicAllocator' is not supplied or is 0, the currently
        // installed default allocator is used.  Note that if a member of
        // 'values' has an equivalent key to an earlier member, the later
        // member will not be inserted.
#endif

    FlatHashMap(const FlatHashMap&  original,
                bslma::Allocator   *basicAllocator = 0);
        // Create a 'FlatHashMap' object having the same value, hasher, and
        // equality comparator as the specified 'original' object.  Optionally
        // specify a 'basicAllocator' used to supply memory.  If
        // 'basicAllocator' is not specified or is 0, the currently installed
        // default allocator is used.

    FlatHashMap(bslmf::MovableRef<FlatHashMap> original);
        // Create a 'FlatHashMap' object having the same value, hasher,
        // equality comparator, and allocator as the specified 'original'
        // object.  The contents of 'original' are moved (in constant time) to
        // this object, 'original' is left in a (valid) unspecified state, and
        // no exceptions will be thrown.

    FlatHashMap(bslmf::MovableRef<FlatHashMap>  original,
                bslma::Allocator               *basicAllocator);
        // Create a 'FlatHashMap' object having the same value, hasher, and
        // equality comparator as the specified 'original' object, using the
        // specified 'basicAllocator' to supply memory.  If 'basicAllocator' is
        // 0, the currently installed default allocator is used.  The allocator
        // of 'original' remains unchanged.  If 'original' and the newly
        // created object have the same allocator then the contents of
        // 'original' are moved (in constant time) to this object, 'original'
        // is left in a (valid) unspecified state, and no exceptions will be
        // thrown; otherwise, 'original' is unchanged (and an exception may be
        // thrown).

    ~FlatHashMap();
        // Destroy this object and each of its elements.

    // MANIPULATORS
    FlatHashMap& operator=(const FlatHashMap& rhs);
        // Assign to this object the value, hasher, and equality functor of the
        // specified 'rhs' object, and return a reference providing modifiable
        // access to this object.

    FlatHashMap& operator=(bslmf::MovableRef<FlatHashMap> rhs);
        // Assign to this object the value, hasher, and equality comparator of
        // the specified 'rhs' object, and return a reference providing
        // modifiable access to this object.  If this object and 'rhs' use the
        // same allocator the contents of 'rhs' are moved (in constant time) to
        // this object.  'rhs' is left in a (valid) unspecified state.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS)
    FlatHashMap& operator=(bsl::initializer_list<value_type> values);
        // Assign to this object the value resulting from first clearing this
        // map and then inserting each object in the specified 'values'
        // initializer list, ignoring those objects having a value whose key is
        // equivalent to that which appears earlier in the list; return a
        // reference providing modifiable access to this object.  This method
        // requires that the (template parameter) type 'KEY' be
        // 'copy-insertable' into this map (see {Requirements on 'KEY', 'HASH',
        // and 'EQUAL'}).
#endif

    template <class KEY_TYPE>
    VALUE& operator[](BSLS_COMPILERFEATURES_FORWARD_REF(KEY_TYPE) key);
        // Return a reference providing modifiable access to the mapped value
        // associated with the specified 'key' in this map.  If this map does
        // not already contain an element having 'key', insert an element with
        // the 'key' and a default-constructed 'VALUE', and return a reference
        // to the newly mapped value.  If 'key' is movable, 'key' is left in a
        // (valid) unspecified state.

    VALUE& at(const KEY& key);
        // Return a reference providing modifiable access to the mapped value
        // associated with the specified 'key' in this map, if such an entry
        // exists; otherwise throw a 'std::out_of_range' exception.  Note that
        // this method is not exception-neutral.

    void clear();
        // Remove all elements from this map.  Note that this map will be empty
        // after calling this method, but allocated memory may be retained for
        // future use.  See the 'capacity' method.

    bsl::pair<iterator, iterator> equal_range(const KEY& key);
        // Return a pair of iterators defining the sequence of modifiable
        // elements in this map having the specified 'key', where the first
        // iterator is positioned at the start of the sequence and the second
        // iterator is positioned one past the end of the sequence.  If this
        // map contains no elements having a key equivalent to 'key', then the
        // two returned iterators will have the same value.  Note that since a
        // map maintains unique keys, the range will contain at most one
        // element.

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bdlc_flathashmap.h
#ifndef BDLC_FLATHASHMAP_VARIADIC_LIMIT
#define BDLC_FLATHASHMAP_VARIADIC_LIMIT 10
#endif
#ifndef BDLC_FLATHASHMAP_VARIADIC_LIMIT_B
#define BDLC_FLATHASHMAP_VARIADIC_LIMIT_B BDLC_FLATHASHMAP_VARIADIC_LIMIT
#endif
#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 0
    bsl::pair<iterator, bool> emplace(
                              );
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 0

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 1
    template <class ARGS_01>
    bsl::pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 1

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 2
    template <class ARGS_01,
              class ARGS_02>
    bsl::pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 2

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 3
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03>
    bsl::pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 3

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 4
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04>
    bsl::pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 4

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 5
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05>
    bsl::pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 5

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 6
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06>
    bsl::pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 6

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 7
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07>
    bsl::pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 7

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 8
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08>
    bsl::pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 8

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 9
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09>
    bsl::pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 9

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 10
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class ARGS_10>
    bsl::pair<iterator, bool> emplace(
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 10


#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 0
    iterator emplace_hint(const_iterator hint);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 0

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 1
    template <class ARGS_01>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 1

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 2
    template <class ARGS_01,
              class ARGS_02>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 2

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 3
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 3

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 4
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 4

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 5
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 5

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 6
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 6

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 7
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 7

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 8
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 8

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 9
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 9

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 10
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class ARGS_10>
    iterator emplace_hint(const_iterator hint,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_B >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
    template <class... ARGS>
    bsl::pair<iterator, bool> emplace(
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args);

    template <class... ARGS>
    iterator emplace_hint(const_iterator hint,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args);
// }}} END GENERATED CODE
#endif

    bsl::size_t erase(const KEY& key);
        // Remove from this map the element whose key is equal to the specified
        // 'key', if it exists, and return 1; otherwise (there is no element
        // having 'key' in this map), return 0 with no other effect.  This
        // method invalidates all iterators and references to the removed
        // element.

    iterator erase(const_iterator position);
    iterator erase(iterator position);
        // Remove from this map the element at the specified 'position', and
        // return an iterator referring to the modifiable element immediately
        // following the removed element, or to the past-the-end position if
        // the removed element was the last element in the sequence of elements
        // maintained by this map.  This method invalidates all iterators and
        // references to the removed element.  The behavior is undefined unless
        // 'position' refers to an element in this map.

    iterator erase(const_iterator first, const_iterator last);
        // Remove from this map the elements starting at the specified 'first'
        // position up to, but not including, the specified 'last' position,
        // and return an iterator referencing the same element as 'last'.  This
        // method invalidates all iterators and references to the removed
        // elements.  The behavior is undefined unless 'first' and 'last' are
        // valid iterators on this map, and the 'first' position is at or
        // before the 'last' position in the iteration sequence provided by
        // this container.

    iterator find(const KEY& key);
        // Return an iterator referring to the modifiable element in this map
        // having the specified 'key', or 'end()' if no such entry exists in
        // this map.

#if defined(BSLS_PLATFORM_CMP_SUN) && BSLS_PLATFORM_CMP_VERSION < 0x5130
    template <class VALUE_TYPE>
    bsl::pair<iterator, bool>
#elif !defined(BSLS_COMPILERFEATURES_SUPPORT_TRAITS_HEADER)
    template <class VALUE_TYPE>
    typename bsl::enable_if<bsl::is_convertible<VALUE_TYPE, value_type>::value,
                            bsl::pair<iterator, bool> >::type
#else
    template <class VALUE_TYPE>
    typename bsl::enable_if<bsl::is_constructible<value_type,
                                                  VALUE_TYPE&&>::value,
                            bsl::pair<iterator, bool> >::type
#endif
    insert(BSLS_COMPILERFEATURES_FORWARD_REF(VALUE_TYPE) value)
        // Insert the specified 'value' into this map if the key of 'value'
        // does not already exist in this map; otherwise, this method has no
        // effect.  Return a 'pair' whose 'first' member is an iterator
        // referring to the (possibly newly inserted) modifiable element in
        // this map whose key is equivalent to that of the element to be
        // inserted, and whose 'second' member is 'true' if a new element was
        // inserted, and 'false' if an element with an equivalent key was
        // already present.
    {
        // Note that some compilers require functions declared with 'enable_if'
        // to be defined inline.

        return d_impl.insert(BSLS_COMPILERFEATURES_FORWARD(VALUE_TYPE, value));
    }

#if defined(BSLS_PLATFORM_CMP_SUN) && BSLS_PLATFORM_CMP_VERSION < 0x5130
    template <class VALUE_TYPE>
    iterator
#elif !defined(BSLS_COMPILERFEATURES_SUPPORT_TRAITS_HEADER)
    template <class VALUE_TYPE>
    typename bsl::enable_if<bsl::is_convertible<VALUE_TYPE, value_type>::value,
                            iterator>::type
#else
    template <class VALUE_TYPE>
    typename bsl::enable_if<bsl::is_constructible<value_type,
                                                  VALUE_TYPE&&>::value,
                            iterator>::type
#endif
    insert(const_iterator                                ,
           BSLS_COMPILERFEATURES_FORWARD_REF(VALUE_TYPE) value)
        // Insert the specified 'value' into this map if the key of 'value'
        // does not already exist in this map; otherwise, this method has no
        // effect.  Return an iterator referring to the (possibly newly
        // inserted) modifiable element in this map whose key is equivalent to
        // that of the element to be inserted.  The supplied 'const_iterator'
        // is ignored.
    {
        // Note that some compilers require functions declared with 'enable_if'
        // to be defined inline.

        return d_impl.insert(BSLS_COMPILERFEATURES_FORWARD(VALUE_TYPE,
                                                           value)).first;
    }

    template <class INPUT_ITERATOR>
    void insert(INPUT_ITERATOR first, INPUT_ITERATOR last);
        // Insert into this map the value of each element in the input iterator
        // range specified by 'first' through 'last' (including 'first',
        // excluding 'last').  The behavior is undefined unless 'first' and
        // 'last' refer to a sequence of valid values where 'first' is at a
        // position at or before 'last'.  Note that if the key of a member of
        // the input sequence is equivalent to the key of an earlier member,
        // the later member will not be inserted.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS)
    void insert(bsl::initializer_list<value_type> values);
        // Insert into this map an element having the value of each object in
        // the specified 'values' initializer list if a value with an
        // equivalent key is not already contained in this map.  This method
        // requires that the (template parameter) type 'KEY' be copy-insertable
        // (see {Requirements on 'KEY', 'HASH', and 'EQUAL'}).
#endif

    void rehash(bsl::size_t minimumCapacity);
        // Change the capacity of this map to at least the specified
        // 'minimumCapacity', and redistribute all the contained elements into
        // a new sequence of entries according to their hash values.  If
        // '0 == minimumCapacity' and '0 == size()', the map is returned to the
        // default constructed state.  After this call, 'load_factor()' will be
        // less than or equal to 'max_load_factor()' and all iterators,
        // pointers, and references to elements of this map are invalidated.

    void reserve(bsl::size_t numEntries);
        // Change the capacity of this map to at least a capacity that can
        // accommodate the specified 'numEntries' (accounting for the load
        // factor invariant), and redistribute all the contained elements into
        // a new sequence of entries according to their hash values.  If
        // '0 == numEntries' and '0 == size()', the map is returned to the
        // default constructed state.  After this call, 'load_factor()' will be
        // less than or equal to 'max_load_factor()' and all iterators,
        // pointers, and references to elements of this map are invalidated.
        // Note that this method is effectively equivalent to:
        //..
        //     rehash(bsl::ceil(numEntries / max_load_factor()))
        //..

    void reset();
        // Remove all elements from this map and release all memory from this
        // map, returning the map to the default constructed state.

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bdlc_flathashmap.h
#ifndef BDLC_FLATHASHMAP_VARIADIC_LIMIT
#define BDLC_FLATHASHMAP_VARIADIC_LIMIT 10
#endif
#ifndef BDLC_FLATHASHMAP_VARIADIC_LIMIT_C
#define BDLC_FLATHASHMAP_VARIADIC_LIMIT_C BDLC_FLATHASHMAP_VARIADIC_LIMIT
#endif
#ifdef BSLS_LIBRARYFEATURES_HAS_CPP11_PAIR_PIECEWISE_CONSTRUCTOR
#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 0
    bsl::pair<iterator, bool> try_emplace(const KEY& key);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 0

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 1
    template< class ARGS_01>
    bsl::pair<iterator, bool> try_emplace(const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 1

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 2
    template< class ARGS_01,
              class ARGS_02>
    bsl::pair<iterator, bool> try_emplace(const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 2

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 3
    template< class ARGS_01,
              class ARGS_02,
              class ARGS_03>
    bsl::pair<iterator, bool> try_emplace(const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 3

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 4
    template< class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04>
    bsl::pair<iterator, bool> try_emplace(const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 4

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 5
    template< class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05>
    bsl::pair<iterator, bool> try_emplace(const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 5

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 6
    template< class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06>
    bsl::pair<iterator, bool> try_emplace(const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 6

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 7
    template< class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07>
    bsl::pair<iterator, bool> try_emplace(const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 7

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 8
    template< class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08>
    bsl::pair<iterator, bool> try_emplace(const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 8

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 9
    template< class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09>
    bsl::pair<iterator, bool> try_emplace(const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 9

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 10
    template< class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class ARGS_10>
    bsl::pair<iterator, bool> try_emplace(const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 10


#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 0
    bsl::pair<iterator, bool> try_emplace(
                                     BloombergLP::bslmf::MovableRef<KEY> key);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 0

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 1
    template <class ARGS_01>
    bsl::pair<iterator, bool> try_emplace(
                                     BloombergLP::bslmf::MovableRef<KEY> key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 1

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 2
    template <class ARGS_01,
              class ARGS_02>
    bsl::pair<iterator, bool> try_emplace(
                                     BloombergLP::bslmf::MovableRef<KEY> key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 2

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 3
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03>
    bsl::pair<iterator, bool> try_emplace(
                                     BloombergLP::bslmf::MovableRef<KEY> key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 3

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 4
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04>
    bsl::pair<iterator, bool> try_emplace(
                                     BloombergLP::bslmf::MovableRef<KEY> key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 4

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 5
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05>
    bsl::pair<iterator, bool> try_emplace(
                                     BloombergLP::bslmf::MovableRef<KEY> key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 5

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 6
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06>
    bsl::pair<iterator, bool> try_emplace(
                                     BloombergLP::bslmf::MovableRef<KEY> key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 6

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 7
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07>
    bsl::pair<iterator, bool> try_emplace(
                                     BloombergLP::bslmf::MovableRef<KEY> key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 7

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 8
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08>
    bsl::pair<iterator, bool> try_emplace(
                                     BloombergLP::bslmf::MovableRef<KEY> key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 8

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 9
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09>
    bsl::pair<iterator, bool> try_emplace(
                                     BloombergLP::bslmf::MovableRef<KEY> key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 9

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 10
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class ARGS_10>
    bsl::pair<iterator, bool> try_emplace(
                                     BloombergLP::bslmf::MovableRef<KEY> key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 10


#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 0
    iterator
    try_emplace(const_iterator, const KEY& key);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 0

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 1
    template<class ARGS_01>
    iterator
    try_emplace(const_iterator, const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 1

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 2
    template<class ARGS_01,
             class ARGS_02>
    iterator
    try_emplace(const_iterator, const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 2

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 3
    template<class ARGS_01,
             class ARGS_02,
             class ARGS_03>
    iterator
    try_emplace(const_iterator, const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 3

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 4
    template<class ARGS_01,
             class ARGS_02,
             class ARGS_03,
             class ARGS_04>
    iterator
    try_emplace(const_iterator, const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 4

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 5
    template<class ARGS_01,
             class ARGS_02,
             class ARGS_03,
             class ARGS_04,
             class ARGS_05>
    iterator
    try_emplace(const_iterator, const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 5

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 6
    template<class ARGS_01,
             class ARGS_02,
             class ARGS_03,
             class ARGS_04,
             class ARGS_05,
             class ARGS_06>
    iterator
    try_emplace(const_iterator, const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 6

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 7
    template<class ARGS_01,
             class ARGS_02,
             class ARGS_03,
             class ARGS_04,
             class ARGS_05,
             class ARGS_06,
             class ARGS_07>
    iterator
    try_emplace(const_iterator, const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 7

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 8
    template<class ARGS_01,
             class ARGS_02,
             class ARGS_03,
             class ARGS_04,
             class ARGS_05,
             class ARGS_06,
             class ARGS_07,
             class ARGS_08>
    iterator
    try_emplace(const_iterator, const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 8

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 9
    template<class ARGS_01,
             class ARGS_02,
             class ARGS_03,
             class ARGS_04,
             class ARGS_05,
             class ARGS_06,
             class ARGS_07,
             class ARGS_08,
             class ARGS_09>
    iterator
    try_emplace(const_iterator, const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 9

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 10
    template<class ARGS_01,
             class ARGS_02,
             class ARGS_03,
             class ARGS_04,
             class ARGS_05,
             class ARGS_06,
             class ARGS_07,
             class ARGS_08,
             class ARGS_09,
             class ARGS_10>
    iterator
    try_emplace(const_iterator, const KEY& key,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 10


#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 0
    iterator try_emplace(const_iterator,
                         BloombergLP::bslmf::MovableRef<KEY> key);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 0

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 1
    template <class ARGS_01>
    iterator try_emplace(const_iterator,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 1

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 2
    template <class ARGS_01,
              class ARGS_02>
    iterator try_emplace(const_iterator,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 2

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 3
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03>
    iterator try_emplace(const_iterator,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 3

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 4
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04>
    iterator try_emplace(const_iterator,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 4

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 5
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05>
    iterator try_emplace(const_iterator,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 5

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 6
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06>
    iterator try_emplace(const_iterator,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 6

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 7
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07>
    iterator try_emplace(const_iterator,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 7

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 8
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08>
    iterator try_emplace(const_iterator,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 8

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 9
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09>
    iterator try_emplace(const_iterator,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 9

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 10
    template <class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class ARGS_10>
    iterator try_emplace(const_iterator,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10);
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_C >= 10

#endif
#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
#ifdef BSLS_LIBRARYFEATURES_HAS_CPP11_PAIR_PIECEWISE_CONSTRUCTOR
    template< class... ARGS>
    bsl::pair<iterator, bool> try_emplace(const KEY& key,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args);

    template <class... ARGS>
    bsl::pair<iterator, bool> try_emplace(
                                     BloombergLP::bslmf::MovableRef<KEY> key,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args);

    template<class... ARGS>
    iterator
    try_emplace(const_iterator, const KEY& key,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args);

    template <class... ARGS>
    iterator try_emplace(const_iterator,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args);
#endif
// }}} END GENERATED CODE
#endif

                          // Iterators

    iterator begin();
        // Return an iterator to the first element in the sequence of
        // modifiable elements maintained by this map, or the 'end' iterator if
        // this map is empty.

    iterator end();
        // Return an iterator to the past-the-end element in the sequence of
        // modifiable elements maintained by this map.

                             // Aspects

    void swap(FlatHashMap& other);
        // Exchange the value of this object as well as its hasher and equality
        // functors with those of the specified 'other' object.  The behavior
        // is undefined unless this object was created with the same allocator
        // as 'other'.

    // ACCESSORS
    const VALUE& at(const KEY& key) const;
        // Return a reference providing non-modifiable access to the mapped
        // value associated with the specified 'key' in this map, if such an
        // entry exists; otherwise throw a 'std::out_of_range' exception.  Note
        // that this method is not exception-neutral.

    bsl::size_t capacity() const;
        // Return the number of elements this map could hold if the load factor
        // were 1.

    bool contains(const KEY& key) const;
        // Return 'true' if this map contains an element having the specified
        // 'key', and 'false' otherwise.

    bsl::size_t count(const KEY& key) const;
        // Return the number of elements in this map having the specified
        // 'key'.  Note that since a flat hash map maintains unique keys, the
        // returned value will be either 0 or 1.

    bool empty() const;
        // Return 'true' if this map contains no elements, and 'false'
        // otherwise.

    bsl::pair<const_iterator, const_iterator> equal_range(
                                                         const KEY& key) const;
        // Return a pair of 'const_iterator's defining the sequence of elements
        // in this map having the specified 'key', where the first iterator is
        // positioned at the start of the sequence and the second iterator is
        // positioned one past the end of the sequence.  If this map contains
        // no elements having a key equivalent to 'key', then the two returned
        // iterators will have the same value.  Note that since a map maintains
        // unique keys, the range will contain at most one element.

    const_iterator find(const KEY& key) const;
        // Return a 'const_iterator' referring to the element in this map
        // having the specified 'key', or 'end()' if no such entry exists in
        // this map.

    HASH hash_function() const;
        // Return (a copy of) the unary hash functor used by this map to
        // generate a hash value (of type 'bsl::size_t') for a 'KEY' object.

    EQUAL key_eq() const;
        // Return (a copy of) the binary key-equality functor that returns
        // 'true' if the value of two 'KEY' objects are equivalent, and 'false'
        // otherwise.

    float load_factor() const;
        // Return the current ratio between the number of elements in this
        // container and its capacity.

    float max_load_factor() const;
        // Return the maximum load factor allowed for this map.  Note that if
        // an insert operation would cause the load factor to exceed
        // 'max_load_factor()', that same insert operation will increase the
        // capacity and rehash the entries of the container (see {Load Factor
        // and Resizing}).  Also note that the value returned by
        // 'max_load_factor' is implementation defined and cannot be changed by
        // the user.

    bsl::size_t size() const;
        // Return the number of elements in this map.

                          // Iterators

    const_iterator begin() const;
        // Return a 'const_iterator' to the first element in the sequence of
        // elements maintained by this map, or the 'end' iterator if this map
        // is empty.

    const_iterator cbegin() const;
        // Return a 'const_iterator' to the first element in the sequence of
        // elements maintained by this map, or the 'end' iterator if this map
        // is empty.

    const_iterator cend() const;
        // Return a 'const_iterator' to the past-the-end element in the
        // sequence of elements maintained by this map.

    const_iterator end() const;
        // Return a 'const_iterator' to the past-the-end element in the
        // sequence of elements maintained by this map.

                           // Aspects

    bslma::Allocator *allocator() const;
        // Return the allocator used by this flat hash map to supply memory.

    bsl::ostream& print(bsl::ostream& stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output 'stream' at the (absolute
        // value of) the optionally specified indentation 'level', and return a
        // reference to the modifiable 'stream'.  If 'level' is specified,
        // optionally specify 'spacesPerLevel', the number of spaces per
        // indentation level for this and all of its nested objects.  If
        // 'level' is negative, suppress indentation of the first line.  If
        // 'spacesPerLevel' is negative, format the entire output on one line,
        // suppressing all but the initial indentation (as governed by
        // 'level').  If 'stream' is not valid on entry, this operation has no
        // effect.
};

// FREE OPERATORS
template <class KEY, class VALUE, class HASH, class EQUAL>
bool operator==(const FlatHashMap<KEY, VALUE, HASH, EQUAL> &lhs,
                const FlatHashMap<KEY, VALUE, HASH, EQUAL> &rhs);
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'FlatHashMap' objects have the same
    // value if their sizes are the same and each element contained in one is
    // equal to an element of the other.  The hash and equality functors are
    // not involved in the comparison.

template <class KEY, class VALUE, class HASH, class EQUAL>
bool operator!=(const FlatHashMap<KEY, VALUE, HASH, EQUAL> &lhs,
                const FlatHashMap<KEY, VALUE, HASH, EQUAL> &rhs);
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have the
    // same value, and 'false' otherwise.  Two 'FlatHashMap' objects do not
    // have the same value if their sizes are different or one contains an
    // element equal to no element of the other.  The hash and equality
    // functors are not involved in the comparison.

template <class KEY, class VALUE, class HASH, class EQUAL>
bsl::ostream& operator<<(bsl::ostream&                               stream,
                         const FlatHashMap<KEY, VALUE, HASH, EQUAL>& map);
    // Write the value of the specified 'map' to the specified output 'stream'
    // in a single-line format, and return a reference providing modifiable
    // access to 'stream'.  If 'stream' is not valid on entry, this operation
    // has no effect.  Note that this human-readable format is not fully
    // specified and can change without notice.

// FREE FUNCTIONS
template <class KEY, class VALUE, class HASH, class EQUAL>
void swap(FlatHashMap<KEY, VALUE, HASH, EQUAL>& a,
          FlatHashMap<KEY, VALUE, HASH, EQUAL>& b);
    // Exchange the value, the hasher, and the key-equality functor of the
    // specified 'a' and 'b' objects.  This function provides the no-throw
    // exception-safety guarantee if the two objects were created with the same
    // allocator and the basic guarantee otherwise.

// ============================================================================
//                  TEMPLATE AND INLINE FUNCTION DEFINITIONS
// ============================================================================

                       // ----------------------------
                       // struct FlatHashMap_EntryUtil
                       // ----------------------------

// CLASS METHODS
#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bdlc_flathashmap.h
#ifndef BDLC_FLATHASHMAP_VARIADIC_LIMIT
#define BDLC_FLATHASHMAP_VARIADIC_LIMIT 10
#endif
#ifndef BDLC_FLATHASHMAP_VARIADIC_LIMIT_D
#define BDLC_FLATHASHMAP_VARIADIC_LIMIT_D BDLC_FLATHASHMAP_VARIADIC_LIMIT
#endif
#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_D >= 0
template <class KEY, class VALUE, class ENTRY>
inline
void FlatHashMap_EntryUtil<KEY, VALUE, ENTRY>::construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator)
{
    BSLS_ASSERT_SAFE(entry);
    bslma::ConstructionUtil::construct(
                                 entry,
                                 allocator);
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_D >= 0

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_D >= 1
template <class KEY, class VALUE, class ENTRY>
template <class ARGS_01>
inline
void FlatHashMap_EntryUtil<KEY, VALUE, ENTRY>::construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01)
{
    BSLS_ASSERT_SAFE(entry);
    bslma::ConstructionUtil::construct(
                                 entry,
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_D >= 1

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_D >= 2
template <class KEY, class VALUE, class ENTRY>
template <class ARGS_01,
          class ARGS_02>
inline
void FlatHashMap_EntryUtil<KEY, VALUE, ENTRY>::construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02)
{
    BSLS_ASSERT_SAFE(entry);
    bslma::ConstructionUtil::construct(
                                 entry,
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_D >= 2

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_D >= 3
template <class KEY, class VALUE, class ENTRY>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03>
inline
void FlatHashMap_EntryUtil<KEY, VALUE, ENTRY>::construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03)
{
    BSLS_ASSERT_SAFE(entry);
    bslma::ConstructionUtil::construct(
                                 entry,
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_D >= 3

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_D >= 4
template <class KEY, class VALUE, class ENTRY>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04>
inline
void FlatHashMap_EntryUtil<KEY, VALUE, ENTRY>::construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04)
{
    BSLS_ASSERT_SAFE(entry);
    bslma::ConstructionUtil::construct(
                                 entry,
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_D >= 4

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_D >= 5
template <class KEY, class VALUE, class ENTRY>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05>
inline
void FlatHashMap_EntryUtil<KEY, VALUE, ENTRY>::construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05)
{
    BSLS_ASSERT_SAFE(entry);
    bslma::ConstructionUtil::construct(
                                 entry,
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_D >= 5

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_D >= 6
template <class KEY, class VALUE, class ENTRY>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06>
inline
void FlatHashMap_EntryUtil<KEY, VALUE, ENTRY>::construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06)
{
    BSLS_ASSERT_SAFE(entry);
    bslma::ConstructionUtil::construct(
                                 entry,
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_D >= 6

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_D >= 7
template <class KEY, class VALUE, class ENTRY>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07>
inline
void FlatHashMap_EntryUtil<KEY, VALUE, ENTRY>::construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07)
{
    BSLS_ASSERT_SAFE(entry);
    bslma::ConstructionUtil::construct(
                                 entry,
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_D >= 7

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_D >= 8
template <class KEY, class VALUE, class ENTRY>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08>
inline
void FlatHashMap_EntryUtil<KEY, VALUE, ENTRY>::construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08)
{
    BSLS_ASSERT_SAFE(entry);
    bslma::ConstructionUtil::construct(
                                 entry,
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_D >= 8

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_D >= 9
template <class KEY, class VALUE, class ENTRY>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08,
          class ARGS_09>
inline
void FlatHashMap_EntryUtil<KEY, VALUE, ENTRY>::construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09)
{
    BSLS_ASSERT_SAFE(entry);
    bslma::ConstructionUtil::construct(
                                 entry,
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_D >= 9

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_D >= 10
template <class KEY, class VALUE, class ENTRY>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08,
          class ARGS_09,
          class ARGS_10>
inline
void FlatHashMap_EntryUtil<KEY, VALUE, ENTRY>::construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10)
{
    BSLS_ASSERT_SAFE(entry);
    bslma::ConstructionUtil::construct(
                                 entry,
                                 allocator,
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_10, args_10));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_D >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class KEY, class VALUE, class ENTRY>
template <class... ARGS>
inline
void FlatHashMap_EntryUtil<KEY, VALUE, ENTRY>::construct(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args)
{
    BSLS_ASSERT_SAFE(entry);
    bslma::ConstructionUtil::construct(
                                 entry,
                                 allocator,
                                 BSLS_COMPILERFEATURES_FORWARD(ARGS, args)...);
}
// }}} END GENERATED CODE
#endif

template <class KEY, class VALUE, class ENTRY>
template <class KEY_TYPE>
inline
void FlatHashMap_EntryUtil<KEY, VALUE, ENTRY>::constructFromKey(
                        ENTRY                                       *entry,
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(KEY_TYPE)  key)
{
    BSLS_ASSERT_SAFE(entry);

    bsls::ObjectBuffer<VALUE> value;

    bslma::ConstructionUtil::construct(value.address(), allocator);
    bslma::DestructorGuard<VALUE> guard(value.address());

    bslma::ConstructionUtil::construct(
                                  entry,
                                  allocator,
                                  BSLS_COMPILERFEATURES_FORWARD(KEY_TYPE, key),
                                  bslmf::MovableRefUtil::move(value.object()));
}

template <class KEY, class VALUE, class ENTRY>
inline
const KEY& FlatHashMap_EntryUtil<KEY, VALUE, ENTRY>::key(const ENTRY& entry)
{
    return entry.first;
}

                            // -----------------
                            // class FlatHashMap
                            // -----------------

// CREATORS
template <class KEY, class VALUE, class HASH, class EQUAL>
inline
FlatHashMap<KEY, VALUE, HASH, EQUAL>::FlatHashMap()
: d_impl(0, HASH(), EQUAL())
{
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
FlatHashMap<KEY, VALUE, HASH, EQUAL>::FlatHashMap(
                                              bslma::Allocator *basicAllocator)
: d_impl(0, HASH(), EQUAL(), basicAllocator)
{
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
FlatHashMap<KEY, VALUE, HASH, EQUAL>::FlatHashMap(bsl::size_t capacity)
: d_impl(capacity, HASH(), EQUAL())
{
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
FlatHashMap<KEY, VALUE, HASH, EQUAL>::FlatHashMap(
                                              bsl::size_t       capacity,
                                              bslma::Allocator *basicAllocator)
: d_impl(capacity, HASH(), EQUAL(), basicAllocator)
{
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
FlatHashMap<KEY, VALUE, HASH, EQUAL>::FlatHashMap(
                                              bsl::size_t       capacity,
                                              const HASH&       hash,
                                              bslma::Allocator *basicAllocator)
: d_impl(capacity, hash, EQUAL(), basicAllocator)
{
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
FlatHashMap<KEY, VALUE, HASH, EQUAL>::FlatHashMap(
                                              bsl::size_t       capacity,
                                              const HASH&       hash,
                                              const EQUAL&      equal,
                                              bslma::Allocator *basicAllocator)
: d_impl(capacity, hash, equal, basicAllocator)
{
}

template <class KEY, class VALUE, class HASH, class EQUAL>
template <class INPUT_ITERATOR>
inline
FlatHashMap<KEY, VALUE, HASH, EQUAL>::FlatHashMap(
                                              INPUT_ITERATOR    first,
                                              INPUT_ITERATOR    last,
                                              bslma::Allocator *basicAllocator)
: d_impl(0, HASH(), EQUAL(), basicAllocator)
{
    insert(first, last);
}

template <class KEY, class VALUE, class HASH, class EQUAL>
template <class INPUT_ITERATOR>
inline
FlatHashMap<KEY, VALUE, HASH, EQUAL>::FlatHashMap(
                                              INPUT_ITERATOR    first,
                                              INPUT_ITERATOR    last,
                                              bsl::size_t       capacity,
                                              bslma::Allocator *basicAllocator)
: d_impl(capacity, HASH(), EQUAL(), basicAllocator)
{
    insert(first, last);
}

template <class KEY, class VALUE, class HASH, class EQUAL>
template <class INPUT_ITERATOR>
inline
FlatHashMap<KEY, VALUE, HASH, EQUAL>::FlatHashMap(
                                              INPUT_ITERATOR    first,
                                              INPUT_ITERATOR    last,
                                              bsl::size_t       capacity,
                                              const HASH&       hash,
                                              bslma::Allocator *basicAllocator)
: d_impl(capacity, hash, EQUAL(), basicAllocator)
{
    insert(first, last);
}

template <class KEY, class VALUE, class HASH, class EQUAL>
template <class INPUT_ITERATOR>
inline
FlatHashMap<KEY, VALUE, HASH, EQUAL>::FlatHashMap(
                                              INPUT_ITERATOR    first,
                                              INPUT_ITERATOR    last,
                                              bsl::size_t       capacity,
                                              const HASH&       hash,
                                              const EQUAL&      equal,
                                              bslma::Allocator *basicAllocator)
: d_impl(capacity, hash, equal, basicAllocator)
{
    insert(first, last);
}

#if defined(BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS)
template <class KEY, class VALUE, class HASH, class EQUAL>
inline
FlatHashMap<KEY, VALUE, HASH, EQUAL>::FlatHashMap(
                             bsl::initializer_list<value_type>  values,
                             bslma::Allocator                  *basicAllocator)
: FlatHashMap(values.begin(),
              values.end(),
              0,
              HASH(),
              EQUAL(),
              basicAllocator)
{
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
FlatHashMap<KEY, VALUE, HASH, EQUAL>::FlatHashMap(
                             bsl::initializer_list<value_type>  values,
                             bsl::size_t                        capacity,
                             bslma::Allocator                  *basicAllocator)
: FlatHashMap(values.begin(),
              values.end(),
              capacity,
              HASH(),
              EQUAL(),
              basicAllocator)
{
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
FlatHashMap<KEY, VALUE, HASH, EQUAL>::FlatHashMap(
                             bsl::initializer_list<value_type>  values,
                             bsl::size_t                        capacity,
                             const HASH&                        hash,
                             bslma::Allocator                  *basicAllocator)
: FlatHashMap(values.begin(),
              values.end(),
              capacity,
              hash,
              EQUAL(),
              basicAllocator)
{
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
FlatHashMap<KEY, VALUE, HASH, EQUAL>::FlatHashMap(
                             bsl::initializer_list<value_type>  values,
                             bsl::size_t                        capacity,
                             const HASH&                        hash,
                             const EQUAL&                       equal,
                             bslma::Allocator                  *basicAllocator)
: FlatHashMap(values.begin(),
              values.end(),
              capacity,
              hash,
              equal,
              basicAllocator)
{
}
#endif

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
FlatHashMap<KEY, VALUE, HASH, EQUAL>::FlatHashMap(
                                            const FlatHashMap&  original,
                                            bslma::Allocator   *basicAllocator)
: d_impl(original.d_impl, basicAllocator)
{
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
FlatHashMap<KEY, VALUE, HASH, EQUAL>::FlatHashMap(
                                       bslmf::MovableRef<FlatHashMap> original)
: d_impl(bslmf::MovableRefUtil::move(
                               bslmf::MovableRefUtil::access(original).d_impl))
{
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
FlatHashMap<KEY, VALUE, HASH, EQUAL>::FlatHashMap(
                                bslmf::MovableRef<FlatHashMap>  original,
                                bslma::Allocator               *basicAllocator)
: d_impl(bslmf::MovableRefUtil::move(
                               bslmf::MovableRefUtil::access(original).d_impl),
         basicAllocator)
{
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
FlatHashMap<KEY, VALUE, HASH, EQUAL>::~FlatHashMap()
{
}

// MANIPULATORS
template <class KEY, class VALUE, class HASH, class EQUAL>
inline
FlatHashMap<KEY, VALUE, HASH, EQUAL>&
FlatHashMap<KEY, VALUE, HASH, EQUAL>::operator=(const FlatHashMap& rhs)
{
    d_impl = rhs.d_impl;

    return *this;
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
FlatHashMap<KEY, VALUE, HASH, EQUAL>&
FlatHashMap<KEY, VALUE, HASH, EQUAL>::operator=(
                                            bslmf::MovableRef<FlatHashMap> rhs)
{
    FlatHashMap& lvalue = rhs;

    d_impl = bslmf::MovableRefUtil::move(lvalue.d_impl);

    return *this;
}

#if defined(BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS)
template <class KEY, class VALUE, class HASH, class EQUAL>
inline
FlatHashMap<KEY, VALUE, HASH, EQUAL>&
FlatHashMap<KEY, VALUE, HASH, EQUAL>::operator=(
                                      bsl::initializer_list<value_type> values)
{
    FlatHashMap tmp(values.begin(),
                    values.end(),
                    0,
                    d_impl.hash_function(),
                    d_impl.key_eq(),
                    d_impl.allocator());

    this->swap(tmp);

    return *this;
}
#endif

template <class KEY, class VALUE, class HASH, class EQUAL>
template <class KEY_TYPE>
inline
VALUE& FlatHashMap<KEY, VALUE, HASH, EQUAL>::operator[](
                               BSLS_COMPILERFEATURES_FORWARD_REF(KEY_TYPE) key)
{
    return d_impl[BSLS_COMPILERFEATURES_FORWARD(KEY_TYPE, key)].second;
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
VALUE& FlatHashMap<KEY, VALUE, HASH, EQUAL>::at(const KEY& key)
{
    iterator node = d_impl.find(key);

    if (node == d_impl.end()) {
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                          "FlatHashMap<...>::at(key_type): invalid key value");
    }

    return node->second;
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
void
FlatHashMap<KEY, VALUE, HASH, EQUAL>::clear()
{
    d_impl.clear();
}

template <class KEY, class VALUE, class HASH, class EQUAL>
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator,
          typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::equal_range(const KEY& key)
{
    return d_impl.equal_range(key);
}

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bdlc_flathashmap.h
#ifndef BDLC_FLATHASHMAP_VARIADIC_LIMIT
#define BDLC_FLATHASHMAP_VARIADIC_LIMIT 10
#endif
#ifndef BDLC_FLATHASHMAP_VARIADIC_LIMIT_E
#define BDLC_FLATHASHMAP_VARIADIC_LIMIT_E BDLC_FLATHASHMAP_VARIADIC_LIMIT
#endif
#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 0
template <class KEY, class VALUE, class HASH, class EQUAL>
inline
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::emplace(
                               )
{
    return d_impl.emplace();
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 0

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 1
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01>
inline
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01)
{
    return d_impl.emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 1

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 2
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02>
inline
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02)
{
    return d_impl.emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 2

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 3
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03>
inline
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03)
{
    return d_impl.emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 3

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 4
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04>
inline
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04)
{
    return d_impl.emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 4

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 5
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05>
inline
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05)
{
    return d_impl.emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 5

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 6
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06>
inline
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06)
{
    return d_impl.emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 6

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 7
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07>
inline
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07)
{
    return d_impl.emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 7

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 8
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08>
inline
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08)
{
    return d_impl.emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 8

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 9
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08,
          class ARGS_09>
inline
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09)
{
    return d_impl.emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 9

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 10
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08,
          class ARGS_09,
          class ARGS_10>
inline
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::emplace(
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10)
{
    return d_impl.emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_10, args_10));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 10


#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 0
template <class KEY, class VALUE, class HASH, class EQUAL>
inline
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::emplace_hint(const_iterator)
{
    return emplace().first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 0

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 1
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01>
inline
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::emplace_hint(const_iterator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01)
{
    return emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01)).first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 1

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 2
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02>
inline
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::emplace_hint(const_iterator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02)
{
    return emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02)).first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 2

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 3
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03>
inline
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::emplace_hint(const_iterator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03)
{
    return emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03)).first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 3

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 4
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04>
inline
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::emplace_hint(const_iterator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04)
{
    return emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04)).first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 4

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 5
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05>
inline
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::emplace_hint(const_iterator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05)
{
    return emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05)).first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 5

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 6
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06>
inline
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::emplace_hint(const_iterator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06)
{
    return emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06)).first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 6

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 7
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07>
inline
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::emplace_hint(const_iterator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07)
{
    return emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07)).first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 7

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 8
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08>
inline
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::emplace_hint(const_iterator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08)
{
    return emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08)).first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 8

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 9
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08,
          class ARGS_09>
inline
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::emplace_hint(const_iterator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09)
{
    return emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09)).first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 9

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 10
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08,
          class ARGS_09,
          class ARGS_10>
inline
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::emplace_hint(const_iterator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10)
{
    return emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_10, args_10)).first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_E >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class... ARGS>
inline
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::emplace(
                               BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args)
{
    return d_impl.emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS, args)...);
}

template <class KEY, class VALUE, class HASH, class EQUAL>
template <class... ARGS>
inline
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::emplace_hint(const_iterator,
                               BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args)
{
    return emplace(BSLS_COMPILERFEATURES_FORWARD(ARGS, args)...).first;
}
// }}} END GENERATED CODE
#endif


template <class KEY, class VALUE, class HASH, class EQUAL>
bsl::size_t FlatHashMap<KEY, VALUE, HASH, EQUAL>::erase(const KEY& key)
{
    return d_impl.erase(key);
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::erase(const_iterator position)
{
    BSLS_ASSERT_SAFE(position != end());

    return d_impl.erase(position);
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::erase(iterator position)
{
    // Note that this overload is necessary to avoid ambiguity when the key is
    // an iterator.

    BSLS_ASSERT_SAFE(position != end());

    return d_impl.erase(position);
}

template <class KEY, class VALUE, class HASH, class EQUAL>
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::erase(const_iterator first,
                                            const_iterator last)
{
    return d_impl.erase(first, last);
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::find(const KEY& key)
{
    return d_impl.find(key);
}

template <class KEY, class VALUE, class HASH, class EQUAL>
template <class INPUT_ITERATOR>
void FlatHashMap<KEY, VALUE, HASH, EQUAL>::insert(INPUT_ITERATOR first,
                                                  INPUT_ITERATOR last)
{
    d_impl.insert(first, last);
}

#if defined(BSLS_COMPILERFEATURES_SUPPORT_GENERALIZED_INITIALIZERS)
template <class KEY, class VALUE, class HASH, class EQUAL>
void FlatHashMap<KEY, VALUE, HASH, EQUAL>::insert(
                                      bsl::initializer_list<value_type> values)
{
    insert(values.begin(), values.end());
}
#endif

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
void FlatHashMap<KEY, VALUE, HASH, EQUAL>::rehash(bsl::size_t minimumCapacity)
{
    d_impl.rehash(minimumCapacity);
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
void FlatHashMap<KEY, VALUE, HASH, EQUAL>::reserve(bsl::size_t numEntries)
{
    d_impl.reserve(numEntries);
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
void FlatHashMap<KEY, VALUE, HASH, EQUAL>::reset()
{
    d_impl.reset();
}

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bdlc_flathashmap.h
#ifndef BDLC_FLATHASHMAP_VARIADIC_LIMIT
#define BDLC_FLATHASHMAP_VARIADIC_LIMIT 10
#endif
#ifndef BDLC_FLATHASHMAP_VARIADIC_LIMIT_F
#define BDLC_FLATHASHMAP_VARIADIC_LIMIT_F BDLC_FLATHASHMAP_VARIADIC_LIMIT
#endif
#ifdef BSLS_LIBRARYFEATURES_HAS_CPP11_PAIR_PIECEWISE_CONSTRUCTOR
#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 0
template <class KEY, class VALUE, class HASH, class EQUAL>
inline
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const KEY& key)
{
    return d_impl.try_emplace(
          key,
          std::piecewise_construct,
          std::forward_as_tuple(key),
          std::forward_as_tuple());
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 0

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 1
template <class KEY, class VALUE, class HASH, class EQUAL>
template< class ARGS_01>
inline
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const KEY& key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01)
{
    return d_impl.try_emplace(
          key,
          std::piecewise_construct,
          std::forward_as_tuple(key),
          std::forward_as_tuple(
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01)));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 1

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 2
template <class KEY, class VALUE, class HASH, class EQUAL>
template< class ARGS_01,
          class ARGS_02>
inline
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const KEY& key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02)
{
    return d_impl.try_emplace(
          key,
          std::piecewise_construct,
          std::forward_as_tuple(key),
          std::forward_as_tuple(
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02)));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 2

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 3
template <class KEY, class VALUE, class HASH, class EQUAL>
template< class ARGS_01,
          class ARGS_02,
          class ARGS_03>
inline
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const KEY& key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03)
{
    return d_impl.try_emplace(
          key,
          std::piecewise_construct,
          std::forward_as_tuple(key),
          std::forward_as_tuple(
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03)));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 3

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 4
template <class KEY, class VALUE, class HASH, class EQUAL>
template< class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04>
inline
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const KEY& key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04)
{
    return d_impl.try_emplace(
          key,
          std::piecewise_construct,
          std::forward_as_tuple(key),
          std::forward_as_tuple(
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04)));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 4

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 5
template <class KEY, class VALUE, class HASH, class EQUAL>
template< class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05>
inline
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const KEY& key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05)
{
    return d_impl.try_emplace(
          key,
          std::piecewise_construct,
          std::forward_as_tuple(key),
          std::forward_as_tuple(
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05)));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 5

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 6
template <class KEY, class VALUE, class HASH, class EQUAL>
template< class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06>
inline
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const KEY& key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06)
{
    return d_impl.try_emplace(
          key,
          std::piecewise_construct,
          std::forward_as_tuple(key),
          std::forward_as_tuple(
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06)));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 6

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 7
template <class KEY, class VALUE, class HASH, class EQUAL>
template< class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07>
inline
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const KEY& key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07)
{
    return d_impl.try_emplace(
          key,
          std::piecewise_construct,
          std::forward_as_tuple(key),
          std::forward_as_tuple(
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07)));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 7

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 8
template <class KEY, class VALUE, class HASH, class EQUAL>
template< class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08>
inline
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const KEY& key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08)
{
    return d_impl.try_emplace(
          key,
          std::piecewise_construct,
          std::forward_as_tuple(key),
          std::forward_as_tuple(
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08)));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 8

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 9
template <class KEY, class VALUE, class HASH, class EQUAL>
template< class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08,
          class ARGS_09>
inline
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const KEY& key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09)
{
    return d_impl.try_emplace(
          key,
          std::piecewise_construct,
          std::forward_as_tuple(key),
          std::forward_as_tuple(
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09)));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 9

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 10
template <class KEY, class VALUE, class HASH, class EQUAL>
template< class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08,
          class ARGS_09,
          class ARGS_10>
inline
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const KEY& key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10)
{
    return d_impl.try_emplace(
          key,
          std::piecewise_construct,
          std::forward_as_tuple(key),
          std::forward_as_tuple(
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_10, args_10)));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 10


#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 0
template <class KEY, class VALUE, class HASH, class EQUAL>
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(
                                      BloombergLP::bslmf::MovableRef<KEY> key)
{
    return d_impl.try_emplace(
          BSLS_COMPILERFEATURES_FORWARD(KEY, key),
          std::piecewise_construct,
          std::forward_as_tuple(BSLS_COMPILERFEATURES_FORWARD(KEY, key)),
          std::forward_as_tuple());
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 0

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 1
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01>
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(
                                      BloombergLP::bslmf::MovableRef<KEY> key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01)
{
    return d_impl.try_emplace(
          BSLS_COMPILERFEATURES_FORWARD(KEY, key),
          std::piecewise_construct,
          std::forward_as_tuple(BSLS_COMPILERFEATURES_FORWARD(KEY, key)),
          std::forward_as_tuple(
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01)));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 1

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 2
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02>
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(
                                      BloombergLP::bslmf::MovableRef<KEY> key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02)
{
    return d_impl.try_emplace(
          BSLS_COMPILERFEATURES_FORWARD(KEY, key),
          std::piecewise_construct,
          std::forward_as_tuple(BSLS_COMPILERFEATURES_FORWARD(KEY, key)),
          std::forward_as_tuple(
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02)));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 2

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 3
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03>
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(
                                      BloombergLP::bslmf::MovableRef<KEY> key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03)
{
    return d_impl.try_emplace(
          BSLS_COMPILERFEATURES_FORWARD(KEY, key),
          std::piecewise_construct,
          std::forward_as_tuple(BSLS_COMPILERFEATURES_FORWARD(KEY, key)),
          std::forward_as_tuple(
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03)));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 3

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 4
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04>
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(
                                      BloombergLP::bslmf::MovableRef<KEY> key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04)
{
    return d_impl.try_emplace(
          BSLS_COMPILERFEATURES_FORWARD(KEY, key),
          std::piecewise_construct,
          std::forward_as_tuple(BSLS_COMPILERFEATURES_FORWARD(KEY, key)),
          std::forward_as_tuple(
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04)));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 4

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 5
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05>
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(
                                      BloombergLP::bslmf::MovableRef<KEY> key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05)
{
    return d_impl.try_emplace(
          BSLS_COMPILERFEATURES_FORWARD(KEY, key),
          std::piecewise_construct,
          std::forward_as_tuple(BSLS_COMPILERFEATURES_FORWARD(KEY, key)),
          std::forward_as_tuple(
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05)));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 5

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 6
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06>
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(
                                      BloombergLP::bslmf::MovableRef<KEY> key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06)
{
    return d_impl.try_emplace(
          BSLS_COMPILERFEATURES_FORWARD(KEY, key),
          std::piecewise_construct,
          std::forward_as_tuple(BSLS_COMPILERFEATURES_FORWARD(KEY, key)),
          std::forward_as_tuple(
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06)));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 6

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 7
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07>
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(
                                      BloombergLP::bslmf::MovableRef<KEY> key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07)
{
    return d_impl.try_emplace(
          BSLS_COMPILERFEATURES_FORWARD(KEY, key),
          std::piecewise_construct,
          std::forward_as_tuple(BSLS_COMPILERFEATURES_FORWARD(KEY, key)),
          std::forward_as_tuple(
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07)));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 7

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 8
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08>
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(
                                      BloombergLP::bslmf::MovableRef<KEY> key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08)
{
    return d_impl.try_emplace(
          BSLS_COMPILERFEATURES_FORWARD(KEY, key),
          std::piecewise_construct,
          std::forward_as_tuple(BSLS_COMPILERFEATURES_FORWARD(KEY, key)),
          std::forward_as_tuple(
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08)));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 8

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 9
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08,
          class ARGS_09>
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(
                                      BloombergLP::bslmf::MovableRef<KEY> key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09)
{
    return d_impl.try_emplace(
          BSLS_COMPILERFEATURES_FORWARD(KEY, key),
          std::piecewise_construct,
          std::forward_as_tuple(BSLS_COMPILERFEATURES_FORWARD(KEY, key)),
          std::forward_as_tuple(
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09)));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 9

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 10
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08,
          class ARGS_09,
          class ARGS_10>
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(
                                      BloombergLP::bslmf::MovableRef<KEY> key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10)
{
    return d_impl.try_emplace(
          BSLS_COMPILERFEATURES_FORWARD(KEY, key),
          std::piecewise_construct,
          std::forward_as_tuple(BSLS_COMPILERFEATURES_FORWARD(KEY, key)),
          std::forward_as_tuple(
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS_10, args_10)));
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 10


#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 0
template <class KEY, class VALUE, class HASH, class EQUAL>
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const_iterator,
                                                  const KEY&      key)
{
    return d_impl.try_emplace(
          key,
          std::piecewise_construct,
          std::forward_as_tuple(key),
          std::forward_as_tuple())
          .first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 0

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 1
template <class KEY, class VALUE, class HASH, class EQUAL>
template<class ARGS_01>
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const_iterator,
                                                  const KEY&      key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01)
{
    return d_impl.try_emplace(
          key,
          std::piecewise_construct,
          std::forward_as_tuple(key),
          std::forward_as_tuple(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01)))
          .first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 1

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 2
template <class KEY, class VALUE, class HASH, class EQUAL>
template<class ARGS_01,
         class ARGS_02>
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const_iterator,
                                                  const KEY&      key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02)
{
    return d_impl.try_emplace(
          key,
          std::piecewise_construct,
          std::forward_as_tuple(key),
          std::forward_as_tuple(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02)))
          .first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 2

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 3
template <class KEY, class VALUE, class HASH, class EQUAL>
template<class ARGS_01,
         class ARGS_02,
         class ARGS_03>
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const_iterator,
                                                  const KEY&      key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03)
{
    return d_impl.try_emplace(
          key,
          std::piecewise_construct,
          std::forward_as_tuple(key),
          std::forward_as_tuple(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03)))
          .first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 3

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 4
template <class KEY, class VALUE, class HASH, class EQUAL>
template<class ARGS_01,
         class ARGS_02,
         class ARGS_03,
         class ARGS_04>
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const_iterator,
                                                  const KEY&      key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04)
{
    return d_impl.try_emplace(
          key,
          std::piecewise_construct,
          std::forward_as_tuple(key),
          std::forward_as_tuple(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04)))
          .first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 4

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 5
template <class KEY, class VALUE, class HASH, class EQUAL>
template<class ARGS_01,
         class ARGS_02,
         class ARGS_03,
         class ARGS_04,
         class ARGS_05>
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const_iterator,
                                                  const KEY&      key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05)
{
    return d_impl.try_emplace(
          key,
          std::piecewise_construct,
          std::forward_as_tuple(key),
          std::forward_as_tuple(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05)))
          .first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 5

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 6
template <class KEY, class VALUE, class HASH, class EQUAL>
template<class ARGS_01,
         class ARGS_02,
         class ARGS_03,
         class ARGS_04,
         class ARGS_05,
         class ARGS_06>
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const_iterator,
                                                  const KEY&      key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06)
{
    return d_impl.try_emplace(
          key,
          std::piecewise_construct,
          std::forward_as_tuple(key),
          std::forward_as_tuple(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06)))
          .first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 6

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 7
template <class KEY, class VALUE, class HASH, class EQUAL>
template<class ARGS_01,
         class ARGS_02,
         class ARGS_03,
         class ARGS_04,
         class ARGS_05,
         class ARGS_06,
         class ARGS_07>
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const_iterator,
                                                  const KEY&      key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07)
{
    return d_impl.try_emplace(
          key,
          std::piecewise_construct,
          std::forward_as_tuple(key),
          std::forward_as_tuple(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07)))
          .first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 7

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 8
template <class KEY, class VALUE, class HASH, class EQUAL>
template<class ARGS_01,
         class ARGS_02,
         class ARGS_03,
         class ARGS_04,
         class ARGS_05,
         class ARGS_06,
         class ARGS_07,
         class ARGS_08>
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const_iterator,
                                                  const KEY&      key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08)
{
    return d_impl.try_emplace(
          key,
          std::piecewise_construct,
          std::forward_as_tuple(key),
          std::forward_as_tuple(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08)))
          .first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 8

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 9
template <class KEY, class VALUE, class HASH, class EQUAL>
template<class ARGS_01,
         class ARGS_02,
         class ARGS_03,
         class ARGS_04,
         class ARGS_05,
         class ARGS_06,
         class ARGS_07,
         class ARGS_08,
         class ARGS_09>
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const_iterator,
                                                  const KEY&      key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09)
{
    return d_impl.try_emplace(
          key,
          std::piecewise_construct,
          std::forward_as_tuple(key),
          std::forward_as_tuple(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09)))
          .first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 9

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 10
template <class KEY, class VALUE, class HASH, class EQUAL>
template<class ARGS_01,
         class ARGS_02,
         class ARGS_03,
         class ARGS_04,
         class ARGS_05,
         class ARGS_06,
         class ARGS_07,
         class ARGS_08,
         class ARGS_09,
         class ARGS_10>
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const_iterator,
                                                  const KEY&      key,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10)
{
    return d_impl.try_emplace(
          key,
          std::piecewise_construct,
          std::forward_as_tuple(key),
          std::forward_as_tuple(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_10, args_10)))
          .first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 10


#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 0
template <class KEY, class VALUE, class HASH, class EQUAL>
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const_iterator,
                         BloombergLP::bslmf::MovableRef<KEY> key)
{
    return d_impl.try_emplace(
          BSLS_COMPILERFEATURES_FORWARD(KEY, key),
          std::piecewise_construct,
          std::forward_as_tuple(BSLS_COMPILERFEATURES_FORWARD(KEY, key)),
          std::forward_as_tuple())
          .first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 0

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 1
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01>
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const_iterator,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01)
{
    return d_impl.try_emplace(
          BSLS_COMPILERFEATURES_FORWARD(KEY, key),
          std::piecewise_construct,
          std::forward_as_tuple(BSLS_COMPILERFEATURES_FORWARD(KEY, key)),
          std::forward_as_tuple(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01)))
          .first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 1

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 2
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02>
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const_iterator,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02)
{
    return d_impl.try_emplace(
          BSLS_COMPILERFEATURES_FORWARD(KEY, key),
          std::piecewise_construct,
          std::forward_as_tuple(BSLS_COMPILERFEATURES_FORWARD(KEY, key)),
          std::forward_as_tuple(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02)))
          .first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 2

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 3
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03>
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const_iterator,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03)
{
    return d_impl.try_emplace(
          BSLS_COMPILERFEATURES_FORWARD(KEY, key),
          std::piecewise_construct,
          std::forward_as_tuple(BSLS_COMPILERFEATURES_FORWARD(KEY, key)),
          std::forward_as_tuple(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03)))
          .first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 3

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 4
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04>
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const_iterator,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04)
{
    return d_impl.try_emplace(
          BSLS_COMPILERFEATURES_FORWARD(KEY, key),
          std::piecewise_construct,
          std::forward_as_tuple(BSLS_COMPILERFEATURES_FORWARD(KEY, key)),
          std::forward_as_tuple(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04)))
          .first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 4

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 5
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05>
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const_iterator,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05)
{
    return d_impl.try_emplace(
          BSLS_COMPILERFEATURES_FORWARD(KEY, key),
          std::piecewise_construct,
          std::forward_as_tuple(BSLS_COMPILERFEATURES_FORWARD(KEY, key)),
          std::forward_as_tuple(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05)))
          .first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 5

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 6
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06>
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const_iterator,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06)
{
    return d_impl.try_emplace(
          BSLS_COMPILERFEATURES_FORWARD(KEY, key),
          std::piecewise_construct,
          std::forward_as_tuple(BSLS_COMPILERFEATURES_FORWARD(KEY, key)),
          std::forward_as_tuple(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06)))
          .first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 6

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 7
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07>
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const_iterator,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07)
{
    return d_impl.try_emplace(
          BSLS_COMPILERFEATURES_FORWARD(KEY, key),
          std::piecewise_construct,
          std::forward_as_tuple(BSLS_COMPILERFEATURES_FORWARD(KEY, key)),
          std::forward_as_tuple(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07)))
          .first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 7

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 8
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08>
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const_iterator,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08)
{
    return d_impl.try_emplace(
          BSLS_COMPILERFEATURES_FORWARD(KEY, key),
          std::piecewise_construct,
          std::forward_as_tuple(BSLS_COMPILERFEATURES_FORWARD(KEY, key)),
          std::forward_as_tuple(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08)))
          .first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 8

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 9
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08,
          class ARGS_09>
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const_iterator,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09)
{
    return d_impl.try_emplace(
          BSLS_COMPILERFEATURES_FORWARD(KEY, key),
          std::piecewise_construct,
          std::forward_as_tuple(BSLS_COMPILERFEATURES_FORWARD(KEY, key)),
          std::forward_as_tuple(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09)))
          .first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 9

#if BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 10
template <class KEY, class VALUE, class HASH, class EQUAL>
template <class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08,
          class ARGS_09,
          class ARGS_10>
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const_iterator,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10)
{
    return d_impl.try_emplace(
          BSLS_COMPILERFEATURES_FORWARD(KEY, key),
          std::piecewise_construct,
          std::forward_as_tuple(BSLS_COMPILERFEATURES_FORWARD(KEY, key)),
          std::forward_as_tuple(
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09),
                              BSLS_COMPILERFEATURES_FORWARD(ARGS_10, args_10)))
          .first;
}
#endif  // BDLC_FLATHASHMAP_VARIADIC_LIMIT_F >= 10

#endif
#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
#ifdef BSLS_LIBRARYFEATURES_HAS_CPP11_PAIR_PIECEWISE_CONSTRUCTOR
template <class KEY, class VALUE, class HASH, class EQUAL>
template< class... ARGS>
inline
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const KEY& key,
                               BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args)
{
    return d_impl.try_emplace(
          key,
          std::piecewise_construct,
          std::forward_as_tuple(key),
          std::forward_as_tuple(BSLS_COMPILERFEATURES_FORWARD(ARGS, args)...));
}

template <class KEY, class VALUE, class HASH, class EQUAL>
template <class... ARGS>
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator, bool>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(
                                      BloombergLP::bslmf::MovableRef<KEY> key,
                               BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args)
{
    return d_impl.try_emplace(
          BSLS_COMPILERFEATURES_FORWARD(KEY, key),
          std::piecewise_construct,
          std::forward_as_tuple(BSLS_COMPILERFEATURES_FORWARD(KEY, key)),
          std::forward_as_tuple(BSLS_COMPILERFEATURES_FORWARD(ARGS, args)...));
}

template <class KEY, class VALUE, class HASH, class EQUAL>
template<class... ARGS>
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const_iterator,
                                                  const KEY&      key,
                               BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args)
{
    return d_impl.try_emplace(
          key,
          std::piecewise_construct,
          std::forward_as_tuple(key),
          std::forward_as_tuple(BSLS_COMPILERFEATURES_FORWARD(ARGS, args)...))
          .first;
}

template <class KEY, class VALUE, class HASH, class EQUAL>
template <class... ARGS>
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::try_emplace(const_iterator,
                         BloombergLP::bslmf::MovableRef<KEY> key,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args)
{
    return d_impl.try_emplace(
          BSLS_COMPILERFEATURES_FORWARD(KEY, key),
          std::piecewise_construct,
          std::forward_as_tuple(BSLS_COMPILERFEATURES_FORWARD(KEY, key)),
          std::forward_as_tuple(BSLS_COMPILERFEATURES_FORWARD(ARGS, args)...))
          .first;
}
#endif
// }}} END GENERATED CODE
#endif

                          // Iterators

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
                                  FlatHashMap<KEY, VALUE, HASH, EQUAL>::begin()
{
    return d_impl.begin();
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::iterator
                                    FlatHashMap<KEY, VALUE, HASH, EQUAL>::end()
{
    return d_impl.end();
}

                             // Aspects

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
void FlatHashMap<KEY, VALUE, HASH, EQUAL>::swap(FlatHashMap& other)
{
    BSLS_ASSERT_SAFE(allocator() == other.allocator());

    d_impl.swap(other.d_impl);
}

// ACCESSORS
template <class KEY, class VALUE, class HASH, class EQUAL>
inline
const VALUE& FlatHashMap<KEY, VALUE, HASH, EQUAL>::at(const KEY& key) const
{
    const_iterator node = d_impl.find(key);

    if (node == d_impl.end()) {
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                    "FlatHashMap<...>::at(key_type) const: invalid key value");
    }

    return node->second;
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
bsl::size_t FlatHashMap<KEY, VALUE, HASH, EQUAL>::capacity() const
{
    return d_impl.capacity();
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
bool FlatHashMap<KEY, VALUE, HASH, EQUAL>::contains(const KEY& key) const
{
    return d_impl.contains(key);
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
bsl::size_t FlatHashMap<KEY, VALUE, HASH, EQUAL>::count(const KEY& key) const
{
    return d_impl.count(key);
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
bool FlatHashMap<KEY, VALUE, HASH, EQUAL>::empty() const
{
    return d_impl.empty();
}

template <class KEY, class VALUE, class HASH, class EQUAL>
bsl::pair<typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::const_iterator,
          typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::const_iterator>
FlatHashMap<KEY, VALUE, HASH, EQUAL>::equal_range(const KEY& key) const
{
    return d_impl.equal_range(key);
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::const_iterator
FlatHashMap<KEY, VALUE, HASH, EQUAL>::find(const KEY& key) const
{
    return d_impl.find(key);
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
HASH FlatHashMap<KEY, VALUE, HASH, EQUAL>::hash_function() const
{
    return d_impl.hash_function();
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
EQUAL FlatHashMap<KEY, VALUE, HASH, EQUAL>::key_eq() const
{
    return d_impl.key_eq();
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
float FlatHashMap<KEY, VALUE, HASH, EQUAL>::load_factor() const
{
    return d_impl.load_factor();
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
float FlatHashMap<KEY, VALUE, HASH, EQUAL>::max_load_factor() const
{
    return d_impl.max_load_factor();
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
bsl::size_t FlatHashMap<KEY, VALUE, HASH, EQUAL>::size() const
{
    return d_impl.size();
}

                          // Iterators

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::const_iterator
                      FlatHashMap<KEY, VALUE, HASH, EQUAL>::begin() const
{
    return d_impl.begin();
}
template <class KEY, class VALUE, class HASH, class EQUAL>
inline
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::const_iterator
                     FlatHashMap<KEY, VALUE, HASH, EQUAL>::cbegin() const
{
    return d_impl.cbegin();
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::const_iterator
                       FlatHashMap<KEY, VALUE, HASH, EQUAL>::cend() const
{
    return d_impl.cend();
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
typename FlatHashMap<KEY, VALUE, HASH, EQUAL>::const_iterator
                        FlatHashMap<KEY, VALUE, HASH, EQUAL>::end() const
{
    return d_impl.end();
}

                             // Aspects

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
bslma::Allocator *FlatHashMap<KEY, VALUE, HASH, EQUAL>::allocator() const
{
    return d_impl.allocator();
}

template <class KEY, class VALUE, class HASH, class EQUAL>
bsl::ostream& FlatHashMap<KEY, VALUE, HASH, EQUAL>::print(
                                            bsl::ostream& stream,
                                            int           level,
                                            int           spacesPerLevel) const
{
    if (stream.bad()) {
        return stream;                                                // RETURN
    }

    bslim::Printer printer(&stream, level, spacesPerLevel);

    printer.start();

    const_iterator iter = begin();
    while (iter != end()) {
        printer.printValue(*iter);
        ++iter;
    }

    printer.end();

    return stream;
}

}  // close package namespace

// FREE OPERATORS
template <class KEY, class VALUE, class HASH, class EQUAL>
inline
bool bdlc::operator==(const FlatHashMap<KEY, VALUE, HASH, EQUAL>& lhs,
                      const FlatHashMap<KEY, VALUE, HASH, EQUAL>& rhs)
{
    return lhs.d_impl == rhs.d_impl;
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
bool bdlc::operator!=(const FlatHashMap<KEY, VALUE, HASH, EQUAL>& lhs,
                      const FlatHashMap<KEY, VALUE, HASH, EQUAL>& rhs)
{
    return lhs.d_impl != rhs.d_impl;
}

template <class KEY, class VALUE, class HASH, class EQUAL>
inline
bsl::ostream& bdlc::operator<<(
                            bsl::ostream&                               stream,
                            const FlatHashMap<KEY, VALUE, HASH, EQUAL>& map)
{
    return map.print(stream, 0, -1);
}

// FREE FUNCTIONS
template <class KEY, class VALUE, class HASH, class EQUAL>
inline
void bdlc::swap(FlatHashMap<KEY, VALUE, HASH, EQUAL>& a,
                FlatHashMap<KEY, VALUE, HASH, EQUAL>& b)
{
    bslalg::SwapUtil::swap(&a.d_impl, &b.d_impl);
}

// ============================================================================
//                                TYPE TRAITS
// ============================================================================

namespace bslalg {

template <class KEY, class VALUE, class HASH, class EQUAL>
struct HasStlIterators<bdlc::FlatHashMap<KEY, VALUE, HASH, EQUAL> >
: bsl::true_type {
};

}  // close namespace bslalg

namespace bslma {

template <class KEY, class VALUE, class HASH, class EQUAL>
struct UsesBslmaAllocator<bdlc::FlatHashMap<KEY, VALUE, HASH, EQUAL> >
: bsl::true_type {
};

}  // close namespace bslma
}  // close enterprise namespace

#else // if ! defined(DEFINED_BDLC_FLATHASHMAP_H)
# error Not valid except when included from bdlc_flathashmap.h
#endif // ! defined(COMPILING_BDLC_FLATHASHMAP_H)

#endif // ! defined(INCLUDED_BDLC_FLATHASHMAP_CPP03)

// ----------------------------------------------------------------------------
// Copyright 2020 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
